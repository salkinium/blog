<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US"><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="http://blog.salkinium.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://blog.salkinium.com/" rel="alternate" type="text/html" hreflang="en-US" /><updated>2021-07-05T01:11:44+02:00</updated><id>http://blog.salkinium.com/feed.xml</id><title type="html">embedded entanglement</title><subtitle>reflecting on embedded software development</subtitle><author><name>Niklas Hauser</name><email>niklas@salkinium.com</email></author><entry><title type="html">Accurate Micro- and Nanosecond Delay in modm</title><link href="http://blog.salkinium.com/modm-delay/" rel="alternate" type="text/html" title="Accurate Micro- and Nanosecond Delay in modm" /><published>2021-07-05T00:00:00+02:00</published><updated>2021-07-05T00:00:00+02:00</updated><id>http://blog.salkinium.com/modm-delay</id><content type="html" xml:base="http://blog.salkinium.com/modm-delay/">&lt;p&gt;Accurately spinning for short and long time durations is an essential part of an embedded application. In the &lt;a href=&quot;https://modm.io&quot;&gt;modm embedded library&lt;/a&gt; we provide blocking delay functions in the resolution of milli-, micro- and even nanoseconds. Let me show you how we used the available hardware to implement a fast, efficient and flexible API that works with thousands of devices all with different clock configurations.&lt;/p&gt;

&lt;p&gt;The most prominent uses for blocking delays in modm are during initialization of internal peripherals and external drivers that may require a few micro- to milliseconds to stabilize their hardware, and when bit-banging protocols in software with kHz and MHz baudrates requiring micro- or even nanosecond delay.&lt;/p&gt;

&lt;p&gt;The delay functions must be as accurate as possible. In particular they must have the shortest possible overhead and a low error over at least 1s of delay. They must already work before main (during the global constructor calls) and remain accurate if the clock configuration and therefore the CPU frequency dynamically changes. They must also be reentrant so they can be called from inside an interrupt if needed. And lastly they should be compatible with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::chrono&lt;/code&gt; time units, so that we can pass them literals for ease of use:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mx&quot;&gt;1s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// non-literal version&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mx&quot;&gt;10ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mx&quot;&gt;100us&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay_us&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mx&quot;&gt;1000ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;computing-cycles&quot;&gt;Computing Cycles&lt;/h1&gt;

&lt;p&gt;The simplest delay function converts the input time to CPU cycles and then spins in place counting them down. For the conversion we need to know the CPU frequency and have some mechanism for keeping track of elapsed CPU cycles.&lt;/p&gt;

&lt;p&gt;For microsecond and longer delays the conversion is simple: &lt;em&gt;1µs = 1MHz&lt;sup&gt;-1&lt;/sup&gt;&lt;/em&gt;, so you can just take the CPU frequency in MHz and multiply it with the input to get the cycles. We store the frequency in a global &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uint16_t&lt;/code&gt; already scaled down to MHz and initialized with the boot frequency during startup.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// microcontroller boots with a 8MHz clock&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint16_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fcpu_MHz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// simple conversion with multiplication&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cycles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;us&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fcpu_MHz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This works well for frequencies that divide 1MHz cleanly, however, the STM32L0/L1 microcontrollers boot at 2.097MHz for example, which results in a 5% error right after boot. We therefore binary scale the MHz value to achieve a much lower error, which can be done very efficiently with bit shifting:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// multiply MHz with power-of-two 2^5 = 32&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 2.097MHz * 32  -&amp;gt;  67 = 2.09375MHz  -&amp;gt;  ~0.2% error&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;constinit&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint16_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fcpu_MHz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;round&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.097&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1ul&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// divide with simple bit shift&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cycles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;us&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fcpu_MHz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To keep the 32-bit multiplication from overflowing and to maintain at least 1s = 1’000’000µs of delay, we must limit the scaling so that &lt;em&gt;2&lt;sup&gt;32 - shift&lt;/sup&gt; / max_fcpu ≥ 1s&lt;/em&gt;. A scalar of 32 (shift 5) is only good up to 134MHz, while the fastest STM32H7 running at 480MHz limits the scalar to only 8 (shift 3).&lt;/p&gt;

&lt;p&gt;For nanosecond delay we need a different algorithm, since the microcontrollers all run below 1GHz so one CPU cycle is several nanoseconds long. For example, the STM32F7 runnning at 216MHz will take ~4.6ns per cycle. To get the cycles from a nanosecond input we would need to &lt;em&gt;divide&lt;/em&gt;:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ns_per_cycle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;4.6&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cycles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ns_per_cycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is obviously way too slow to compute, but we first need to understand how to accurately &lt;em&gt;count&lt;/em&gt; cycles to find a better solution to this problem.&lt;/p&gt;

&lt;h1 id=&quot;counting-cycles&quot;&gt;Counting Cycles&lt;/h1&gt;

&lt;p&gt;Wouldn’t it be nice if we could just delegate counting cycles to some hardware counter? Well, look no further than the Data Watchpoint and Trace (DWT) peripheral and its 32-bit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CYCCNT&lt;/code&gt; free running at CPU frequency!&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Enable Tracing Debug Unit&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;CoreDebug&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DEMCR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoreDebug_DEMCR_TRCENA_Msk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Enable CPU cycle counter&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;DWT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CTRL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DWT_CTRL_CYCCNTENA_Msk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;By reading &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DWT-&amp;gt;CYCCNT&lt;/code&gt; once at the beginning and then comparing this constantly in a loop until the number of cycles have passed, we can implement a very simple, yet very accurate delay function:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay_us&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;us&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DWT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CYCCNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cycles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fcpu_MHz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;us&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;now&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DWT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CYCCNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;now&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cycles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Bonus win for this solution: time spent in interrupts during the delay is compensated for, since the hardware counter continues counting throughout.&lt;/p&gt;

&lt;h1 id=&quot;counting-loops&quot;&gt;Counting Loops&lt;/h1&gt;

&lt;p&gt;Unfortunately, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DWT&lt;/code&gt; peripheral is not accessible in all ARMv7-M devices (NRF52 only allows the debugger to access it) and it’s not even implemented on ARM Cortex-M0(+) aka. ARMv6-M devices, so we have to count cycles a different way. We could use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SysTick-&amp;gt;VAL&lt;/code&gt;, however it’s just a 24-bit counter, which limits us to ~16.8 million cycles: a ~1s delay at 16MHz or a maximum 35ms delay (!) at 480MHz. In addition, the SysTick is often used for preemptive scheduling (in FreeRTOS) or to create a global clock (for software timers), so we cannot use it as a replacement.&lt;/p&gt;

&lt;p&gt;Instead we will count cycles the old fashioned way: in a tight assembly loop with a known timing. We use two 16-bit Thumb-2 instructions: &lt;a href=&quot;https://www.keil.com/support/man/docs/armasm/armasm_dom1361289908389.htm&quot;&gt;subtraction with condition flags update&lt;/a&gt; and &lt;a href=&quot;https://www.keil.com/support/man/docs/armasm/armasm_dom1361289863797.htm&quot;&gt;branch back if positive&lt;/a&gt;. They are aligned so they fit into a single 32-bit instruction fetch and fill the pipeline entirely, giving us the maximum performance: 1 cycle for the subtraction and 2-cycles to branch back, so the loop takes 3 cycles total:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay_us&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;us&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modm_fastcode&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cycles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fcpu_MHz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;us&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;asm&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;.align 4&quot;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// align for *one* 32-bit instruction fetch&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;1:  subs %0, %0, #3&quot;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// subtract the loop cycles&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;bpl  1b&quot;&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;// loop while cycles are positive&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;l&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cycles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The instruction fetch timings for executing directly from Flash depends on the CPU speed, the currently configured wait states and the state of the instruction cache (if available and configured) and finally the branch speculation of the cache implementation. We therefore place the entire function into SRAM using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modm_fastcode&lt;/code&gt; attribute, which gives us &lt;em&gt;predictable&lt;/em&gt; timings for instruction fetches across all Cortex-M cores, since we’re bypassing the Flash wait states and the (vendor supplied) cache entirely.&lt;/p&gt;

&lt;p&gt;Predictable, but not consistent: In my experiments I’ve discovered the loop to take 3 cycles on STM32{F3, G0, G4, L0, L4}, 4 cycles on STM32{L1, F0, F1, F4, F2} and just 1 cycle (!) on STM32F7. The timings depend on the (vendor defined) bus matrix implementation and the system configuration and are mainly about whether the Instruction Bus (I-Code) can access SRAM directly or whether the access is performed by the slower System Bus (S-Bus). The &lt;a href=&quot;https://www.st.com/resource/en/reference_manual/dm00031020-stm32f405-415-stm32f407-417-stm32f427-437-and-stm32f429-439-advanced-arm-based-32-bit-mcus-stmicroelectronics.pdf#page=68&quot;&gt;STM32F4 reference manual states in section 2.3.1 Embedded SRAM&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The CPU can access the SRAM1, SRAM2, and SRAM3 through the System Bus or through the I-Code/D-Code buses when boot from SRAM is selected or when physical remap is selected. To get the max performance on SRAM execution, physical remap should be selected (boot or software selection).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It seems that access through the I-Code takes 2-cycles, but the S-Bus takes 4-cycles, while the Cortex-M7 has a dual issue pipeline and native instruction cache with native branch prediction, so it’s just… really fast ? As confusing as it might be, at least the instruction fetch timing from SRAM is independent from the configured CPU frequency, which allows us to hardcode the loop cycles to subtract as an immediate value encoded in the instruction.&lt;/p&gt;

&lt;p&gt;The upper bound on the error is at most 3 cycles plus the error of the binary scaling, which together is good enough for our purpose. However, interrupts are not compensated, so the real delay may be significantly longer. If an accurate delay is absolutely necessary it can be wrapped into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modm::atomic::Lock&lt;/code&gt; to disable interrupts during the delay.&lt;/p&gt;

&lt;h1 id=&quot;counting-nanoseconds&quot;&gt;Counting Nanoseconds&lt;/h1&gt;

&lt;p&gt;To delay for nanoseconds we need to do something a little different, since the naive approach involves division, which would be way too slow. We can, however, approximate this division with a loop of subtractions! So we input the nanoseconds into the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subs bpl&lt;/code&gt; loop and subtract the nanoseconds each loop takes. We store this value in SRAM and update it on every clock change:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cycles_per_loop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1-4 cycles, depends on device&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// round the nanoseconds to minimize error&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint16_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ns_per_loop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;round&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1e9&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cycles_per_loop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fcpu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modm_fastcode&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;asm&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;.align 4&quot;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// align for *one* 32-bit instruction fetch&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;1:  subs %0, %0, %1&quot;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// subtract the nanoseconds per loop&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;bpl  1b&quot;&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;// loop while nanoseconds are positive&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;l&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;l&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ns_per_loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This works, however, there is a large overhead until execution arrives at the loop. The reason is that the compiler uses a &lt;a href=&quot;https://www.keil.com/support/man/docs/armasm/armasm_dom1361289865686.htm&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bl&lt;/code&gt; (branch and link) instruction&lt;/a&gt; to jump to an address encoded as an &lt;em&gt;immediate value&lt;/em&gt;. This is fast and efficient, however, it limits us to a relative address range of ±16MBs and our delay function in SRAM is waaaaay out there (SRAM starts @0x20000000 vs Flash @0x08000000). So the linker has to add a veneer, that does nothing else but jump further by loading the address into a register and loading it into the program counter therefore jumping:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        modm::delay_ns(ns);
 8000214:   f002 fbf4   bl  8002a00 &amp;lt;___ZN4modm8delay_nsEm_veneer&amp;gt;

08002a00 &amp;lt;___ZN4modm8delay_nsEm_veneer&amp;gt;:
 8002a00:   f85f f000   ldr.w   pc, [pc]    ; 8002a04
 8002a04:   20000189    .word   0x20000189

20000188 &amp;lt;_ZN4modm8delay_nsEm&amp;gt;:
void modm_fastcode modm::delay_ns(uint32_t us)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Since Flash access is very slow (up to a dozen wait states for fast devices), vendors supply a cache implementation with a large, but limited buffer size (the STM32F4 cache has 64 cache lines of 128-bit = 1kB!). So the jump to a veneer outside of the 1kB range spends many cycles just waiting on the Flash and this time depends on the current clock configuration. Can we do better? Yes, with inline assembly!&lt;/p&gt;

&lt;p&gt;We move the actual implementation to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modm::platform::delay_ns&lt;/code&gt; and then use an forced-inline forwarding function that uses the &lt;a href=&quot;https://www.keil.com/support/man/docs/armasm/armasm_dom1361289866046.htm&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blx&lt;/code&gt; instruction&lt;/a&gt; to jump there directly instead of through a veneer:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;modm_always_inline&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;asm&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;mov r0, %0&quot;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Pass the argument in r0 as per EABI&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;blx %1&quot;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// Jump there directly&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;r&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;l&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;platform&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;r0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;r1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;r2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This reduces the overhead by eliminating the unnecessary jump and loading a literal from Flash that much closer to the execution site (here &lt;em&gt;0x35c - 0x2cc = 0x90 = 144 bytes&lt;/em&gt;) and therefore most likely already in the cache:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        modm::delay_ns(ns);
 80002c6:   4c25        ldr r4, [pc, #148]  ; 800035c
 80002ca:   4628        mov r0, r5
 80002cc:   47a0        blx r4

 800035c:   200001a9    .word   0x200001a9

200001a8 &amp;lt;_ZN4modm8platform8delay_nsEm&amp;gt;:
void modm_fastcode modm::platform::delay_ns(uint32_t us)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;However, we still need to actually compensate for this overhead, even if it’s just a few cycles, there should not be an offset in the delay function. To have maximum control we declare the function to be naked and implement the whole function in inline assembly:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__attribute__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;naked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aligned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modm_fastcode&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;platform&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// passed in r0&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;asm&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;ldr  r2, =ns_per_loop&quot;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// address of ns_per_loop&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;ldrh r2, [r2, #0]&quot;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// load the actual 16-bit ns_per_loop value&lt;/span&gt;

        &lt;span class=&quot;s&quot;&gt;&quot;lsls r1, r2, #2&quot;&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// approximate overhead in ns by shifting&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;subs r0, r0, r1&quot;&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// subtract the overhead in nanoseconds&lt;/span&gt;

    &lt;span class=&quot;s&quot;&gt;&quot;1:  subs r0, r0, r2&quot;&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// subtract the nanoseconds per loop&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;bpl  1b&quot;&lt;/span&gt;               &lt;span class=&quot;c1&quot;&gt;// loop while nanoseconds are positive&lt;/span&gt;

        &lt;span class=&quot;s&quot;&gt;&quot;bx lr&quot;&lt;/span&gt;                   &lt;span class=&quot;c1&quot;&gt;// return to execution&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The overhead is measured experimentally and expressed in loops, which we can convert to nanoseconds by multiplying with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ns_per_loop&lt;/code&gt; variable. However the &lt;a href=&quot;https://www.keil.com/support/man/docs/armasm/armasm_dom1361289882394.htm&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mul&lt;/code&gt; instruction&lt;/a&gt; requires passing the operands in registers, which would require an additional &lt;a href=&quot;https://www.keil.com/support/man/docs/armasm/armasm_dom1361289878994.htm&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mov&lt;/code&gt; instruction&lt;/a&gt; to put the value into a register, so instead we use the &lt;a href=&quot;https://www.keil.com/support/man/docs/armasm/armasm_dom1361289876185.htm&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lsl&lt;/code&gt; instruction&lt;/a&gt; to shift the value left with the same effect. This limits the “overhead loop count” to powers of two, which in practice is not an issue.&lt;/p&gt;

&lt;p&gt;In the above code we’re using 4 loops as overhead (so about 12-16 cycles at 3-4 cycles per loop), which is equivalent to shifting left by 2, hence the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#2&lt;/code&gt; immediate value in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lsl&lt;/code&gt; instruction.&lt;/p&gt;

&lt;h1 id=&quot;counting-cycles-on-avr&quot;&gt;Counting Cycles on AVR&lt;/h1&gt;

&lt;p&gt;AVRs cannot change their CPU frequency at runtime, instead it is fixed at compile time via the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F_CPU&lt;/code&gt; macro, so we don’t have to worry about that. The avr-lib provide implementations of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_delay_ms(double)&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_delay_us(double)&lt;/code&gt; in the &lt;a href=&quot;https://www.nongnu.org/avr-libc/user-manual/group__util__delay.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;util/delay.h&amp;gt;&lt;/code&gt; header&lt;/a&gt;: However, &lt;a href=&quot;https://www.nongnu.org/avr-libc/user-manual/delay_8h_source.html&quot;&gt;the implementations use floating point math to calculate the delay cycles&lt;/a&gt; for runtime arguments. But fear not for there is a very sternly worded warning for passing a dynamic value to this incredibly powerful foot gun:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In order for these functions to work as intended, compiler optimizations must be enabled, and the delay time must be an expression that is a known constant at compile-time. If these requirements are not met, the resulting delay will be much longer (and basically unpredictable), and applications that otherwise do not use floating-point calculations will experience severe code bloat by the floating-point library routines linked into the application.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Of course this is a completely unacceptable implementation, since avr-gcc provides &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__builtin_constant_p()&lt;/code&gt;&lt;/a&gt; to detect constant arguments and together with &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/AVR-Built-in-Functions.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__builtin_avr_delay_cycles(uint32_t)&lt;/code&gt;&lt;/a&gt; can generates very accurate delays down to a single cycle for constant inputs at any clock rate.&lt;/p&gt;

&lt;p&gt;For a delay with a runtime argument we can loop over a 1ms or 1us constant delay and compensate for the loop overhead:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;modm_always_inline&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;lt;- must be force inlined to work&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;__builtin_constant_p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cycles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ceil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F_CPU&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1e3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;__builtin_avr_delay_cycles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cycles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__builtin_avr_delay_cycles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F_CPU&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1e3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;modm_always_inline&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay_us&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;us&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;__builtin_constant_p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;us&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cycles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ceil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F_CPU&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;us&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1e6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;__builtin_avr_delay_cycles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cycles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// slightly lower overhead due to 16-bit delay  vvv&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;us&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__builtin_avr_delay_cycles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F_CPU&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1e6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For dynamic nanosecond delay we approximate the division again with a shift, however, this time without multiplication, since that operation is very expensive on AVRs (dozens of cycles). The shift value is computed at compile time by rounding to the nearest power-of-two. The result is passed to the 4-cycle &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_delay_loop_2(uint16_t)&lt;/code&gt;, which does the actual delay. This solution only yields accurate delays at 16MHz (shift 8), 8MHz (shift 9) and 4MHz (shift 10), and has a significant error plus additional overhead of a few cycles for shifts &amp;gt; 8. It’s also limited to 24-bits of input or about 16ms. It’s not an ideal solution, but all other ideas yielded significantly worse results incl. using the Cortex-M method of subtraction in a loop.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;modm_always_inline&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;__builtin_constant_p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cycles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ceil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F_CPU&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1e9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;__builtin_avr_delay_cycles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cycles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint16_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loops&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loops&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_delay_loop_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loops&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;using-stdchrono&quot;&gt;Using std::chrono&lt;/h1&gt;

&lt;p&gt;We want these functions to be compatible with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;using namespace std::chrono_literals&lt;/code&gt;, so we overload the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modm::delay()&lt;/code&gt; function with the appropriate durations. The conversion gets completely inlined and optimized away, so even for dynamic arguments there’s no code generated. A notable exception is the millisecond delay on Cortex-M, which gets converted to microseconds via a fast multiplication.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Rep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chrono&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;duration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nano&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ns_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chrono&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;duration_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chrono&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nanoseconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)};&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ns_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Rep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chrono&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;duration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;micro&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;us&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;us_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chrono&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;duration_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chrono&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;microseconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;us&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)};&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay_us&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;us_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Rep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chrono&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;duration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;milli&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// converted to us on Cortex-M, but AVR just forwards to modm::delay_ms&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;us&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chrono&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;duration_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chrono&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;microseconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)};&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay_us&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;us&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;evaluation&quot;&gt;Evaluation&lt;/h1&gt;

&lt;p&gt;We can test the performance of our delay functions with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DWT-&amp;gt;CYCCNT&lt;/code&gt; on ARMv7-M which has a fixed 4 cycle overhead:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DWT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CYCCNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DWT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CYCCNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cycles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 4 cycles overhead&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ARMv6-M has no DWT module, so we use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SysTick-&amp;gt;VAL&lt;/code&gt; instead. The value counts down (!) and gets reloaded to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SysTick-&amp;gt;LOAD&lt;/code&gt; on underrun. We need to make sure the underrun does not happen during measurement so we reload the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SysTick-&amp;gt;VAL&lt;/code&gt;before it. The 24-bit value limits our measurement duration to 262ms @ 64MHz (the fastest ARMv6-M tested).&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;SysTick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VAL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SysTick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LOAD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SysTick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SysTick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cycles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// swapped subtraction!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And finally on AVRs we use the 16-bit Timer/Counter 1, which limits the measurement duration (but not the delay functions) to 4ms @16MHz.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint16_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TCNT1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint16_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TCNT1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint16_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cycles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In total 19 devices were tested by passing the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modm::delay_ns()&lt;/code&gt; function durations from 0ns to 10000ns in 10ns steps. The Cortex-M devices were tested once at boot frequency and then again at their highest frequency.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Device&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Core Type&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Cycles per Loop&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Minimum Cycles at Boot/High Frequency&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Minimum Delay at Boot Frequency&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Minimum Delay at High Frequency&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ATMEGA2560&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;avr8&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1000ns @ 16     MHz&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;SAMD21&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;cm0+&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;15&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;312ns @  48 MHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;STM32F072&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;cm0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;18/19&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1125ns @ 16     MHz&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;395ns @  48 MHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;STM32F091&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;cm0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;18/19&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1125ns @ 16     MHz&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;395ns @  48 MHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;STM32F103&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;cm3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2000ns @  8     MHz&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;250ns @  64 MHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;STM32F303&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;cm4f&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;13&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1625ns @  8     MHz&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;203ns @  64 MHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;STM32F334&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;cm4f&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;13&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1625ns @  8     MHz&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;203ns @  64 MHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;STM32F401&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;cm4f&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1000ns @ 16     MHz&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;190ns @  84 MHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;STM32F411&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;cm4f&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1000ns @ 16     MHz&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;166ns @  96 MHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;STM32F429&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;cm4f&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1000ns @ 16     MHz&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;95ns @ 168 MHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;STM32F446&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;cm4f&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1000ns @ 16     MHz&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;88ns @ 180 MHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;STM32F469&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;cm4f&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1000ns @ 16     MHz&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;88ns @ 180 MHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;STM32F746&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;cm7fd&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;19&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1187ns @ 16     MHz&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;87ns @ 216 MHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;STM32G071&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;cm0+&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16/18&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1000ns @ 16     MHz&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;281ns @  64 MHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;STM32G474&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;cm4f&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;17&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1062ns @ 16     MHz&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;100ns @ 170 MHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;STM32L031&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;cm0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16/17&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;7629ns @  2.097 MHz&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;531ns @  32 MHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;STM32L152&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;cm3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16/17&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;7629ns @  2.097 MHz&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;531ns @  32 MHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;STM32L432&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;cm4f&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;13/15&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;812ns @ 16     MHz&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;162ns @  80 MHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;STM32L476&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;cm4f&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;13/15&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;812ns @ 16     MHz&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;312ns @  48 MHz&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The absolute minimum delay we can achieve is ~90ns and only on devices with a fast clock. You can clearly see the effects of the additional flash wait-states despite the cache on some devices after switching to high frequency.&lt;/p&gt;

&lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;ns_boot.svg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The graph of nanosecond delay at boot frequency shows several interesting points:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The above mentioned minimum delays are very clear, particularly the ~7600ns minimum delay for the STM32L0 and STM32L1 which boot at only ~2MHz.&lt;/li&gt;
  &lt;li&gt;A ~600ns offset on AVR: This is not surprising as our implementation does not compensate for the calling overhead at all.&lt;/li&gt;
  &lt;li&gt;A percentual error on AVR: At 16MHz the correct divider would be 250 for a 4-cycle loop, however, we’re shifting 8 = divide by 256, which is a 2.5% error. For other frequencies this error will be much higher.&lt;/li&gt;
  &lt;li&gt;An offset on STM32F7: The correct offset compensation would be ~26 loops, however our “shift multiplication” can only do 16 or 32 loops, hence this offset. The Cortex-M7 has built-in branch prediction, perhaps that explains the small irregularity at the beginning.&lt;/li&gt;
  &lt;li&gt;The coarseness of the stepping varies, showing the effect of different clock speeds and cycles per loop.&lt;/li&gt;
  &lt;li&gt;Most implemementations follow the ideal delay line very closely.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;ns_high.svg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The graph of nanosecond delay at high frequency shows that all implementations follow the ideal delay very precisely with no significant offset or error.&lt;/p&gt;

&lt;p&gt;The notable exception is the STM32F7 implementation, which has a significant ~7.5% error over time. Running at 216MHz a 1-cycle loop takes ~4.6ns which gets rounded up to 5ns which is then subtracted on every 1-cycle loop, thus yielding this error. This creates an interesting failure mode for this delay algorithm: At around 667MHz the error is highest at 50%, since a 1.5ns per loop (=1ns/667MHz) delay must be rounded to either 1ns or 2ns. Currently no STM32 runs at that high a speed, however, the STM32H7 can run at at 400MHz (≤480MHz), where the error would still be 25%.&lt;/p&gt;

&lt;p&gt;The delay implementation on other devices has the same problem, however, since the loop takes 3-4 cycles the error is much smaller. For example, the 3-cycle loop on the STM32G4 running at a comparable 170MHz takes ~17.6ns (=3ns/170MHz) ≈ 18ns per loop, which is an error of just ~2%. In contrast, the 4-cycle loop on the 64MHz STM32F1 takes 62.5ns (=4ns/64MHz) ≈ 63ns with an error of ~1%.&lt;/p&gt;

&lt;p&gt;It becomes clear that the subtraction spreads the rounding error over 3-4 cycles which essentially functions as a fractional integer division. So an easy fix for the 1-cycle loop error on the STM32F7 is to lengthen the loop with some NOPs to reduce the overall error at the cost of resolution. I will leave this for a future self to solve though.&lt;/p&gt;

&lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;ns_high_detail.svg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A detailed version of nanosecond delay graph at high frequencies from 0ns to 1000ns shows the same properties as the boot frequency graph, however with much smaller minimal delays and stepping. Note the non-linear STM32F7 delay curve.&lt;/p&gt;

&lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;us_boot.svg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;For completeness we’ve also measured microsecond delay from 0us to 1000us at boot frequency. The results are very accurate with a minimum delay of 1us on all devices except on the STM32L0 and STM32L1. They boot at 2.097MHz, where we use the fractional multiplication and shift to approximate 2.125MHz with an error of ~2%. Unfortunately on these devices millisecond delay will also have a 2% error, since they use microsecond delay under the hood as discussed.&lt;/p&gt;

&lt;p&gt;For microsecond delay at high frequency the measurements show no deviation at all, so that the graph is just a boring 1:1 line and therefore omitted.&lt;/p&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Very accurate delays even at nanosecond resolution on AVR and Cortex-M devices are possible if the call overhead is compensated and the error over time is bound. However, the delay implementations are not as trivial as expected, but with some simple tricks can be made to work very well.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://xkcd.com/598&quot;&gt;&lt;img dimmable=&quot;&quot; src=&quot;xkcd.png&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The code presented here is slightly simplified, so please also check the real delay implementations inside modm:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/modm-io/modm/blob/develop/src/modm/platform/core/avr/delay_impl.hpp.in&quot;&gt;AVR &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modm::delay_us&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modm::delay_ns&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/modm-io/modm/blob/develop/src/modm/platform/core/cortex/delay.cpp.in&quot;&gt;Cortex-M &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modm::delay_us&lt;/code&gt; using DWT&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/modm-io/modm/blob/develop/src/modm/platform/core/cortex/delay_ns.cpp.in&quot;&gt;Cortex-M &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modm::delay_us&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modm::delay_ns&lt;/code&gt; using Cycle Counting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/modm-io/modm/blob/develop/examples/generic/delay/main.cpp&quot;&gt;example used to measure the delay in hardware can be found here&lt;/a&gt;.&lt;/p&gt;</content><author><name>Niklas Hauser</name><email>niklas@salkinium.com</email></author><summary type="html">Accurately spinning for short and long time durations is an essential part of an embedded application. In the modm embedded library we provide blocking delay functions in the resolution of milli-, micro- and even nanoseconds. Let me show you how we used the available hardware to implement a fast, efficient and flexible API that works with thousands of devices all with different clock configurations. The most prominent uses for blocking delays in modm are during initialization of internal peripherals and external drivers that may require a few micro- to milliseconds to stabilize their hardware, and when bit-banging protocols in software with kHz and MHz baudrates requiring micro- or even nanosecond delay. The delay functions must be as accurate as possible. In particular they must have the shortest possible overhead and a low error over at least 1s of delay. They must already work before main (during the global constructor calls) and remain accurate if the clock configuration and therefore the CPU frequency dynamically changes. They must also be reentrant so they can be called from inside an interrupt if needed. And lastly they should be compatible with the std::chrono time units, so that we can pass them literals for ease of use: modm::delay(1s); // non-literal version modm::delay(10ms); modm::delay_ms(10); modm::delay(100us); modm::delay_us(100); modm::delay(1000ns); modm::delay_ns(1000); Computing Cycles The simplest delay function converts the input time to CPU cycles and then spins in place counting them down. For the conversion we need to know the CPU frequency and have some mechanism for keeping track of elapsed CPU cycles. For microsecond and longer delays the conversion is simple: 1µs = 1MHz-1, so you can just take the CPU frequency in MHz and multiply it with the input to get the cycles. We store the frequency in a global uint16_t already scaled down to MHz and initialized with the boot frequency during startup. // microcontroller boots with a 8MHz clock uint16_t fcpu_MHz = 8; // simple conversion with multiplication uint32_t cycles = us * fcpu_MHz; This works well for frequencies that divide 1MHz cleanly, however, the STM32L0/L1 microcontrollers boot at 2.097MHz for example, which results in a 5% error right after boot. We therefore binary scale the MHz value to achieve a much lower error, which can be done very efficiently with bit shifting: // multiply MHz with power-of-two 2^5 = 32 constexpr uint8_t shift = 5; // 2.097MHz * 32 -&amp;gt; 67 = 2.09375MHz -&amp;gt; ~0.2% error constinit uint16_t fcpu_MHz = std::round(2.097f * (1ul &amp;lt;&amp;lt; shift)); // divide with simple bit shift uint32_t cycles = (us * fcpu_MHz) &amp;gt;&amp;gt; shift; To keep the 32-bit multiplication from overflowing and to maintain at least 1s = 1’000’000µs of delay, we must limit the scaling so that 232 - shift / max_fcpu ≥ 1s. A scalar of 32 (shift 5) is only good up to 134MHz, while the fastest STM32H7 running at 480MHz limits the scalar to only 8 (shift 3). For nanosecond delay we need a different algorithm, since the microcontrollers all run below 1GHz so one CPU cycle is several nanoseconds long. For example, the STM32F7 runnning at 216MHz will take ~4.6ns per cycle. To get the cycles from a nanosecond input we would need to divide: float ns_per_cycle = 4.6f; uint32_t cycles = ns / ns_per_cycle; This is obviously way too slow to compute, but we first need to understand how to accurately count cycles to find a better solution to this problem. Counting Cycles Wouldn’t it be nice if we could just delegate counting cycles to some hardware counter? Well, look no further than the Data Watchpoint and Trace (DWT) peripheral and its 32-bit CYCCNT free running at CPU frequency! // Enable Tracing Debug Unit CoreDebug-&amp;gt;DEMCR |= CoreDebug_DEMCR_TRCENA_Msk; // Enable CPU cycle counter DWT-&amp;gt;CTRL |= DWT_CTRL_CYCCNTENA_Msk; By reading DWT-&amp;gt;CYCCNT once at the beginning and then comparing this constantly in a loop until the number of cycles have passed, we can implement a very simple, yet very accurate delay function: void modm::delay_us(uint32_t us) { const uint32_t start = DWT-&amp;gt;CYCCNT; const uint32_t cycles = fcpu_MHz * us &amp;gt;&amp;gt; shift; while (true) { const uint32_t now = DWT-&amp;gt;CYCCNT; if (now - start &amp;gt;= cycles) break; } } Bonus win for this solution: time spent in interrupts during the delay is compensated for, since the hardware counter continues counting throughout. Counting Loops Unfortunately, the DWT peripheral is not accessible in all ARMv7-M devices (NRF52 only allows the debugger to access it) and it’s not even implemented on ARM Cortex-M0(+) aka. ARMv6-M devices, so we have to count cycles a different way. We could use the SysTick-&amp;gt;VAL, however it’s just a 24-bit counter, which limits us to ~16.8 million cycles: a ~1s delay at 16MHz or a maximum 35ms delay (!) at 480MHz. In addition, the SysTick is often used for preemptive scheduling (in FreeRTOS) or to create a global clock (for software timers), so we cannot use it as a replacement. Instead we will count cycles the old fashioned way: in a tight assembly loop with a known timing. We use two 16-bit Thumb-2 instructions: subtraction with condition flags update and branch back if positive. They are aligned so they fit into a single 32-bit instruction fetch and fill the pipeline entirely, giving us the maximum performance: 1 cycle for the subtraction and 2-cycles to branch back, so the loop takes 3 cycles total: void modm::delay_us(uint32_t us) modm_fastcode { const uint32_t cycles = fcpu_MHz * us &amp;gt;&amp;gt; shift; asm volatile ( &quot;.align 4&quot; // align for *one* 32-bit instruction fetch &quot;1: subs %0, %0, #3&quot; // subtract the loop cycles &quot;bpl 1b&quot; // loop while cycles are positive :: &quot;l&quot; (cycles)); } The instruction fetch timings for executing directly from Flash depends on the CPU speed, the currently configured wait states and the state of the instruction cache (if available and configured) and finally the branch speculation of the cache implementation. We therefore place the entire function into SRAM using the modm_fastcode attribute, which gives us predictable timings for instruction fetches across all Cortex-M cores, since we’re bypassing the Flash wait states and the (vendor supplied) cache entirely. Predictable, but not consistent: In my experiments I’ve discovered the loop to take 3 cycles on STM32{F3, G0, G4, L0, L4}, 4 cycles on STM32{L1, F0, F1, F4, F2} and just 1 cycle (!) on STM32F7. The timings depend on the (vendor defined) bus matrix implementation and the system configuration and are mainly about whether the Instruction Bus (I-Code) can access SRAM directly or whether the access is performed by the slower System Bus (S-Bus). The STM32F4 reference manual states in section 2.3.1 Embedded SRAM: The CPU can access the SRAM1, SRAM2, and SRAM3 through the System Bus or through the I-Code/D-Code buses when boot from SRAM is selected or when physical remap is selected. To get the max performance on SRAM execution, physical remap should be selected (boot or software selection). It seems that access through the I-Code takes 2-cycles, but the S-Bus takes 4-cycles, while the Cortex-M7 has a dual issue pipeline and native instruction cache with native branch prediction, so it’s just… really fast ? As confusing as it might be, at least the instruction fetch timing from SRAM is independent from the configured CPU frequency, which allows us to hardcode the loop cycles to subtract as an immediate value encoded in the instruction. The upper bound on the error is at most 3 cycles plus the error of the binary scaling, which together is good enough for our purpose. However, interrupts are not compensated, so the real delay may be significantly longer. If an accurate delay is absolutely necessary it can be wrapped into modm::atomic::Lock to disable interrupts during the delay. Counting Nanoseconds To delay for nanoseconds we need to do something a little different, since the naive approach involves division, which would be way too slow. We can, however, approximate this division with a loop of subtractions! So we input the nanoseconds into the subs bpl loop and subtract the nanoseconds each loop takes. We store this value in SRAM and update it on every clock change: constexpr uint8_t cycles_per_loop = 3; // 1-4 cycles, depends on device // round the nanoseconds to minimize error uint16_t ns_per_loop = std::round(1e9 * cycles_per_loop / fcpu); void modm::delay_ns(uint32_t ns) modm_fastcode { asm volatile ( &quot;.align 4&quot; // align for *one* 32-bit instruction fetch &quot;1: subs %0, %0, %1&quot; // subtract the nanoseconds per loop &quot;bpl 1b&quot; // loop while nanoseconds are positive :: &quot;l&quot; (ns), &quot;l&quot; (ns_per_loop)); } This works, however, there is a large overhead until execution arrives at the loop. The reason is that the compiler uses a bl (branch and link) instruction to jump to an address encoded as an immediate value. This is fast and efficient, however, it limits us to a relative address range of ±16MBs and our delay function in SRAM is waaaaay out there (SRAM starts @0x20000000 vs Flash @0x08000000). So the linker has to add a veneer, that does nothing else but jump further by loading the address into a register and loading it into the program counter therefore jumping: modm::delay_ns(ns); 8000214: f002 fbf4 bl 8002a00 &amp;lt;___ZN4modm8delay_nsEm_veneer&amp;gt; 08002a00 &amp;lt;___ZN4modm8delay_nsEm_veneer&amp;gt;: 8002a00: f85f f000 ldr.w pc, [pc] ; 8002a04 8002a04: 20000189 .word 0x20000189 20000188 &amp;lt;_ZN4modm8delay_nsEm&amp;gt;: void modm_fastcode modm::delay_ns(uint32_t us) Since Flash access is very slow (up to a dozen wait states for fast devices), vendors supply a cache implementation with a large, but limited buffer size (the STM32F4 cache has 64 cache lines of 128-bit = 1kB!). So the jump to a veneer outside of the 1kB range spends many cycles just waiting on the Flash and this time depends on the current clock configuration. Can we do better? Yes, with inline assembly! We move the actual implementation to modm::platform::delay_ns and then use an forced-inline forwarding function that uses the blx instruction to jump there directly instead of through a veneer: modm_always_inline void modm::delay_ns(uint32_t ns) { asm volatile( &quot;mov r0, %0&quot; // Pass the argument in r0 as per EABI &quot;blx %1&quot; // Jump there directly :: &quot;r&quot; (ns), &quot;l&quot; (modm::platform::delay_ns) : &quot;r0&quot;, &quot;r1&quot;, &quot;r2&quot;); } This reduces the overhead by eliminating the unnecessary jump and loading a literal from Flash that much closer to the execution site (here 0x35c - 0x2cc = 0x90 = 144 bytes) and therefore most likely already in the cache: modm::delay_ns(ns); 80002c6: 4c25 ldr r4, [pc, #148] ; 800035c 80002ca: 4628 mov r0, r5 80002cc: 47a0 blx r4 800035c: 200001a9 .word 0x200001a9 200001a8 &amp;lt;_ZN4modm8platform8delay_nsEm&amp;gt;: void modm_fastcode modm::platform::delay_ns(uint32_t us) However, we still need to actually compensate for this overhead, even if it’s just a few cycles, there should not be an offset in the delay function. To have maximum control we declare the function to be naked and implement the whole function in inline assembly: void __attribute__((naked, aligned(4))) modm_fastcode modm::platform::delay_ns(uint32_t ns) // passed in r0 { asm volatile ( &quot;ldr r2, =ns_per_loop&quot; // address of ns_per_loop &quot;ldrh r2, [r2, #0]&quot; // load the actual 16-bit ns_per_loop value &quot;lsls r1, r2, #2&quot; // approximate overhead in ns by shifting &quot;subs r0, r0, r1&quot; // subtract the overhead in nanoseconds &quot;1: subs r0, r0, r2&quot; // subtract the nanoseconds per loop &quot;bpl 1b&quot; // loop while nanoseconds are positive &quot;bx lr&quot; // return to execution ); } The overhead is measured experimentally and expressed in loops, which we can convert to nanoseconds by multiplying with the ns_per_loop variable. However the mul instruction requires passing the operands in registers, which would require an additional mov instruction to put the value into a register, so instead we use the lsl instruction to shift the value left with the same effect. This limits the “overhead loop count” to powers of two, which in practice is not an issue. In the above code we’re using 4 loops as overhead (so about 12-16 cycles at 3-4 cycles per loop), which is equivalent to shifting left by 2, hence the #2 immediate value in the lsl instruction. Counting Cycles on AVR AVRs cannot change their CPU frequency at runtime, instead it is fixed at compile time via the F_CPU macro, so we don’t have to worry about that. The avr-lib provide implementations of _delay_ms(double) and _delay_us(double) in the &amp;lt;util/delay.h&amp;gt; header: However, the implementations use floating point math to calculate the delay cycles for runtime arguments. But fear not for there is a very sternly worded warning for passing a dynamic value to this incredibly powerful foot gun: In order for these functions to work as intended, compiler optimizations must be enabled, and the delay time must be an expression that is a known constant at compile-time. If these requirements are not met, the resulting delay will be much longer (and basically unpredictable), and applications that otherwise do not use floating-point calculations will experience severe code bloat by the floating-point library routines linked into the application. Of course this is a completely unacceptable implementation, since avr-gcc provides __builtin_constant_p() to detect constant arguments and together with __builtin_avr_delay_cycles(uint32_t) can generates very accurate delays down to a single cycle for constant inputs at any clock rate. For a delay with a runtime argument we can loop over a 1ms or 1us constant delay and compensate for the loop overhead: modm_always_inline // &amp;lt;- must be force inlined to work void modm::delay_ms(uint32_t ms) { __builtin_constant_p(ms) ? ({ const uint32_t cycles = ceil((F_CPU * double(ms)) / 1e3); __builtin_avr_delay_cycles(cycles); }) : ({ while(ms--) __builtin_avr_delay_cycles((F_CPU / 1e3) - 10); }); } modm_always_inline void modm::delay_us(uint32_t us) { __builtin_constant_p(us) ? ({ const uint32_t cycles = ceil((F_CPU * double(us)) / 1e6); __builtin_avr_delay_cycles(cycles); }) : ({ // slightly lower overhead due to 16-bit delay vvv while(us--) __builtin_avr_delay_cycles((F_CPU / 1e6) - 6); }); } For dynamic nanosecond delay we approximate the division again with a shift, however, this time without multiplication, since that operation is very expensive on AVRs (dozens of cycles). The shift value is computed at compile time by rounding to the nearest power-of-two. The result is passed to the 4-cycle _delay_loop_2(uint16_t), which does the actual delay. This solution only yields accurate delays at 16MHz (shift 8), 8MHz (shift 9) and 4MHz (shift 10), and has a significant error plus additional overhead of a few cycles for shifts &amp;gt; 8. It’s also limited to 24-bits of input or about 16ms. It’s not an ideal solution, but all other ideas yielded significantly worse results incl. using the Cortex-M method of subtraction in a loop. modm_always_inline void modm::delay_ns(uint32_t ns) { __builtin_constant_p(ns) ? ({ const uint32_t cycles = ceil((F_CPU * double(ns)) / 1e9); __builtin_avr_delay_cycles(cycles); }) : ({ const uint16_t loops = ns &amp;gt;&amp;gt; 8; if (loops) _delay_loop_2(loops); }); } Using std::chrono We want these functions to be compatible with using namespace std::chrono_literals, so we overload the modm::delay() function with the appropriate durations. The conversion gets completely inlined and optimized away, so even for dynamic arguments there’s no code generated. A notable exception is the millisecond delay on Cortex-M, which gets converted to microseconds via a fast multiplication. template&amp;lt;class Rep&amp;gt; void modm::delay(std::chrono::duration&amp;lt;Rep, std::nano&amp;gt; ns) { const auto ns_{std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(ns)}; modm::delay_ns(ns_.count()); } template&amp;lt;class Rep&amp;gt; void modm::delay(std::chrono::duration&amp;lt;Rep, std::micro&amp;gt; us) { const auto us_{std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(us)}; modm::delay_us(us_.count()); } template&amp;lt;class Rep&amp;gt; void modm::delay(std::chrono::duration&amp;lt;Rep, std::milli&amp;gt; ms) { // converted to us on Cortex-M, but AVR just forwards to modm::delay_ms const auto us{std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(ms)}; modm::delay_us(us.count()); } Evaluation We can test the performance of our delay functions with DWT-&amp;gt;CYCCNT on ARMv7-M which has a fixed 4 cycle overhead: const uint32_t start = DWT-&amp;gt;CYCCNT; modm::delay(time); const uint32_t stop = DWT-&amp;gt;CYCCNT; const uint32_t cycles = (stop - start) - 4; // 4 cycles overhead ARMv6-M has no DWT module, so we use the SysTick-&amp;gt;VAL instead. The value counts down (!) and gets reloaded to SysTick-&amp;gt;LOAD on underrun. We need to make sure the underrun does not happen during measurement so we reload the SysTick-&amp;gt;VALbefore it. The 24-bit value limits our measurement duration to 262ms @ 64MHz (the fastest ARMv6-M tested). SysTick-&amp;gt;VAL = SysTick-&amp;gt;LOAD; const uint32_t start = SysTick-&amp;gt;VAL; modm::delay(time); const uint32_t stop = SysTick-&amp;gt;VAL; const uint32_t cycles = (start - stop) - 4; // swapped subtraction! And finally on AVRs we use the 16-bit Timer/Counter 1, which limits the measurement duration (but not the delay functions) to 4ms @16MHz. const uint16_t start = TCNT1; modm::delay(time); const uint16_t stop = TCNT1; const uint16_t cycles = (stop - start) - 4; In total 19 devices were tested by passing the modm::delay_ns() function durations from 0ns to 10000ns in 10ns steps. The Cortex-M devices were tested once at boot frequency and then again at their highest frequency. Device Core Type Cycles per Loop Minimum Cycles at Boot/High Frequency Minimum Delay at Boot Frequency Minimum Delay at High Frequency ATMEGA2560 avr8 4 16 1000ns @ 16 MHz   SAMD21 cm0+ 3 15   312ns @ 48 MHz STM32F072 cm0 4 18/19 1125ns @ 16 MHz 395ns @ 48 MHz STM32F091 cm0 4 18/19 1125ns @ 16 MHz 395ns @ 48 MHz STM32F103 cm3 4 16 2000ns @ 8 MHz 250ns @ 64 MHz STM32F303 cm4f 3 13 1625ns @ 8 MHz 203ns @ 64 MHz STM32F334 cm4f 3 13 1625ns @ 8 MHz 203ns @ 64 MHz STM32F401 cm4f 4 16 1000ns @ 16 MHz 190ns @ 84 MHz STM32F411 cm4f 4 16 1000ns @ 16 MHz 166ns @ 96 MHz STM32F429 cm4f 4 16 1000ns @ 16 MHz 95ns @ 168 MHz STM32F446 cm4f 4 16 1000ns @ 16 MHz 88ns @ 180 MHz STM32F469 cm4f 4 16 1000ns @ 16 MHz 88ns @ 180 MHz STM32F746 cm7fd 1 19 1187ns @ 16 MHz 87ns @ 216 MHz STM32G071 cm0+ 3 16/18 1000ns @ 16 MHz 281ns @ 64 MHz STM32G474 cm4f 3 17 1062ns @ 16 MHz 100ns @ 170 MHz STM32L031 cm0 4 16/17 7629ns @ 2.097 MHz 531ns @ 32 MHz STM32L152 cm3 4 16/17 7629ns @ 2.097 MHz 531ns @ 32 MHz STM32L432 cm4f 3 13/15 812ns @ 16 MHz 162ns @ 80 MHz STM32L476 cm4f 3 13/15 812ns @ 16 MHz 312ns @ 48 MHz The absolute minimum delay we can achieve is ~90ns and only on devices with a fast clock. You can clearly see the effects of the additional flash wait-states despite the cache on some devices after switching to high frequency. The graph of nanosecond delay at boot frequency shows several interesting points: The above mentioned minimum delays are very clear, particularly the ~7600ns minimum delay for the STM32L0 and STM32L1 which boot at only ~2MHz. A ~600ns offset on AVR: This is not surprising as our implementation does not compensate for the calling overhead at all. A percentual error on AVR: At 16MHz the correct divider would be 250 for a 4-cycle loop, however, we’re shifting 8 = divide by 256, which is a 2.5% error. For other frequencies this error will be much higher. An offset on STM32F7: The correct offset compensation would be ~26 loops, however our “shift multiplication” can only do 16 or 32 loops, hence this offset. The Cortex-M7 has built-in branch prediction, perhaps that explains the small irregularity at the beginning. The coarseness of the stepping varies, showing the effect of different clock speeds and cycles per loop. Most implemementations follow the ideal delay line very closely. The graph of nanosecond delay at high frequency shows that all implementations follow the ideal delay very precisely with no significant offset or error. The notable exception is the STM32F7 implementation, which has a significant ~7.5% error over time. Running at 216MHz a 1-cycle loop takes ~4.6ns which gets rounded up to 5ns which is then subtracted on every 1-cycle loop, thus yielding this error. This creates an interesting failure mode for this delay algorithm: At around 667MHz the error is highest at 50%, since a 1.5ns per loop (=1ns/667MHz) delay must be rounded to either 1ns or 2ns. Currently no STM32 runs at that high a speed, however, the STM32H7 can run at at 400MHz (≤480MHz), where the error would still be 25%. The delay implementation on other devices has the same problem, however, since the loop takes 3-4 cycles the error is much smaller. For example, the 3-cycle loop on the STM32G4 running at a comparable 170MHz takes ~17.6ns (=3ns/170MHz) ≈ 18ns per loop, which is an error of just ~2%. In contrast, the 4-cycle loop on the 64MHz STM32F1 takes 62.5ns (=4ns/64MHz) ≈ 63ns with an error of ~1%. It becomes clear that the subtraction spreads the rounding error over 3-4 cycles which essentially functions as a fractional integer division. So an easy fix for the 1-cycle loop error on the STM32F7 is to lengthen the loop with some NOPs to reduce the overall error at the cost of resolution. I will leave this for a future self to solve though. A detailed version of nanosecond delay graph at high frequencies from 0ns to 1000ns shows the same properties as the boot frequency graph, however with much smaller minimal delays and stepping. Note the non-linear STM32F7 delay curve. For completeness we’ve also measured microsecond delay from 0us to 1000us at boot frequency. The results are very accurate with a minimum delay of 1us on all devices except on the STM32L0 and STM32L1. They boot at 2.097MHz, where we use the fractional multiplication and shift to approximate 2.125MHz with an error of ~2%. Unfortunately on these devices millisecond delay will also have a 2% error, since they use microsecond delay under the hood as discussed. For microsecond delay at high frequency the measurements show no deviation at all, so that the graph is just a boring 1:1 line and therefore omitted. Conclusion Very accurate delays even at nanosecond resolution on AVR and Cortex-M devices are possible if the call overhead is compensated and the error over time is bound. However, the delay implementations are not as trivial as expected, but with some simple tricks can be made to work very well. The code presented here is slightly simplified, so please also check the real delay implementations inside modm: AVR modm::delay_us and modm::delay_ns. Cortex-M modm::delay_us using DWT Cortex-M modm::delay_us and modm::delay_ns using Cycle Counting The example used to measure the delay in hardware can be found here.</summary></entry><entry><title type="html">Introducing modm-devices: hardware descriptions for AVR and STM32 devices</title><link href="http://blog.salkinium.com/modm-devices/" rel="alternate" type="text/html" title="Introducing modm-devices: hardware descriptions for AVR and STM32 devices" /><published>2018-03-07T00:00:00+01:00</published><updated>2018-03-07T00:00:00+01:00</updated><id>http://blog.salkinium.com/modm-devices</id><content type="html" xml:base="http://blog.salkinium.com/modm-devices/">&lt;p&gt;For the last 2 years &lt;a href=&quot;https://github.com/dergraaf&quot;&gt;Fabian Greif&lt;/a&gt; and I have been
working on a secret project called &lt;a href=&quot;https://github.com/modm-io/&quot;&gt;modm: a toolkit for data-driven code generation&lt;/a&gt;.
In a nutshell, we feed detailed hardware description data for almost all AVR
and STM32 targets into a code generator to create a C++ Hardware Abstraction
Layer (HAL), startup &amp;amp; linkerscript code, documentation and support tools.&lt;/p&gt;

&lt;p&gt;This isn’t exactly a new idea, after all very similar ideas have been floating
around before, most notably in the Linux Kernel with its
&lt;a href=&quot;https://www.devicetree.org&quot;&gt;Device Tree (DT) effort&lt;/a&gt;. In fact, modm itself is based
entirely on &lt;a href=&quot;http://xpcc.io&quot;&gt;xpcc&lt;/a&gt; which matured the idea of data-driven HAL
generation in the first place.&lt;/p&gt;

&lt;p&gt;However, for modm we focused on what goes on behind the scenes: how to &lt;em&gt;acquire&lt;/em&gt;
detailed target description data and how to &lt;em&gt;use&lt;/em&gt; it with reasonable effort.
We now have a toolbox that transcends its use as our C++ HAL generator and
instead can be applied generically to any project in any language
(*awkwardly winks at the Rust community*). That’s pretty powerful stuff.&lt;/p&gt;

&lt;p&gt;So let me first ease you into this topic with some historic background and then
walk you through the data sources we use and the design decisions of our data
engine.
All with plenty of examples for you to follow along, just stay well clear of
those hairy yaks in the distance.&lt;/p&gt;

&lt;h2 id=&quot;the-origin-story&quot;&gt;The Origin Story&lt;/h2&gt;

&lt;p&gt;All the usual suspects in this case were members of the
&lt;a href=&quot;http://www.roboterclub.rwth-aachen.de/&quot;&gt;Roboterclub Aachen e. V.&lt;/a&gt;
(&lt;a href=&quot;https://twitter.com/RCA_eV&quot;&gt;@RCA_eV&lt;/a&gt;). Around 2006 the team surrounding
Fabian had built a communication library called RCCP for doing remote procedure
calls over CAN. Back then the only affordable microcontrollers were AVRs, but
neither were they powerful enough to perform all the computations needed for
autonomy nor did they have enough pins to interface with all the motors and
sensors we stuffed in our robots. So an embedded PC programmed in various
languages did all the heavy lifting and talked via CAN to the AVR actuators and sensors.&lt;/p&gt;

&lt;p&gt;(It has been passed on for many generations of robot builders, that the embedded
PC did a disk check once during its boot process, which rendered the robot
unresponsive for a few minutes. Unfortunately it did this during the a
&lt;a href=&quot;http://www.eurobot.org&quot;&gt;Eurobot&lt;/a&gt; finals game and we lost due to that.
Since then our robots don’t have a kernel in their critical path anymore.)&lt;/p&gt;

&lt;p&gt;RCCP was eventually refactored into the Cross Platform Component Communication
(XPCC) library and open-sourced on Sourceforge in 2009.
Around 2012 when Fabian was leaving us to go work on satellites at the German
space agency (DLR), I took over stewardship of the project and moved it over to
&lt;a href=&quot;https://github.com/roboterclubaachen/xpcc&quot;&gt;GitHub where it exists to this day&lt;/a&gt;.
It’s the foundation of all the RCAs robots.&lt;/p&gt;

&lt;h3 id=&quot;from-avr-to-stm32&quot;&gt;From AVR to STM32&lt;/h3&gt;

&lt;p&gt;By the time I joined in 2010, the team had been using C++ on AVRs for years.
Around 2012 we finally outgrew the AVRs used to control our autonomous robots
and switched over to Arm Cortex-M devices, specifically the STM32 series. So
began the cumbersome task of porting the HAL that worked so well on the AVRs to
the STM32F1 and F4 families, both of which have much more capable peripherals.&lt;/p&gt;

&lt;p&gt;We had inherited a C++ API that passed around static classes containing the
peripheral abstraction to template classes wrapping these classes. It’s the
clear anti-thesis of polymorphic interface design, almost a form of “compile
time duck-typing”:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GpioB0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// one class for every GPIO on the device&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SpiMaster0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// one class for every Spi peripheral&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SpiMaster&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ChipSelect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SensorDriver&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ChipSelect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Gpio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Low&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SpiMaster&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foobar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ChipSelect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Gpio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;High&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Hey look, a generic sensor driver&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;SensorDriver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SpiMaster0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GpioB0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heading&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;center&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.stroustrup.com/good_concepts.pdf&quot;&gt;C++ concepts&lt;/a&gt; sure would be useful
here for asserting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SpiMaster&lt;/code&gt; traits. *cough*&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;This technique resulted in a rather unusual HAL, but when used &lt;em&gt;in moderation&lt;/em&gt; it
yields ridiculously small binary sizes! And this was absolutely a requirement on
our AVRs which wanted to stuff full of control code for our autonomous robots.&lt;/p&gt;

&lt;p&gt;The size reduction didn’t so much come from using C++ features like templates,
but from being able to very accurately dissect special cases into their own functions.
This is particularly useful on AVRs where the IO memory map is very irregular and
differs quite a bit between devices. Writing one function to handle all variations
at runtime can be more expensive than writing a couple of specialized functions and
letting the linker throw away all the unused ones.&lt;/p&gt;

&lt;p&gt;But it does have one significant and obvious disadvantage: Our HAL had to &lt;em&gt;have&lt;/em&gt; a
class for every peripheral you want to use. And adding these classes manually didn’t
scale very well with us and it proved an even bigger problem for a device with the
peripheral amount and features of an STM32. And so the inevitable happened: we started
using preprocessor macros to “instantiate” these peripheral classes, or switched
between different implementation with extensive, often nested, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#if/#else/#endif&lt;/code&gt;
trees. It was such an ugly solution.&lt;/p&gt;

&lt;p&gt;We also had a mechanism for generating code manually calling a Jinja2 template
engine and committing the result, in fact, already
&lt;a href=&quot;https://github.com/roboterclubaachen/xpcc/commit/e239176#diff-41dfb98586123c4821a51af70cf93ae8&quot;&gt;since Nov. 2009&lt;/a&gt;.
It was first used to create the AVR’s UART classes and slowly expanded to other
platforms. But it didn’t really scale either because you still had to explicitly
provide all the substitution data to the engine, which usually only was the number,
or letter, identifying the peripheral.&lt;/p&gt;

&lt;p&gt;It wasn’t until 2013 that &lt;a href=&quot;https://github.com/ekiwi&quot;&gt;Kevin Läufer&lt;/a&gt; generalized
this idea by moving it into our &lt;a href=&quot;http://scons.org&quot;&gt;SCons-based&lt;/a&gt; build system and
collecting all template substitution data into one common file per target, which
we just called “The Device File” (naming things is hard, ok?). This made it much
easier to generate new peripheral drivers and it even did so on-the-fly during the
build process due to being included into SCons’ dependency graph, which eliminated
the need for manually committing these generated files and keeping them up-to-date.&lt;/p&gt;

&lt;h3 id=&quot;first-steps&quot;&gt;First Steps&lt;/h3&gt;

&lt;p&gt;The first draft of the &lt;a href=&quot;https://github.com/roboterclubaachen/xpcc/commit/3fcf8cb&quot;&gt;STM32F407’s device file&lt;/a&gt;
was assembled by hand and lacked a clear structure. In retrospect, we also had
trouble deciding which data goes in the device file and which
&lt;a href=&quot;https://github.com/roboterclubaachen/xpcc/blob/826c43797d31513d128760c190b19bdc61ca2f6b/src/xpcc/architecture/platform/core/cortex/stm32/stm32.macros#L52-L168&quot;&gt;stays embedded in the templates&lt;/a&gt;,
but, we didn’t sweat the details, since we had an entire library to refactor and
a robot to build.&lt;/p&gt;

&lt;p&gt;The major limitation of our system of course was getting the required data and
manually assembling it didn’t scale, and so we were stuck in the same bottleneck
as before, albeit with a slightly better build process.
And then, after researching how avr-gcc actually generate the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;avr/io.h&amp;gt;&lt;/code&gt; headers,
a solution presented itself:
&lt;a href=&quot;http://packs.download.atmel.com&quot;&gt;Atmel publishes a bunch of XML files called Part Description Files&lt;/a&gt;,
or PDFs (lolwut?), containing the memory map of their AVR devices, and we just had
to reformat this a little bit. Right? If only I knew what I was getting into…&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;module&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;USART&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;instance&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;USART0&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;caption=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;USART&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;register-group&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;USART0&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name-in-module=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;USART0&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;offset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0x00&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;address-space=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;data&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;caption=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;USART&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;signals&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;group=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TXD&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;function=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;default&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pad=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PD1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;group=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RXD&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;function=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;default&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pad=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PD0&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;group=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;XCK&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;function=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;default&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pad=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PD4&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/signals&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/instance&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/module&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;module&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TWI&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;instance&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TWI&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;caption=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Two Wire Serial Interface&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;register-group&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TWI&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name-in-module=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TWI&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;offset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0x00&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;address-space=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;data&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;caption=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Two Wire Serial Interface&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;signals&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;group=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SDA&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;function=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;default&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pad=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PC4&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;group=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SCL&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;function=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;default&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pad=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PC5&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/signals&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/instance&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/module&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;module&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PORT&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;instance&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PORTB&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;caption=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I/O Port&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;register-group&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PORTB&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name-in-module=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PORTB&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;offset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0x00&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;address-space=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;data&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;caption=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I/O Port&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;signals&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;group=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;P&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;function=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;default&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pad=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PB0&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;index=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;group=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;P&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;function=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;default&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pad=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PB1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;index=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;group=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;P&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;function=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;default&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pad=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PB2&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;index=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;group=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;P&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;function=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;default&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pad=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PB3&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;index=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;3&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;group=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;P&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;function=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;default&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pad=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PB4&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;index=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;4&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;group=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;P&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;function=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;default&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pad=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PB5&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;index=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;5&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;group=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;P&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;function=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;default&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pad=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PB6&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;index=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;6&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;group=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;P&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;function=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;default&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pad=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PB7&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;index=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;7&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/signals&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/instance&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;center&gt;
  &lt;p&gt;Excerpt of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ATmega328P.atdf&lt;/code&gt; part description file.&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;It really turned out to be a great, but very much incomplete, source of information
about AVRs. Even today, over 4 years later,
&lt;a href=&quot;https://github.com/modm-io/modm/blob/29f73690f43df87030a6dc2a8df56df1fa65ea6f/test/all/ignored.txt#L1-L114&quot;&gt;110 AVR memory maps are still missing GPIO signal definitions&lt;/a&gt;.
So I did what any student with too much time on their hands would do:
I began to &lt;em&gt;manually assemble&lt;/em&gt; the missing information by downloading  &lt;em&gt;all&lt;/em&gt;
existing AVR device datasheets, reading through &lt;em&gt;all&lt;/em&gt; of them and collecting
the pinouts in a spreadsheet. I then &lt;em&gt;manually reformatted&lt;/em&gt; this data into a
&lt;a href=&quot;https://github.com/modm-io/modm-devices/blob/64ebb6cdc99e79e3cf405f10d4d00d21f095cf1b/tools/generator/dfg/avr/avr_io.py#L222-L1868&quot;&gt;Python data structure, where it still exists today&lt;/a&gt;.
Don’t do this! I did get the job done, but I wasted two weeks of my life with this
crap and even though I was being really diligent, I still made a lot of mistakes.&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img dimmable=&quot;&quot; src=&quot;atmega_io.png&quot; /&gt;&lt;/p&gt;

  &lt;p&gt;Ah, the insanities of youth 🙄&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;I also wrote a memory map comparison tool, which was really useful for understanding
the batshit-insane AVR IO maps. Since the AVR can only address a certain amount of
IO memory directly, the hardware engineers have to “compress” (more like “forcefully
stuff”) the IO map and this quickly becomes very ugly. For example, the ATtiny*61
series features differential ADC inputs with selectable gains, configurable in 64
combinations, but register &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADMUX&lt;/code&gt; only has space for 5 bits (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MUX0&lt;/code&gt; - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MUX4&lt;/code&gt;).
So Atmel decided to cram &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MUX5&lt;/code&gt; into register &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADCSRB&lt;/code&gt;:&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img src=&quot;attiny_adc_mux.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

  &lt;p&gt;Wait, did the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADLAR&lt;/code&gt; bit just move around? Nah, must be an illusion. 😒&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;This memory map comparison tool was vital in understanding how all the AVRs memory
maps differ and coming up with strategies on how to map this functionality into our HAL.
&lt;a href=&quot;https://www.youtube.com/watch?v=KMU0tzLwhbE&quot;&gt;It’s all about tools, tools, tools, tools&lt;/a&gt;!&lt;/p&gt;

&lt;h2 id=&quot;peeking-into-stm32cubemx&quot;&gt;Peeking into STM32CubeMX&lt;/h2&gt;

&lt;p&gt;ST maintains the &lt;a href=&quot;http://www.st.com/en/development-tools/stm32cubemx.html&quot;&gt;CubeMX initialization code generator&lt;/a&gt;,
which contains “a pinout-conflict solver, a clock-tree setting helper, a power-consumption
calculator, and an utility performing MCU peripheral configuration”. Hm, doesn’t that
sound interesting? How did they implement these features, we wondered.&lt;/p&gt;

&lt;p&gt;Back in 2013 CubeMX was still called MicroXplorer and wasn’t nearly as nice to use
as today. It also launched as a Windows-only application, even though it was clearly
written in Java (those “beautiful” GUI elements give it away). Nevertheless, CubeMX
indeed is a very useful application, giving you a number of visual configuration editors:&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img dimmable=&quot;&quot; src=&quot;stm32f103_cube_gpio.png&quot; /&gt;&lt;/p&gt;

  &lt;p&gt;Configuring the USART1_TX signal on pin PB6 on the popular STM32F103RBT.&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;During installation, CubeMX kindly unpacks a &lt;em&gt;huge&lt;/em&gt; plaintext (!) database to disk
at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STM32CubeMX.app/Contents/Resources/db&lt;/code&gt; (on OSX) and even updates it for
you on every app launch. This database consists out of a lot of XML files, one
for every STM32 device in ST’s portfolio, plus detailed descriptions of peripheral
configurations. It really is an insane amount of data.&lt;/p&gt;

&lt;p&gt;So I invite you to join me on a stroll through the colorful fields of XML that
power the core of the CubeMX’s configurators.
I’ll be using the STM32F103RBT, which is a very popular controller that can be
found all ST Links and on the Plue Pill board available on ebay for a few bucks.&lt;/p&gt;

&lt;h3 id=&quot;gpio-alternate-functions&quot;&gt;GPIO Alternate Functions&lt;/h3&gt;

&lt;p&gt;We start by searching for the unique device identifier &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STM32F103RBTx&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mcu/families.xml&lt;/code&gt;
(which is &amp;gt;30.000 lines long, btw). The minimal information about the device here
is used by the parametric search engine in CubeMX.&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;Mcu&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;STM32F103R(8-B)Tx&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;PackageName=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;LQFP64&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;RefName=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;STM32F103RBTx&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Core&amp;gt;&lt;/span&gt;ARM Cortex-M3&lt;span class=&quot;nt&quot;&gt;&amp;lt;/Core&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Frequency&amp;gt;&lt;/span&gt;72&lt;span class=&quot;nt&quot;&gt;&amp;lt;/Frequency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Ram&amp;gt;&lt;/span&gt;20&lt;span class=&quot;nt&quot;&gt;&amp;lt;/Ram&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Flash&amp;gt;&lt;/span&gt;128&lt;span class=&quot;nt&quot;&gt;&amp;lt;/Flash&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Voltage&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Max=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;3.6&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Min=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2.0&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Current&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Lowest=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.7&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Run=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;373.0&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Temperature&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Max=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;105.0&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Min=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;-40.0&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Peripheral&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ADC 12-bit&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;MaxOccurs=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;16&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Peripheral&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;CAN&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;MaxOccurs=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Peripheral&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I2C&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;MaxOccurs=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Peripheral&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RTC&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;MaxOccurs=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Peripheral&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SPI&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;MaxOccurs=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Peripheral&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Timer 16-bit&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;MaxOccurs=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;4&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Peripheral&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;USART&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;MaxOccurs=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;3&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Peripheral&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;USB Device&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;MaxOccurs=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/Mcu&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Following the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mcu/@Name&lt;/code&gt; leads us to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STM32F103R(8-B)Tx.xml&lt;/code&gt; containing what
peripherals and how many (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mcu/IP/@InstanceName&lt;/code&gt;) as well as what pins exists on this
package and where and what alternate functions they can be connected to.&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;Core&amp;gt;&lt;/span&gt;ARM Cortex-M3&lt;span class=&quot;nt&quot;&gt;&amp;lt;/Core&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;Ram&amp;gt;&lt;/span&gt;20&lt;span class=&quot;nt&quot;&gt;&amp;lt;/Ram&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;Flash&amp;gt;&lt;/span&gt;64&lt;span class=&quot;nt&quot;&gt;&amp;lt;/Flash&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;Flash&amp;gt;&lt;/span&gt;128&lt;span class=&quot;nt&quot;&gt;&amp;lt;/Flash&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- ... --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;IP&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;InstanceName=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;USART3&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;USART&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Version=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sci2_v1_1_Cube&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;IP&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;InstanceName=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RCC&quot;&lt;/span&gt;    &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RCC&quot;&lt;/span&gt;   &lt;span class=&quot;na&quot;&gt;Version=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;STM32F102_rcc_v1_0&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;IP&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;InstanceName=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;NVIC&quot;&lt;/span&gt;   &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;NVIC&quot;&lt;/span&gt;  &lt;span class=&quot;na&quot;&gt;Version=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;STM32F103G&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;IP&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;InstanceName=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;GPIO&quot;&lt;/span&gt;   &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;GPIO&quot;&lt;/span&gt;  &lt;span class=&quot;na&quot;&gt;Version=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;STM32F103x8_gpio_v1_0&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- ... --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;Pin&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PB5&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Position=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;57&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I/O&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I2C1_SMBA&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SPI1_MOSI&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TIM3_CH2&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/Pin&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;Pin&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PB6&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Position=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;58&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I/O&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I2C1_SCL&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TIM4_CH1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;USART1_TX&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/Pin&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;Pin&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PB7&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Position=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;59&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I/O&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I2C1_SDA&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TIM4_CH2&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;USART1_RX&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/Pin&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Each peripheral has a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IP/@Version&lt;/code&gt;, which leads to a configuration file containing
&lt;em&gt;even more&lt;/em&gt; data. Don’t cha just love the smell of freshly unpacked data in the morning?
For this device’s GPIO peripheral we’ll look for any pins with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;USART1_TX&lt;/code&gt;
signal in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mcu/IP/GPIO-STM32F103x8_gpio_v1_0_Modes.xml&lt;/code&gt; file:&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;GPIO_Pin&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;PortName=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PB&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PB6&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;PinSignal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;USART1_TX&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;RemapBlock&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;USART1_REMAP1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
           &lt;span class=&quot;nt&quot;&gt;&amp;lt;SpecificParameter&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;GPIO_AF&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
               &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&amp;gt;&lt;/span&gt;__HAL_AFIO_REMAP_USART1_ENABLE&lt;span class=&quot;nt&quot;&gt;&amp;lt;/PossibleValue&amp;gt;&lt;/span&gt;
           &lt;span class=&quot;nt&quot;&gt;&amp;lt;/SpecificParameter&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/RemapBlock&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/PinSignal&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/GPIO_Pin&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- ... --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;GPIO_Pin&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;PortName=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PA&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PA9&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;PinSignal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;USART1_TX&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;RemapBlock&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;USART1_REMAP0&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;DefaultRemap=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/PinSignal&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/GPIO_Pin&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;USART1_TX&lt;/code&gt; maps to pin PB6 with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;USART1_REMAP1&lt;/code&gt; or pin PA9 with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;USART1_REMAP0&lt;/code&gt;.
The STM32F1 series remap signals either in (overlapping) groups or not at all.
This is controlled by the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AFIO_MAPRx&lt;/code&gt; registers, where we can find PB6/PA9 again:&lt;/p&gt;

&lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;stm32f103_usart1_remap.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__HAL_AFIO_REMAP_USART1_ENABLE&lt;/code&gt; in the XML is actually just a C function name,
and is placed by CubeMX in the generated init code.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;HAL_UART_MspInit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UART_HandleTypeDef&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;huart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;GPIO_InitTypeDef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO_InitStruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;huart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;USART1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cm&quot;&gt;/* Peripheral clock enable */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;__HAL_RCC_USART1_CLK_ENABLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;cm&quot;&gt;/**USART1 GPIO Configuration
        PB6     ------&amp;gt; USART1_TX
        PB7     ------&amp;gt; USART1_RX
        */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;GPIO_InitStruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO_PIN_6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;GPIO_InitStruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO_MODE_AF_PP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;GPIO_InitStruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Speed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO_SPEED_FREQ_HIGH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;HAL_GPIO_Init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIOB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_InitStruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;GPIO_InitStruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO_PIN_7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;GPIO_InitStruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO_MODE_INPUT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;GPIO_InitStruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pull&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO_NOPULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;HAL_GPIO_Init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIOB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_InitStruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;__HAL_AFIO_REMAP_USART1_ENABLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The IP files do contain a very large amount of information, however, it’s mostly
directed at the code generation capabilities of the CubeMX project exporter, and
as such, not very useful as stand-alone information. For example, the above
GPIO signal information relies on the existence of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__HAL_AFIO_REMAP_USART1_ENABLE()&lt;/code&gt;
function that performs the remapping. The mapping between the bits in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AFIO_MAPRx&lt;/code&gt;
registers and the remap groups is therefore encoded in two separate places:
these xml files, and the family’s CubeHAL.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mcu/IP/NVIC-STM32F103G_Modes.xml&lt;/code&gt; configuration file, used to configure the NVIC in
the CubeMX, exemplifies this quite well: here we see the first 10 interrupt vectors
paired with additional metadata (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PossibleValue/@Value&lt;/code&gt; seems to contain some &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:&lt;/code&gt;
separated conditionals for visibility inside the GUI tool).&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;RefParameter&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Interrupt Table&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;IRQn&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;list&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Non maskable interrupt&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;NonMaskableInt_IRQn:N,IF_HAL::HAL_RCC_NMI_IRQHandler:CSSEnabled&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hard fault interrupt&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HardFault_IRQn:N,W1:::&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Memory management fault&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;MemoryManagement_IRQn:Y,W1:::&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Prefetch fault, memory access fault&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;BusFault_IRQn:Y,W1:::&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Undefined instruction or illegal state&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;UsageFault_IRQn:Y,W1:::&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;System service call via SWI instruction&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SVCall_IRQn:Y,RTOS::NONE:&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Debug monitor&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;DebugMonitor_IRQn:Y::NONE:&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Pendable request for system service&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PendSV_IRQn:Y,RTOS::NONE:&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;System tick timer&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SysTick_IRQn:Y:::&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Window watchdog interrupt&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;WWDG_IRQn:Y:WWDG:HAL_WWDG_IRQHandler:&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;However, their actual position in the interrupt vector table is missing, and so
this data cannot be used to extract a valid interrupt table. Instead an alias is
used here to pair the interrupt with its actual table position, as defined in the
&lt;a href=&quot;https://github.com/modm-io/cmsis-header-stm32/blob/master/stm32f1xx/Include/stm32f103xb.h#L86-L144&quot;&gt;STM32F103xB CMSIS header file&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For example, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WWDG&lt;/code&gt; interrupt vector is located at position 16 (=16+0), while
the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SVCall&lt;/code&gt; vector is located at position 11 (=16-5), or 5 positions behind
the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UsageFault&lt;/code&gt; vector:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;cm&quot;&gt;/*!&amp;lt; Interrupt Number Definition */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;NonMaskableInt_IRQn&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*!&amp;lt; 2 Non Maskable Interrupt                */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;HardFault_IRQn&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*!&amp;lt; 3 Cortex-M3 Hard Fault Interrupt        */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;MemoryManagement_IRQn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*!&amp;lt; 4 Cortex-M3 Memory Management Interrupt */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;BusFault_IRQn&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*!&amp;lt; 5 Cortex-M3 Bus Fault Interrupt         */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;UsageFault_IRQn&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*!&amp;lt; 6 Cortex-M3 Usage Fault Interrupt       */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;SVCall_IRQn&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/*!&amp;lt; 11 Cortex-M3 SV Call Interrupt          */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;DebugMonitor_IRQn&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/*!&amp;lt; 12 Cortex-M3 Debug Monitor Interrupt    */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;PendSV_IRQn&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/*!&amp;lt; 14 Cortex-M3 Pend SV Interrupt          */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;SysTick_IRQn&lt;/span&gt;          &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/*!&amp;lt; 15 Cortex-M3 System Tick Interrupt      */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;WWDG_IRQn&lt;/span&gt;             &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;   &lt;span class=&quot;cm&quot;&gt;/*!&amp;lt; Window WatchDog Interrupt               */&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IRQn_Type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So keep in mind that this data is not meant to be a sensible hardware
description format and it just often lacks basic information that would make it
much more useful. Then again, the only consumer of this information is supposed
to be CubeMX for its fairly narrow goal of code generation.&lt;/p&gt;

&lt;h3 id=&quot;clock-tree&quot;&gt;Clock Tree&lt;/h3&gt;

&lt;p&gt;Let’s look at another very interesting data source in CubeMX: the clock
configuration wizard:&lt;/p&gt;

&lt;p&gt;&lt;img dimmable=&quot;&quot; src=&quot;stm32f103_cube_clock.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;What’s so interesting about this configurator is that it &lt;em&gt;knows&lt;/em&gt; what the maximum
frequencies of the respective clock segments are, and more importantly, how to
set the prescalers to resolve these issues and this for every device.
You surely know where this is going by know. Yup, it’s backed by data, and here
is what it looks like rendered with graphviz.&lt;/p&gt;

&lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;stm32f100_clock.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Here is a beautified excerpt from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plugins/clock/STM32F102.xml&lt;/code&gt;, which only
shows the connections highlighted in red. Note how the text in the nodes maps to
the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Element/@type&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Element/@id&lt;/code&gt; attributes, and how the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Element/Output&lt;/code&gt;
and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Element/Input&lt;/code&gt; children declare a (unique) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@signalId&lt;/code&gt; and which node they
are connecting to:&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;Tree&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ClockTree&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- HSE --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;Element&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HSEOSC&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;variedSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;refParameter=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HSE_VALUE&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Output&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HSE&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;to=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HSEDivPLL&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/Element&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- PLL div input from HSE --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;Element&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HSEDivPLL&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;devisor&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;refParameter=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HSEDivPLL&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HSE&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;from=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HSEOSC&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Output&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HSE_PLL&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;to=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PLLSource&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/Element&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;Tree&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PLL&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- PLLsource MUX source pour PLL mul --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Element&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PLLSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;multiplexor&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;refParameter=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PLLSourceVirtual&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;Input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HSE_PLL&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;from=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HSEDivPLL&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;refValue=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RCC_PLLSOURCE_HSE&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;Output&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;VCOInput&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;to=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;VCO2output&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/Element&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Element&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;VCO2output&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;output&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;refParameter=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;VCOOutput2Freq_Value&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;Input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;VCOInput&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;from=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PLLSource&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;Output&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;VCO2Input&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;to=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PLLMUL&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/Element&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Element&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PLLMUL&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;multiplicator&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;refParameter=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PLLMUL&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;Input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;VCO2Input&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;from=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;VCO2output&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;Output&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PLLCLK&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;to=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SysClkSource&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/Element&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/Tree&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!--Sysclock mux --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;Element&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SysClkSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;multiplexor&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;refParameter=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SYSCLKSource&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PLLCLK&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;from=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PLLMUL&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;refValue=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RCC_SYSCLKSOURCE_PLLCLK&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Output&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SYSCLK&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;to=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SysCLKOutput&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/Element&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;Element&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SysCLKOutput&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;output&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;refParameter=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SYSCLKFreq_VALUE&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SYSCLK&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;from=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SysClkSource&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Output&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SYSCLKOUT&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;to=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;AHBPrescaler&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/Element&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- AHB input**SYSclock** --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;Element&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;AHBPrescaler&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;devisor&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;refParameter=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;AHBCLKDivider&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SYSCLKOUT&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;from=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SysCLKOutput&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Output&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HCLK&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;to=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;AHBOutput&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/Element&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- AHB input**SYSclock** output**FHCLK,HCLK,Diviseurcortex,APB1,APB2 --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;Element&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;AHBOutput&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;activeOutput&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;refParameter=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HCLKFreq_Value&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HCLK&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;from=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;AHBPrescaler&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Output&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;to=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;FCLKCortexOutput&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;AHBCLK&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Output&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;to=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;FSMClkOutput&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;AHBCLK&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Output&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;to=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SDIOClkOutput&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;AHBCLK&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Output&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;to=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HCLKDiv2&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;AHBCLK&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Output&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;to=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HCLKOutput&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;AHBCLK&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Output&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;to=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TimSysPresc&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;AHBCLK&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Output&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;to=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;APB1Prescaler&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;AHBCLK&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Output&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;to=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;APB2Prescaler&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signalId=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;AHBCLK&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/Element&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/Tree&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We still don’t know how CubeMX is able to do it actual calculations,
because the clock graph above doesn’t contain any numbers at all.
Some digging around later we can trace the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Element/@refParameter&lt;/code&gt; attribute to
the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IP/RCC-STM32F102_rcc_v1_0_Modes.xml&lt;/code&gt; which contains *drumroll* numbers,
and lots of ‘em:&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Les frequences des sources --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;RefParameter&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HSE_VALUE&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Min=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;4000000&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Max=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;16000000&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Display=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;value/1000000&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Unit=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;MHz&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- frequence PLL --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;RefParameter&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;VCOOutput2Freq_Value&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Min=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1000000&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Max=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;25000000&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Display=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;value/1000000&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Unit=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;MHz&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- les diviseurs --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;RefParameter&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HSEDivPLL&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;DefaultValue=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RCC_HSE_PREDIV_DIV1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RCC_HSE_PREDIV_DIV1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RCC_HSE_PREDIV_DIV2&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/RefParameter&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Les multiplicateurs --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;RefParameter&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PLLMUL&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;DefaultValue=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RCC_PLL_MUL2&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RCC_PLL_MUL2&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- ... --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;16&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RCC_PLL_MUL16&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/RefParameter&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Les frequences des signaux --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- SYS clock freq de l&apos;output --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;RefParameter&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SYSCLKFreq_VALUE&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Max=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;72000000&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Display=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;value/1000000&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Unit=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;MHz&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- diviseur AHB 1..512 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;RefParameter&lt;/span&gt;  &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;AHBCLKDivider&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;DefaultValue=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RCC_SYSCLK_DIV1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RCC_SYSCLK_DIV1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RCC_SYSCLK_DIV2&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;4&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RCC_SYSCLK_DIV4&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;8&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RCC_SYSCLK_DIV8&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;16&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RCC_SYSCLK_DIV16&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;64&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RCC_SYSCLK_DIV64&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;128&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RCC_SYSCLK_DIV128&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;256&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RCC_SYSCLK_DIV256&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;PossibleValue&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Comment=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;512&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RCC_SYSCLK_DIV512&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/RefParameter&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- AHB out freq --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;RefParameter&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HCLKFreq_Value&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Max=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;72000000&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Display=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;value/1000000&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Unit=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;MHz&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Did you know that ST is a French-Italian company? Cos those XML comments clearly
aren’t in English. 🤔 Well, that and they seem keen on calling it a “devisor”
when they really mean “divider”. What is this, I don’t even.&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img src=&quot;not_anything_wrong.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

  &lt;p&gt;French comments in XML&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;Anyways, here you can see the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RefParameter/@min&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RefParameter/@max&lt;/code&gt;
frequency values as well as prescaler values encoded as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PossibleValue/@Comment&lt;/code&gt;,
which are all used by CubeMX to check and fix your clock tree.
That’s pretty amazing actually.&lt;/p&gt;

&lt;p&gt;Ok, so I’m not going into the data of their board support packages, because
I don’t think any health insurance covers this much exposure to XML, especially
not XML containing French comments. But feel free to take a look at your own risk,
it’s just waiting there in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plugins/boardmanager/boards&lt;/code&gt; for your prying eyes.&lt;/p&gt;

&lt;p&gt;Let’s move on to how we can extract this data programmatically and use it to
bring order to chaos, one example at a time. A bit like the Avengers franchise
*drags out blog post to infinity*&lt;/p&gt;

&lt;h2 id=&quot;generating-device-files&quot;&gt;Generating Device Files&lt;/h2&gt;

&lt;p&gt;The goal of finding machine-readable device description data obviously was to
write a program to import, clean-up and convert it into a format that’s more
agreeable to our use-case of generating a HAL.
Ironically the Device File Generator (DFG) started out in mid 2013 with the
innocently named commit
&lt;a href=&quot;https://github.com/roboterclubaachen/xpcc/commit/1532289&quot;&gt;“Cheap and simple parsing of the XML files”&lt;/a&gt;.
It’s not cheap and simple anymore.&lt;/p&gt;

&lt;p&gt;The DFG started out as a glorified &lt;a href=&quot;https://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt;
wrapper in xpcc, but then quickly devolved into some messy monster, that pulled
in data from all over the place and arranged it without much concept.
Back then we were busy building porting the HAL, writing sensor drivers and
building robots, so we didn’t approach this problem structurally, and rather
fixed bugs when they occurred.&lt;/p&gt;

&lt;p&gt;I won’t talk about xpcc’s DFG architecture issues in detail, instead I’ll be
showing you the problems it caused us. This way, the lessons learned are more
transferable to other format (*cough* Device Tree *cough*), since the
device data is immutable whereas the DFG’s architecture is not.&lt;/p&gt;

&lt;p&gt;Note that I rewrote the DFG from scratch for modm, so &lt;a href=&quot;https://github.com/modm-io/modm-devices&quot;&gt;you can have a look at the
source code&lt;/a&gt; while reading this.
I’m continuing to use the STM32F103RBT6 for illustration, but this all works
very similarly for all STM32 and AVR devices.&lt;/p&gt;

&lt;h3 id=&quot;device-identifiers&quot;&gt;Device Identifiers&lt;/h3&gt;

&lt;p&gt;We needed a way to identify what device to build our HAL for, and of course we
use the manufacturers identifier, since it’s (hopefully) unique.
We also needed to split up the identifier string, so that the HAL can query
its traits to select what code templates to use.
For example, in xpcc we split &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stm32f103rbt6&lt;/code&gt; into:&lt;/p&gt;

&lt;center&gt;
  &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   stm32     f1     103     r       b    ​
{platform}{family}{name}{pin-id}{size-id}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;Note how we forgot the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t6&lt;/code&gt; suffix. If we compare this with the documentation
on the ST ordering information scheme, you’ll see why this was a huge mistake:&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;stm32f1_ordering_info_scheme.png&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;Yup, that’s right, we forgot to encode the package type, causing the DFG to select
the first device matching &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STM32F103RB&lt;/code&gt;! And that would be the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STM32F103RBHx&lt;/code&gt;
device, since it occurs first in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;families.xml&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;Mcu&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;STM32F103R(8-B)Hx&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;PackageName=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TFBGA64&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;RefName=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;STM32F103RBHx&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- ... --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;Mcu&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;STM32F103R(8-B)Tx&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;PackageName=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;LQFP64&quot;&lt;/span&gt;  &lt;span class=&quot;na&quot;&gt;RefName=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;STM32F103RBTx&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So we actually used the definitions for the TFBGA64 packaged device instead of
the LQFP64 packaged device. 🤦‍ Incredibly this didn’t cause immediate problems,
since we first focussed on the STM32F3 and F4 families, whose functionality
is almost identical between packages.&lt;/p&gt;

&lt;p&gt;However, we did notice some changes when a new version of CubeMX was released
which added or reordered devices in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;families.xml&lt;/code&gt;.
And then all hell broke loose when I added support for parsing the STM32F1 device
family, which couples peripheral features to memory size &lt;em&gt;and(!)&lt;/em&gt; pin count:&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;stm32f1_feature_package.png&quot; width=&quot;80%&quot; /&gt;&lt;br /&gt;
“32 KB Flash&lt;sup&gt;(1)&lt;/sup&gt;” aka. this table isn’t complicated enough already&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;If you’re a hardware engineer at $vendor, &lt;em&gt;PLEASE DON’T DO THIS!&lt;/em&gt; This is pure
punishment for anyone writing software for these chips. &lt;strong&gt;PLEASE DO NOT DO THIS!&lt;/strong&gt;
You should not have to query for &lt;em&gt;combinations&lt;/em&gt; of identifier traits to get your
hardware feature set. Expand your device lineup into new (orthogonal) identifier
space instead.&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img src=&quot;not_like_this.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;To be fair, the STM32F1 family was the first ST product to feature a Cortex-M
processor and they didn’t use this approach for any of their other STM32 families.
I forgive you, ST.&lt;/p&gt;

&lt;p&gt;So for modm I looked very carefully at how to split the identifier into traits.
I made the trait composition and naming transparent to the DFG, it only operates
on a dictionary of items, sharing the same identifier mechanism with the AVRs.
Since we currently don’t have any information that depends on the temperature
range, I left it out for now. Similarly, the device revision is not considered
either.&lt;/p&gt;

&lt;center&gt;
  &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   stm32     f1     03    r     b      t    ​
{platform}{family}{name}{pin}{size}{package}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;Note how both the xpcc and modm identifier encodings differ from the official ST
ordering scheme. Since we are sharing some code across vendors (like the
Cortex-M startup code), we need to have a common naming scheme, at least for
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{platform}&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{family}&lt;/code&gt; or the equivalent for other vendors.&lt;/p&gt;

&lt;p&gt;Also note that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{name}&lt;/code&gt; now does not contain part the trailing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; of the family.
This is to prevent the problem in xpcc where the code template authors only
checked for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{name}&lt;/code&gt; instead of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{family}&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{name}&lt;/code&gt;, for example,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id[&quot;name&quot;] == &quot;103&quot;&lt;/code&gt; vs. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id[&quot;family&quot;] == &quot;f1&quot; and id[&quot;name&quot;] == &quot;03&quot;&lt;/code&gt;.
This lead to issues when we ported some peripheral drivers to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;L1&lt;/code&gt; family
(similar to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F0/L0&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F4/L4&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F7/H7&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&quot;encoding-commonality&quot;&gt;Encoding Commonality&lt;/h3&gt;

&lt;p&gt;You’ve undoubtedly already noticed that the AVR and CubeMX data is quite verbose
and noisy. We didn’t want to use this data directly, hence the DFG.
However, we wanted to go a step further and cut down on duplicated data, so that
we have an easier time verifying the output of the DFG by not having to look
through &lt;em&gt;thousands&lt;/em&gt; of files, but rather &lt;em&gt;dozens&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;At the time of this writing, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;families.xml&lt;/code&gt; contains 1171 STM32 devices, but
&lt;a href=&quot;https://github.com/modm-io/modm-devices/tree/5d5285ae1b6e889676b6d04a653d26977bf127e8/devices/stm32&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modm-devices/devices/stm32&lt;/code&gt;&lt;/a&gt;
only contains 62 device files, that’s ~19x less files than devices.&lt;/p&gt;

&lt;p&gt;We observed that ST clusters their devices on their website, in their technical
documentation and in their software offerings. The coarsest regular cluster
pattern is the family, which denotes the type of Cortex-M code used among other
features. The subfamilies are then more or less arbitrarily clustered around
whatever combination of functionality ST wanted to bring to market, but the
cluster patterns of pin count, memory size and package are &lt;em&gt;very&lt;/em&gt; regular and
often explicitly called out. We wanted to reflect this in our data structure too.&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img dimmable=&quot;&quot; src=&quot;stm32f4x9_clusters.jpg&quot; /&gt;&lt;br /&gt;
This &lt;a href=&quot;http://www.st.com/en/microcontrollers/stm32f469-479.html&quot;&gt;STM32F4x9 feature matrix&lt;/a&gt; is extremely regular.&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;The Device Tree format deals with data duplication by allowing data specialization
through an inheritance tree and tree inclusion nodes.
However, you still have to create one leaf node for every device, so in the best
case you’d have one DT per device, or if you moved common data up the inheritance
tree, you’d have more files than devices.&lt;/p&gt;

&lt;p&gt;We decided instead to &lt;em&gt;merge&lt;/em&gt; our data trees for devices within similar enough
clusters and then filter out the data for &lt;em&gt;one&lt;/em&gt; device on access.
We use logical OR (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt;) to combine identifier traits to declare what devices
are merged. You’ll recognize the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;naming-schema&amp;gt;&lt;/code&gt; from the previous chapter:&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;device&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;platform=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stm32&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;family=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;f1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;03&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pin=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;c|r|t|v&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;size=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;8|b&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;package=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;h|i|t|u&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;naming-schema&amp;gt;&lt;/span&gt;{platform}{family}{name}{pin}{size}{package}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/naming-schema&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;valid-device&amp;gt;&lt;/span&gt;stm32f103c8t&lt;span class=&quot;nt&quot;&gt;&amp;lt;/valid-device&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- ... --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;valid-device&amp;gt;&lt;/span&gt;stm32f103rbt&lt;span class=&quot;nt&quot;&gt;&amp;lt;/valid-device&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/devices/stm32/stm32f1-03-8_b.xml&quot;&gt;This device file for the F103x8/b devices&lt;/a&gt;
therefore contains all that match the identifier pattern of
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r&quot;stm32f103[crtv][8b][hitu]&quot;&lt;/code&gt;.
&lt;a href=&quot;https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/tools/device/modm/device_file.py#L33-L51&quot;&gt;The engine extracting the data set for a single device&lt;/a&gt;
will first construct a list of all possible identifier strings via the
naming schema and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;device&lt;/code&gt; combinations: 4*2*4 = 32 identifiers in this example.
It then filters these identifiers by the list in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;valid-device&amp;gt;&lt;/code&gt;, since not
every combination actually exists. Whatever device file contains the requested
identifier string is then used.&lt;/p&gt;

&lt;p&gt;The identifier schema does not have to include all traits either, it only has
to be unambiguous. For example the AVR device identifier schema does not contain
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{platform}&lt;/code&gt; but we can infer it anyways:&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;device&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;platform=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;avr&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;family=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mega&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;48|88|168|328&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;|a|p|pa&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;naming-schema&amp;gt;&lt;/span&gt;at{family}{name}{type}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/naming-schema&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It first seems unnecessary to do this reverse lookup, but it gives us a very
important property for free: The extractor does not need to &lt;em&gt;know&lt;/em&gt; anything
about the identifier, and still understands the mapping of string to traits.
So passing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stm32f103rbt&lt;/code&gt; is now &lt;em&gt;understood&lt;/em&gt; as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stm32 f1 03 r b t&lt;/code&gt;.
The disadvantage is having to first build all identifier strings, before
returning the corresponding device file. However, this mapping can be cached.&lt;/p&gt;

&lt;p&gt;The device file can now use the traits as filters by prefixing them with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;device-&lt;/code&gt;.
For our example, the device file continues with declaring the core driver instance,
which contains the memory map and vector table. The devices here only differ in
Flash size, otherwise they are identical:&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;driver&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;core&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cortex-m3&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;memory&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;device-size=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;8&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flash&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;access=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;rx&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;start=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0x8000000&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;size=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;65536&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;memory&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;device-size=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;b&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flash&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;access=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;rx&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;start=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0x8000000&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;size=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;131072&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;memory&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sram1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;access=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;rwx&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;start=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0x20000000&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;size=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;20480&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;vector&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;position=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;WWDG&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;vector&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;position=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PVD&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- ... --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;vector&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;position=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;42&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;USBWakeUp&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;By applying some simple combinatorics math we can find the minimal trait set that
uniquely describes this difference and can push this filter as far up the data
tree as possible while still being unambiguous and therefore losslessly
reconstructible for all merged device data.
This is all done for the sole purpose of optimizing for human readability, so an
embedded engineer with some experience can just look at this data and say:
“This filter looks too noisy to me, so something is probably is wrong here” 🤓
*sound of datasheet pages flipping*.&lt;/p&gt;

&lt;p&gt;Here is an example of what I so dramatically complained about before: The STM32F1
peripheral feature set is coupled to the device’s pin count: F103 devices with
just &lt;a href=&quot;https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/devices/stm32/stm32f1-03-8_b.xml#L68-L109&quot;&gt;36 pins have fewer instances of these peripherals&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;driver&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;i2c&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stm32&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;instance&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;instance&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;device-pin=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;c|r|v&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/driver&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;driver&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;spi&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stm32&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;instance&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;instance&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;device-pin=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;c|r|v&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/driver&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;driver&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;usart&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stm32&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;instance&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;instance&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;instance&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;device-pin=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;c|r|v&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;3&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/driver&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Of course both the pin count and the package influence the number of available
GPIOs and signals. The algorithm here detected that using the pin count as a
filter is enough to safely reconstruct the tree, so the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;device-package&lt;/code&gt; is
missing (it prioritizes traits further “left” in the identifier):&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;driver&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;gpio&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stm32-f1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- ... --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;gpio&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;device-pin=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;r|v&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;port=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;c&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pin=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;10&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;gpio&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;device-pin=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;r|v&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;port=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;c&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pin=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;11&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;driver=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;adc&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;instance=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;exti11&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;driver=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;adc&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;instance=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;exti11&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/gpio&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;gpio&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;device-pin=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;r|v&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;port=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;c&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pin=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;12&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;gpio&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;device-pin=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;c|r|v&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;port=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;c&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pin=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;13&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;driver=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;rtc&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;out&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;driver=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;rtc&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;tamper&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/gpio&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;device-&lt;/code&gt; filter traits are ORed, multiple filters on the same node ANDed,
and the nodes themselves ORed together again. Keen observers will point out that
this can create overly broad filters which would make for incorrect reconstruction.
For these cases we have to create two nodes with the same data, but different
filters to avoid ambiguity. Here is an example from
&lt;a href=&quot;https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/devices/stm32/stm32f4-27_29_37_39.xml#L586-L587&quot;&gt;the STM32F4{27,29,37,39} device file&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nt&quot;&gt;&amp;lt;gpio&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;port=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;c&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pin=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;3&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- ... --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;device-name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;27|37&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;device-pin=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a|i|v|z&quot;&lt;/span&gt;   &lt;span class=&quot;na&quot;&gt;af=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;12&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;driver=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;fmc&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sdcke0&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;signal&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;device-name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;29|39&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;device-pin=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a|b|i|n|z&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;af=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;12&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;driver=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;fmc&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sdcke0&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/gpio&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Hm, but that filter does look suspiciously noisy, doesn’t it? This filter pattern is
repeated for the &lt;a href=&quot;https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/devices/stm32/stm32f4-27_29_37_39.xml#L457-L458&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sdne[1:0]&lt;/code&gt;&lt;/a&gt;
and &lt;a href=&quot;https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/devices/stm32/stm32f4-27_29_37_39.xml#L558-L559&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sdnwe&lt;/code&gt;&lt;/a&gt;
signals, which all belong to the SDRAM controller in the FMC.
And according to this data set they seem to be unavailable for the LQFP100
package? Hm, better &lt;del&gt;call Saul&lt;/del&gt; check the datasheets:&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;stm32f4xx_fmc_sdcke0.png&quot; width=&quot;65%&quot; /&gt;&lt;/p&gt;

  &lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;stm32f4xx_fmc_sdcke0_af.png&quot; /&gt;&lt;br /&gt;
Huh, but the signals &lt;em&gt;do&lt;/em&gt; exist for the LQFP100 package!?&lt;/p&gt;

  &lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;stm32f4xx_fmc_100.png&quot; /&gt;&lt;br /&gt;
“FMC: Yes&lt;sup&gt;(1)&lt;/sup&gt;”. Oh, FFS!&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;I checked with CubeMX and the GPIO configurator doesn’t allow you to set SDRAM
signals in the LQFP100 package, and there are no &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STM32F4[23]7[BN]&lt;/code&gt; devices, so
everything is fine, I guess? Nothing to see here folks, move along,
the filter algorithm encoded this shit correctly. 🙃&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img dimmable=&quot;&quot; src=&quot;do_not_want.gif&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;Anyways, I like our device file format a lot, since it describes the device’s
hardware in such a compact and concise form. However, it doesn’t scale graciously
at all for data that shares less commonalities between devices in the current
clusters.&lt;/p&gt;

&lt;h3 id=&quot;data-pipeline&quot;&gt;Data Pipeline&lt;/h3&gt;

&lt;p&gt;For my rewrite of the DFG for modm I wanted to improve the correctness of device
merges, remove device specific knowledge as much as possible, support multiple
output formats and rename less data.
I’ve already hinted at solutions to some of these in the previous chapters, so
let’s have a proper look at them now.&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img src=&quot;dfg_architecture.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;The DFG has three parts: frontend, optimizer and backend. Here yellow stands for
&lt;span style=&quot;background-color:rgb(255,255,202);&quot;&gt;input data&lt;/span&gt;, blue for
&lt;span style=&quot;background-color:rgb(192,217,254);&quot;&gt;data conversion&lt;/span&gt;, red for
&lt;span style=&quot;background-color:rgb(250,202,199);&quot;&gt;intermediate representation (IR)&lt;/span&gt; and green for
&lt;span style=&quot;background-color:rgb(211,234,205);&quot;&gt;output data&lt;/span&gt;.
I’ve already covered the vendor input data and the device merging in much detail.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/modm-io/modm-devices/blob/8d38650186764c879309fd946b29e94821e6579d/tools/generator/dfg/stm32/stm_device_tree.py#L42-L345&quot;&gt;All the ugly is in the parser&lt;/a&gt;,
it reads the CubeMX data in the same manner I’ve described previously, performs
plausibility and format checks on it, and finally normalizes it into a simple
Python dictionary. This is just mostly mind-numbingly stupid code to write,
since you have to XPath query the CubeMX sources, deal with all the edge cases
in the results and normalize all data relative to all devices.
Ugly to write, ugly to read, but it gets the job done.&lt;/p&gt;

&lt;p&gt;Additional curated data gets injected in this step too. The CubeMX data
contains a hardware IP version, which seems to correlate loosely to the peripherals
feature set, however, I didn’t find it very useful to distinguish between them.
So instead I looked up how all peripherals work in the documentation and &lt;a href=&quot;https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/tools/generator/dfg/stm32/stm_peripherals.py#L298-L325&quot;&gt;grouped
them again manually&lt;/a&gt;.
The device file &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;driver/@type&lt;/code&gt; name comes from this data.&lt;/p&gt;

&lt;p&gt;For example, here we can see that the entire STM32 platform only has three
different I&lt;sup&gt;2&lt;/sup&gt;C hardware implementations, one of which only differs
with the addition of a digital noise filter.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;&apos;i2c&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[{&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&apos;instances&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;*&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&apos;groups&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;# This hardware can go up to 1MHz (Fast Mode Plus)
&lt;/span&gt;            &lt;span class=&quot;s&quot;&gt;&apos;hardware&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;stm32-extended&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&apos;features&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&apos;devices&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;family&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;f0&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;f3&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;f7&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]}]&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;},{&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&apos;hardware&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;stm32l4&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&apos;features&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;dnf&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&apos;devices&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;family&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;l4&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]}]&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;},{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;# Some F4 have a digital noise filter
&lt;/span&gt;            &lt;span class=&quot;s&quot;&gt;&apos;hardware&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;stm32&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&apos;features&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;dnf&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&apos;devices&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;family&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;f4&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;name&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;27&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;29&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;37&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;39&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;46&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;69&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;79&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]}]&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;},{&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&apos;hardware&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;stm32&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&apos;features&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&apos;devices&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;*&apos;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;All names of peripherals, instances, signals are preserved as they are, so that
the name matches the documentation. The only exception are names that wouldn’t
be valid identifiers in most programming languages.
For our STM32F103RBT example, we split up and duplicate these system signals:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SYS_JTCK-SWCLK    =&amp;gt; sys.jtck + sys.swclk
SYS_JTDO-TRACESWO =&amp;gt; sys.jtdo + sys.traceswo
SYS_JTMS-SWDIO    =&amp;gt; sys.jtms + sys.swdio
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The dictionary returned by the parser is then passed onto &lt;a href=&quot;https://github.com/modm-io/modm-devices/blob/8d38650186764c879309fd946b29e94821e6579d/tools/generator/dfg/stm32/stm_device_tree.py#L360-L487&quot;&gt;a platform specific
converter&lt;/a&gt;
that transforms it into the DFGs intermediate representation.
Here the raw data is formatted into a glorified tree structure, which has similar
semantics to a very restricted form of XML (ie. attributes are stored separately
from its children) and annotates each node with the device’s identifier.&lt;/p&gt;

&lt;p&gt;Here the memory maps and the interrupt vector table is added to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name=&quot;core&quot;&lt;/code&gt;
driver node we saw before. The raw data already contains the memories and
vectors with the right naming scheme, so it’s easy to just add them here.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;memories&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;memory_node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;core_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;memory&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;memory_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setAttributes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;access&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;start&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;size&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;interrupts&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vector_node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;core_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;vector&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vector_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setAttributes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;position&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# sort the node children by start address and size
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;core_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addSortKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;start&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;size&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
                                 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;memory&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# sort the node children by vector number and name
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;core_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addSortKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;position&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
                                 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;vector&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I’m adding two sort keys to the core driver node here, to bring the entire
tree into canonical order. This an absolute requirement for the reproducibility of
the results, otherwise I wouldn’t be able to tell what data changed if the
line order came out differently on each invocation.&lt;/p&gt;

&lt;p&gt;It’s time to merge the device IRs now. The device clustering is curated manually, by
&lt;a href=&quot;https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/tools/generator/dfg/stm32/stm_groups.py&quot;&gt;a large list of identifier trait groups&lt;/a&gt;.
I considered using some kind of heuristic to automate this,
but this works really well, particularly for the AVR and STM32F1 devices.
It’s difficult to come up with a metric that accurately describes how annoyed
I feel when looking at wrongfully merged device files with lotsa noisy filters. 😤&lt;/p&gt;

&lt;p&gt;The STM32F103 devices are split into these four groups:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&apos;family&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;f1&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&apos;name&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;03&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&apos;size&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;4&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;6&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},{&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&apos;family&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;f1&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&apos;name&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;03&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&apos;size&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;8&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;b&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},{&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&apos;family&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;f1&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&apos;name&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;03&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&apos;size&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;c&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;d&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;e&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},{&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&apos;family&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;f1&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&apos;name&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;03&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&apos;size&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;f&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;g&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In case you’re curious how bad it would be with just one large F103 group,
&lt;a href=&quot;https://gist.github.com/salkinium/95e3bf6322468c56beef9dc6c7bbaa3f&quot;&gt;here is a gist with the resulting device file&lt;/a&gt;.
It’s not as bad as it could be, but still much harder to read.&lt;/p&gt;

&lt;p&gt;At this point the merged IR for our F103RBT device basically already looks like
the finished device file, including identifier filters:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;device &amp;lt;&amp;gt; stm32f103[c|r|t|v][8|b][h|i|t|u]
. driver &amp;lt;name:core type:cortex-m3&amp;gt;
  . memory &amp;lt;name:flash access:rx start:0x8000000 size:65536&amp;gt; stm32f103[c|r|t|v]8[h|t|u]
  . memory &amp;lt;name:flash access:rx start:0x8000000 size:131072&amp;gt; stm32f103[c|r|t|v]b[h|i|t|u]
  . memory &amp;lt;name:sram1 access:rwx start:0x20000000 size:20480&amp;gt;
  . vector &amp;lt;position:0 name:WWDG&amp;gt;
     ...
  . vector &amp;lt;position:42 name:USBWakeUp&amp;gt;
. driver &amp;lt;name:i2c type:stm32&amp;gt;
  . instance &amp;lt;value:1&amp;gt;
  . instance &amp;lt;value:2&amp;gt; stm32f103[c|r|v][8|b][h|i|t|u]
. driver &amp;lt;name:spi type:stm32&amp;gt;
  . instance &amp;lt;value:1&amp;gt;
  . instance &amp;lt;value:2&amp;gt; stm32f103[c|r|v][8|b][h|i|t|u]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I’ve already described the device file format above, however, one additional
testing step is done before the DFG is finished: A copy of every single device
file is taken before merging, so that it can be compared with the device files
that are extracted from this merged one. This is a brute-force test to make sure
the filter algorithms did perform correctly.&lt;/p&gt;

&lt;p&gt;On a side note, the conversion from IR to device file format can be performed at
any time, so that last merge step is strictly speaking optional. This is useful for debugging
but also if you want to output this data in a format that does not support a
merge mechanism similar to the device file’s one, like plain JSON.&lt;/p&gt;

&lt;h2 id=&quot;using-device-files&quot;&gt;Using Device Files&lt;/h2&gt;

&lt;p&gt;So now that we have all this data, let’s have some fun with it.
modm-devices comes not only with the DFG but also with a device file parser,
which can be used like this:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;modm.parser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;glob&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;devices&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;glob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;glob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;path/to/modm-devices/devices/**/*.xml&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DeviceParser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_devices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;devices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;partname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;devices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stm32f103rbt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;properties&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;driver&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;memory&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;access&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;rx&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                     &lt;span class=&quot;s&quot;&gt;&apos;name&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;flash&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                     &lt;span class=&quot;s&quot;&gt;&apos;size&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;131072&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                     &lt;span class=&quot;s&quot;&gt;&apos;start&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;0x8000000&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;access&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;rwx&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                     &lt;span class=&quot;s&quot;&gt;&apos;name&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;sram1&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                     &lt;span class=&quot;s&quot;&gt;&apos;size&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;20480&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                     &lt;span class=&quot;s&quot;&gt;&apos;start&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;0x20000000&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}],&lt;/span&gt;
         &lt;span class=&quot;s&quot;&gt;&apos;name&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;core&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
         &lt;span class=&quot;s&quot;&gt;&apos;type&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;cortex-m3&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
         &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There are some built-in convenience functions for accessing some of the common
data in the device files:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;devices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stm32f103rbt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;identifier&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;OrderedDict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;platform&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;stm32&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;family&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;f1&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;name&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;03&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;pin&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;r&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;size&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;b&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;package&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;t&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)])&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;has_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;usart:avr&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;has_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;usart:stm32&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;usart:stm32&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;instance&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;1&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;2&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;3&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;name&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;usart&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;type&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;stm32&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I’ve also written a short &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stats&lt;/code&gt; script that allows you to compute some very basic
information about the device file collection:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;python3 tools/device/scripts/stats &lt;span class=&quot;nt&quot;&gt;--count&lt;/span&gt;
1355 devices
 &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;python3 tools/device/scripts/stats &lt;span class=&quot;nt&quot;&gt;--driver&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;ac&quot;&lt;/span&gt;: 234,
    &lt;span class=&quot;s2&quot;&gt;&quot;adc&quot;&lt;/span&gt;: 1339,
    &lt;span class=&quot;s2&quot;&gt;&quot;aes&quot;&lt;/span&gt;: 133,
    &lt;span class=&quot;s2&quot;&gt;&quot;awex&quot;&lt;/span&gt;: 26,
    &lt;span class=&quot;s2&quot;&gt;&quot;bandgap&quot;&lt;/span&gt;: 8,
    &lt;span class=&quot;s2&quot;&gt;&quot;battery_protection&quot;&lt;/span&gt;: 7,
    &lt;span class=&quot;s2&quot;&gt;&quot;bdma&quot;&lt;/span&gt;: 20,
    &lt;span class=&quot;s2&quot;&gt;&quot;bod&quot;&lt;/span&gt;: 30,
    &lt;span class=&quot;s2&quot;&gt;&quot;can&quot;&lt;/span&gt;: 683,
    &lt;span class=&quot;s2&quot;&gt;&quot;ccl&quot;&lt;/span&gt;: 30,
    &lt;span class=&quot;s2&quot;&gt;&quot;cell_balancing&quot;&lt;/span&gt;: 5,
    &lt;span class=&quot;s2&quot;&gt;&quot;cfd&quot;&lt;/span&gt;: 2,
    &lt;span class=&quot;s2&quot;&gt;&quot;charger_detect&quot;&lt;/span&gt;: 4,
    &lt;span class=&quot;s2&quot;&gt;&quot;clk&quot;&lt;/span&gt;: 45,
    &lt;span class=&quot;s2&quot;&gt;&quot;clock&quot;&lt;/span&gt;: 242,
    &lt;span class=&quot;s2&quot;&gt;&quot;comp&quot;&lt;/span&gt;: 577,
    &lt;span class=&quot;s2&quot;&gt;&quot;core&quot;&lt;/span&gt;: 1355,
    ...
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;!-- TODO: insert bar graphs for Flash/RAM distributions? --&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stats&lt;/code&gt; also allows you to dump expanded JSON for a prefix of devices and then
query that with the tool of your choice to, for example, get all the I&lt;sup&gt;2&lt;/sup&gt;C
related signals on port B for the STM32F4 device family.
Not sure why you’d want that, but it’s possible.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;python3 tools/device/scripts/stats &lt;span class=&quot;nt&quot;&gt;--json&lt;/span&gt; stm32f4 | jq &lt;span class=&quot;s1&quot;&gt;&apos;[.[] | .device.driver[] | select(.name == &quot;gpio&quot;).gpio[] | . as $gpio | .signal[]? | select(.driver == &quot;i2c&quot; and $gpio.port == &quot;b&quot;) | ($gpio.port + $gpio.pin + &quot;:&quot; + .name)] | unique&apos;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
  &lt;span class=&quot;s2&quot;&gt;&quot;b10:scl&quot;&lt;/span&gt;,
  &lt;span class=&quot;s2&quot;&gt;&quot;b11:sda&quot;&lt;/span&gt;,
  &lt;span class=&quot;s2&quot;&gt;&quot;b12:smba&quot;&lt;/span&gt;,
  &lt;span class=&quot;s2&quot;&gt;&quot;b3:sda&quot;&lt;/span&gt;,
  &lt;span class=&quot;s2&quot;&gt;&quot;b4:sda&quot;&lt;/span&gt;,
  &lt;span class=&quot;s2&quot;&gt;&quot;b5:smba&quot;&lt;/span&gt;,
  &lt;span class=&quot;s2&quot;&gt;&quot;b6:scl&quot;&lt;/span&gt;,
  &lt;span class=&quot;s2&quot;&gt;&quot;b7:sda&quot;&lt;/span&gt;,
  &lt;span class=&quot;s2&quot;&gt;&quot;b8:scl&quot;&lt;/span&gt;,
  &lt;span class=&quot;s2&quot;&gt;&quot;b8:sda&quot;&lt;/span&gt;,
  &lt;span class=&quot;s2&quot;&gt;&quot;b9:sda&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I’ll discuss in more detail how we use the device files in the next blog post
about the modm library.&lt;/p&gt;

&lt;h3 id=&quot;try-it-yourself&quot;&gt;Try it Yourself&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/modm-io/modm-devices&quot;&gt;device file as well as the DFG are available on GitHub&lt;/a&gt;
for you to play with. It automatically downloads and extracts all the raw data
into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modm-devices/tools/generator/raw-device-data&lt;/code&gt; folder.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone &lt;span class=&quot;nt&quot;&gt;--recursive&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--depth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1 https://github.com/modm-io/modm-devices.git
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;modm-devices/tools/generator
&lt;span class=&quot;c&quot;&gt;# Extract and generate STM32 device data&lt;/span&gt;
make extract-data-stm32
make generate-stm32
&lt;span class=&quot;c&quot;&gt;# Extract and generate AVR device data&lt;/span&gt;
make extract-data-avr
make generate-avr
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Not everything I described here is fully implemented, for example, the &lt;a href=&quot;https://github.com/salkinium/save-the-clocktrees&quot;&gt;clock
graph extractor is just a proof-of-concept&lt;/a&gt;
for now. modm-devices is also supposed to be a Python package installable via pip,
but that’s not implemented yet.&lt;/p&gt;

&lt;p&gt;Please help me maintain this project, I only used devices from a few STM32 families,
so it’s difficult to judge the correctness of some of this data.
If you know of any other machine readable data, please open an issue or preferrably
a pull request.&lt;/p&gt;

&lt;p&gt;Two more device file checks are currently not implemented:
a XML schema validation, and a semantical checker, that verifies the contents
consistency. For example, every GPIO signal should be associable with a driver,
and no signal name should start with a number (otherwise difficult to map into
most programming languages). These are ideas for the future.&lt;/p&gt;

&lt;p&gt;With some effort and additional data sources (CMSIS-SVD files for example),
directly outputting to Device Tree format should be possible too. I leave that
one to the experts though. 😇&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;It was important to use not to bind this data to any preconceptions of its use
by, for example, integrating it tightly into our HAL generator. Instead we’ve very
carefully separated modm-devices from our use of it, so that it can stand on its
own and be integrated into all sorts of projects by the community.
You’re not bound to using this in code either, you can also generate Markdown
documentation, or maybe build your own GPIO configurator as a web UI.&lt;/p&gt;

&lt;p&gt;You can go and use it as is with its Python &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DeviceFile&lt;/code&gt; interface, however,
for larger projects, I’d recommend you write your own wrapper class, that can
format the data as you need it.
The Device File format may change at any time, so that I can fit in new data
or once I don’t like the format anymore, change it completely. So don’t
depend on the format directly.&lt;/p&gt;

&lt;p&gt;The next few blog posts will be about applying this data in our own modm library,
how CMSIS-SVD compares to CMSIS Headers as additional data sources, and what it
means to model check your HAL with this data.&lt;/p&gt;

&lt;h3 id=&quot;on-a-personal-note&quot;&gt;On a Personal Note&lt;/h3&gt;

&lt;p&gt;The last 5 years working on this have been quite a ride. It has completely
changed my view on embedded software engineering and it took a while for me
understand this different way of thinking. As far as I know, nobody has deployed
hardware description methods on such a large and diverse device base. And we’re
just getting started.&lt;/p&gt;

&lt;p&gt;I’ve been fortunate to have found similarly minded people in the RCA, who
provided me with valuable feedback and thoughtful discussions, who mentored me
and tolerated my rants about our robot’s code quality. The RCA is self organized,
so we don’t have anyone telling us what to do, or &lt;em&gt;how&lt;/em&gt; to do it.
As a result, we do reinvent the wheel a lot, sometimes for worse,
but mostly for the better, like with this project.&lt;/p&gt;

&lt;p&gt;During this time I’ve not had the best experience with the “professional” C/C++
embedded community. There are too many established developers convinced of their
own opinions that won’t stop arguing until they’ve “won” (just ask about using
&lt;a href=&quot;https://gist.github.com/salkinium/cc7236328a532c8c0f05f74c9ceb30a4&quot;&gt;C++ on µCs&lt;/a&gt;
and bring some 🍿).
Together with the growth in amateur interest in embedded software (absolutely
&lt;em&gt;not&lt;/em&gt; a bad thing), this completely drowned out any worthwhile online discussions
on new approaches to embedded software that are different from the “approved”
norm. I’m not talking so much about the programming language itself, which is
relatively exchangeable for HALs (a rather unpopular opinion), but about HAL
design concepts and perhaps most importantly, support tools.&lt;/p&gt;

&lt;p&gt;Let me give you an example: ST has committed &lt;a href=&quot;https://github.com/ARMmbed/mbed-os/graphs/contributors&quot;&gt;at least 4-6 engineers&lt;/a&gt;
to porting its devices to Arm Mbed OS. Good for ST, that’s a lot of money.
But: ST only supports &lt;a href=&quot;https://gist.github.com/salkinium/f2140b4ba2bbf7cb3c9a99c215392048#file-targets-md&quot;&gt;55 of their ~1100 STM32 targets&lt;/a&gt;
on Mbed OS, with every single one of them ported &lt;em&gt;by hand&lt;/em&gt;.
This means at least all &lt;a href=&quot;https://gist.github.com/salkinium/f2140b4ba2bbf7cb3c9a99c215392048#file-startuplinker-md&quot;&gt;startup code and linkerscripts&lt;/a&gt;
are mostly duplicated for each target and &lt;a href=&quot;https://gist.github.com/salkinium/f2140b4ba2bbf7cb3c9a99c215392048#file-gpio_signals-md&quot;&gt;all GPIO signal data is added manually&lt;/a&gt;
by an unfortunate soul with all the &lt;a href=&quot;https://github.com/ARMmbed/mbed-os/blob/8f647beacb6f14ce1af7f2eff01d0a497f94f7ae/targets/TARGET_STM/TARGET_STM32F1/TARGET_NUCLEO_F103RB/PeripheralPins.c#L35-L37&quot;&gt;side-effects of manual labor&lt;/a&gt;.
That’s insane, as you’ve seen above, ST is already maintaining and using this data
already to generate code with CubeMX. How is this not automated?
(I dared to utter this simple observation about two years ago while working at
Arm on Mbed OS and it turned out to be &lt;em&gt;surprisingly unpopular&lt;/em&gt;. Touchy folks. 🙃)&lt;/p&gt;

&lt;p&gt;Fortunately, in the last few years there was some significant progress in enabling
(new) programming languages on embedded, like &lt;a href=&quot;http://micropython.org&quot;&gt;MicroPython&lt;/a&gt;,
&lt;a href=&quot;https://www.espruino.com&quot;&gt;Javascript runtimes&lt;/a&gt; and perhaps the most significant
of them: &lt;a href=&quot;http://blog.japaric.io&quot;&gt;Embedded in Rust&lt;/a&gt;.
I’ve been particularly impressed with the progress of the community surrounding
&lt;a href=&quot;https://twitter.com/japaricious&quot;&gt;@japaricious&lt;/a&gt;, who are currently tackling some
very hard issues, &lt;a href=&quot;http://blog.japaric.io/brave-new-io/#no-pin-overlap&quot;&gt;like IO signal grouping&lt;/a&gt;
or &lt;a href=&quot;http://blog.japaric.io/safe-dma/&quot;&gt;safe DMA APIs&lt;/a&gt;.
I’ve kinda written this blog post for them, since I think they are &lt;a href=&quot;https://internals.rust-lang.org/t/announcing-the-embedded-devices-working-group/&quot;&gt;best organized
to actually use it&lt;/a&gt;
and they don’t seem afraid to tackle these issues. (Your move, C++ people!)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Formatting of all data excerpts is possibly copyrighted by their respective owners and if so used here in fair use. However, the data itself are facts which cannot be copyrighted.&lt;/em&gt;&lt;/p&gt;</content><author><name>Niklas Hauser</name><email>niklas@salkinium.com</email></author><summary type="html">For the last 2 years Fabian Greif and I have been working on a secret project called modm: a toolkit for data-driven code generation. In a nutshell, we feed detailed hardware description data for almost all AVR and STM32 targets into a code generator to create a C++ Hardware Abstraction Layer (HAL), startup &amp;amp; linkerscript code, documentation and support tools. This isn’t exactly a new idea, after all very similar ideas have been floating around before, most notably in the Linux Kernel with its Device Tree (DT) effort. In fact, modm itself is based entirely on xpcc which matured the idea of data-driven HAL generation in the first place. However, for modm we focused on what goes on behind the scenes: how to acquire detailed target description data and how to use it with reasonable effort. We now have a toolbox that transcends its use as our C++ HAL generator and instead can be applied generically to any project in any language (*awkwardly winks at the Rust community*). That’s pretty powerful stuff. So let me first ease you into this topic with some historic background and then walk you through the data sources we use and the design decisions of our data engine. All with plenty of examples for you to follow along, just stay well clear of those hairy yaks in the distance. The Origin Story All the usual suspects in this case were members of the Roboterclub Aachen e. V. (@RCA_eV). Around 2006 the team surrounding Fabian had built a communication library called RCCP for doing remote procedure calls over CAN. Back then the only affordable microcontrollers were AVRs, but neither were they powerful enough to perform all the computations needed for autonomy nor did they have enough pins to interface with all the motors and sensors we stuffed in our robots. So an embedded PC programmed in various languages did all the heavy lifting and talked via CAN to the AVR actuators and sensors. (It has been passed on for many generations of robot builders, that the embedded PC did a disk check once during its boot process, which rendered the robot unresponsive for a few minutes. Unfortunately it did this during the a Eurobot finals game and we lost due to that. Since then our robots don’t have a kernel in their critical path anymore.) RCCP was eventually refactored into the Cross Platform Component Communication (XPCC) library and open-sourced on Sourceforge in 2009. Around 2012 when Fabian was leaving us to go work on satellites at the German space agency (DLR), I took over stewardship of the project and moved it over to GitHub where it exists to this day. It’s the foundation of all the RCAs robots. From AVR to STM32 By the time I joined in 2010, the team had been using C++ on AVRs for years. Around 2012 we finally outgrew the AVRs used to control our autonomous robots and switched over to Arm Cortex-M devices, specifically the STM32 series. So began the cumbersome task of porting the HAL that worked so well on the AVRs to the STM32F1 and F4 families, both of which have much more capable peripherals. We had inherited a C++ API that passed around static classes containing the peripheral abstraction to template classes wrapping these classes. It’s the clear anti-thesis of polymorphic interface design, almost a form of “compile time duck-typing”: class GpioB0 { public: // one class for every GPIO on the device static void set(bool state); }; class SpiMaster0 { public: // one class for every Spi peripheral static uint8_t swap(uint8_t data); }; template&amp;lt; class SpiMaster, class ChipSelect &amp;gt; class SensorDriver { public: uint8_t read() { ChipSelect::set(Gpio::Low); uint8_t result = SpiMaster::swap(foobar); ChipSelect::set(Gpio::High); return result; } }; // Hey look, a generic sensor driver SensorDriver&amp;lt; SpiMaster0, GpioB0 &amp;gt; compass; uint8_t heading = compass.read(); C++ concepts sure would be useful here for asserting SpiMaster traits. *cough* This technique resulted in a rather unusual HAL, but when used in moderation it yields ridiculously small binary sizes! And this was absolutely a requirement on our AVRs which wanted to stuff full of control code for our autonomous robots. The size reduction didn’t so much come from using C++ features like templates, but from being able to very accurately dissect special cases into their own functions. This is particularly useful on AVRs where the IO memory map is very irregular and differs quite a bit between devices. Writing one function to handle all variations at runtime can be more expensive than writing a couple of specialized functions and letting the linker throw away all the unused ones. But it does have one significant and obvious disadvantage: Our HAL had to have a class for every peripheral you want to use. And adding these classes manually didn’t scale very well with us and it proved an even bigger problem for a device with the peripheral amount and features of an STM32. And so the inevitable happened: we started using preprocessor macros to “instantiate” these peripheral classes, or switched between different implementation with extensive, often nested, #if/#else/#endif trees. It was such an ugly solution. We also had a mechanism for generating code manually calling a Jinja2 template engine and committing the result, in fact, already since Nov. 2009. It was first used to create the AVR’s UART classes and slowly expanded to other platforms. But it didn’t really scale either because you still had to explicitly provide all the substitution data to the engine, which usually only was the number, or letter, identifying the peripheral. It wasn’t until 2013 that Kevin Läufer generalized this idea by moving it into our SCons-based build system and collecting all template substitution data into one common file per target, which we just called “The Device File” (naming things is hard, ok?). This made it much easier to generate new peripheral drivers and it even did so on-the-fly during the build process due to being included into SCons’ dependency graph, which eliminated the need for manually committing these generated files and keeping them up-to-date. First Steps The first draft of the STM32F407’s device file was assembled by hand and lacked a clear structure. In retrospect, we also had trouble deciding which data goes in the device file and which stays embedded in the templates, but, we didn’t sweat the details, since we had an entire library to refactor and a robot to build. The major limitation of our system of course was getting the required data and manually assembling it didn’t scale, and so we were stuck in the same bottleneck as before, albeit with a slightly better build process. And then, after researching how avr-gcc actually generate the &amp;lt;avr/io.h&amp;gt; headers, a solution presented itself: Atmel publishes a bunch of XML files called Part Description Files, or PDFs (lolwut?), containing the memory map of their AVR devices, and we just had to reformat this a little bit. Right? If only I knew what I was getting into… &amp;lt;module name=&quot;USART&quot;&amp;gt; &amp;lt;instance name=&quot;USART0&quot; caption=&quot;USART&quot;&amp;gt; &amp;lt;register-group name=&quot;USART0&quot; name-in-module=&quot;USART0&quot; offset=&quot;0x00&quot; address-space=&quot;data&quot; caption=&quot;USART&quot;/&amp;gt; &amp;lt;signals&amp;gt; &amp;lt;signal group=&quot;TXD&quot; function=&quot;default&quot; pad=&quot;PD1&quot;/&amp;gt; &amp;lt;signal group=&quot;RXD&quot; function=&quot;default&quot; pad=&quot;PD0&quot;/&amp;gt; &amp;lt;signal group=&quot;XCK&quot; function=&quot;default&quot; pad=&quot;PD4&quot;/&amp;gt; &amp;lt;/signals&amp;gt; &amp;lt;/instance&amp;gt; &amp;lt;/module&amp;gt; &amp;lt;module name=&quot;TWI&quot;&amp;gt; &amp;lt;instance name=&quot;TWI&quot; caption=&quot;Two Wire Serial Interface&quot;&amp;gt; &amp;lt;register-group name=&quot;TWI&quot; name-in-module=&quot;TWI&quot; offset=&quot;0x00&quot; address-space=&quot;data&quot; caption=&quot;Two Wire Serial Interface&quot;/&amp;gt; &amp;lt;signals&amp;gt; &amp;lt;signal group=&quot;SDA&quot; function=&quot;default&quot; pad=&quot;PC4&quot;/&amp;gt; &amp;lt;signal group=&quot;SCL&quot; function=&quot;default&quot; pad=&quot;PC5&quot;/&amp;gt; &amp;lt;/signals&amp;gt; &amp;lt;/instance&amp;gt; &amp;lt;/module&amp;gt; &amp;lt;module name=&quot;PORT&quot;&amp;gt; &amp;lt;instance name=&quot;PORTB&quot; caption=&quot;I/O Port&quot;&amp;gt; &amp;lt;register-group name=&quot;PORTB&quot; name-in-module=&quot;PORTB&quot; offset=&quot;0x00&quot; address-space=&quot;data&quot; caption=&quot;I/O Port&quot;/&amp;gt; &amp;lt;signals&amp;gt; &amp;lt;signal group=&quot;P&quot; function=&quot;default&quot; pad=&quot;PB0&quot; index=&quot;0&quot;/&amp;gt; &amp;lt;signal group=&quot;P&quot; function=&quot;default&quot; pad=&quot;PB1&quot; index=&quot;1&quot;/&amp;gt; &amp;lt;signal group=&quot;P&quot; function=&quot;default&quot; pad=&quot;PB2&quot; index=&quot;2&quot;/&amp;gt; &amp;lt;signal group=&quot;P&quot; function=&quot;default&quot; pad=&quot;PB3&quot; index=&quot;3&quot;/&amp;gt; &amp;lt;signal group=&quot;P&quot; function=&quot;default&quot; pad=&quot;PB4&quot; index=&quot;4&quot;/&amp;gt; &amp;lt;signal group=&quot;P&quot; function=&quot;default&quot; pad=&quot;PB5&quot; index=&quot;5&quot;/&amp;gt; &amp;lt;signal group=&quot;P&quot; function=&quot;default&quot; pad=&quot;PB6&quot; index=&quot;6&quot;/&amp;gt; &amp;lt;signal group=&quot;P&quot; function=&quot;default&quot; pad=&quot;PB7&quot; index=&quot;7&quot;/&amp;gt; &amp;lt;/signals&amp;gt; &amp;lt;/instance&amp;gt; Excerpt of the ATmega328P.atdf part description file. It really turned out to be a great, but very much incomplete, source of information about AVRs. Even today, over 4 years later, 110 AVR memory maps are still missing GPIO signal definitions. So I did what any student with too much time on their hands would do: I began to manually assemble the missing information by downloading all existing AVR device datasheets, reading through all of them and collecting the pinouts in a spreadsheet. I then manually reformatted this data into a Python data structure, where it still exists today. Don’t do this! I did get the job done, but I wasted two weeks of my life with this crap and even though I was being really diligent, I still made a lot of mistakes. Ah, the insanities of youth 🙄 I also wrote a memory map comparison tool, which was really useful for understanding the batshit-insane AVR IO maps. Since the AVR can only address a certain amount of IO memory directly, the hardware engineers have to “compress” (more like “forcefully stuff”) the IO map and this quickly becomes very ugly. For example, the ATtiny*61 series features differential ADC inputs with selectable gains, configurable in 64 combinations, but register ADMUX only has space for 5 bits (MUX0 - MUX4). So Atmel decided to cram MUX5 into register ADCSRB: Wait, did the ADLAR bit just move around? Nah, must be an illusion. 😒 This memory map comparison tool was vital in understanding how all the AVRs memory maps differ and coming up with strategies on how to map this functionality into our HAL. It’s all about tools, tools, tools, tools! Peeking into STM32CubeMX ST maintains the CubeMX initialization code generator, which contains “a pinout-conflict solver, a clock-tree setting helper, a power-consumption calculator, and an utility performing MCU peripheral configuration”. Hm, doesn’t that sound interesting? How did they implement these features, we wondered. Back in 2013 CubeMX was still called MicroXplorer and wasn’t nearly as nice to use as today. It also launched as a Windows-only application, even though it was clearly written in Java (those “beautiful” GUI elements give it away). Nevertheless, CubeMX indeed is a very useful application, giving you a number of visual configuration editors: Configuring the USART1_TX signal on pin PB6 on the popular STM32F103RBT. During installation, CubeMX kindly unpacks a huge plaintext (!) database to disk at STM32CubeMX.app/Contents/Resources/db (on OSX) and even updates it for you on every app launch. This database consists out of a lot of XML files, one for every STM32 device in ST’s portfolio, plus detailed descriptions of peripheral configurations. It really is an insane amount of data. So I invite you to join me on a stroll through the colorful fields of XML that power the core of the CubeMX’s configurators. I’ll be using the STM32F103RBT, which is a very popular controller that can be found all ST Links and on the Plue Pill board available on ebay for a few bucks. GPIO Alternate Functions We start by searching for the unique device identifier STM32F103RBTx in mcu/families.xml (which is &amp;gt;30.000 lines long, btw). The minimal information about the device here is used by the parametric search engine in CubeMX. &amp;lt;Mcu Name=&quot;STM32F103R(8-B)Tx&quot; PackageName=&quot;LQFP64&quot; RefName=&quot;STM32F103RBTx&quot;&amp;gt; &amp;lt;Core&amp;gt;ARM Cortex-M3&amp;lt;/Core&amp;gt; &amp;lt;Frequency&amp;gt;72&amp;lt;/Frequency&amp;gt; &amp;lt;Ram&amp;gt;20&amp;lt;/Ram&amp;gt; &amp;lt;Flash&amp;gt;128&amp;lt;/Flash&amp;gt; &amp;lt;Voltage Max=&quot;3.6&quot; Min=&quot;2.0&quot;/&amp;gt; &amp;lt;Current Lowest=&quot;1.7&quot; Run=&quot;373.0&quot;/&amp;gt; &amp;lt;Temperature Max=&quot;105.0&quot; Min=&quot;-40.0&quot;/&amp;gt; &amp;lt;Peripheral Type=&quot;ADC 12-bit&quot; MaxOccurs=&quot;16&quot;/&amp;gt; &amp;lt;Peripheral Type=&quot;CAN&quot; MaxOccurs=&quot;1&quot;/&amp;gt; &amp;lt;Peripheral Type=&quot;I2C&quot; MaxOccurs=&quot;2&quot;/&amp;gt; &amp;lt;Peripheral Type=&quot;RTC&quot; MaxOccurs=&quot;1&quot;/&amp;gt; &amp;lt;Peripheral Type=&quot;SPI&quot; MaxOccurs=&quot;2&quot;/&amp;gt; &amp;lt;Peripheral Type=&quot;Timer 16-bit&quot; MaxOccurs=&quot;4&quot;/&amp;gt; &amp;lt;Peripheral Type=&quot;USART&quot; MaxOccurs=&quot;3&quot;/&amp;gt; &amp;lt;Peripheral Type=&quot;USB Device&quot; MaxOccurs=&quot;1&quot;/&amp;gt; &amp;lt;/Mcu&amp;gt; Following the Mcu/@Name leads us to STM32F103R(8-B)Tx.xml containing what peripherals and how many (mcu/IP/@InstanceName) as well as what pins exists on this package and where and what alternate functions they can be connected to. &amp;lt;Core&amp;gt;ARM Cortex-M3&amp;lt;/Core&amp;gt; &amp;lt;Ram&amp;gt;20&amp;lt;/Ram&amp;gt; &amp;lt;Flash&amp;gt;64&amp;lt;/Flash&amp;gt; &amp;lt;Flash&amp;gt;128&amp;lt;/Flash&amp;gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;IP InstanceName=&quot;USART3&quot; Name=&quot;USART&quot; Version=&quot;sci2_v1_1_Cube&quot;/&amp;gt; &amp;lt;IP InstanceName=&quot;RCC&quot; Name=&quot;RCC&quot; Version=&quot;STM32F102_rcc_v1_0&quot;/&amp;gt; &amp;lt;IP InstanceName=&quot;NVIC&quot; Name=&quot;NVIC&quot; Version=&quot;STM32F103G&quot;/&amp;gt; &amp;lt;IP InstanceName=&quot;GPIO&quot; Name=&quot;GPIO&quot; Version=&quot;STM32F103x8_gpio_v1_0&quot;/&amp;gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;Pin Name=&quot;PB5&quot; Position=&quot;57&quot; Type=&quot;I/O&quot;&amp;gt; &amp;lt;Signal Name=&quot;I2C1_SMBA&quot;/&amp;gt; &amp;lt;Signal Name=&quot;SPI1_MOSI&quot;/&amp;gt; &amp;lt;Signal Name=&quot;TIM3_CH2&quot;/&amp;gt; &amp;lt;/Pin&amp;gt; &amp;lt;Pin Name=&quot;PB6&quot; Position=&quot;58&quot; Type=&quot;I/O&quot;&amp;gt; &amp;lt;Signal Name=&quot;I2C1_SCL&quot;/&amp;gt; &amp;lt;Signal Name=&quot;TIM4_CH1&quot;/&amp;gt; &amp;lt;Signal Name=&quot;USART1_TX&quot;/&amp;gt; &amp;lt;/Pin&amp;gt; &amp;lt;Pin Name=&quot;PB7&quot; Position=&quot;59&quot; Type=&quot;I/O&quot;&amp;gt; &amp;lt;Signal Name=&quot;I2C1_SDA&quot;/&amp;gt; &amp;lt;Signal Name=&quot;TIM4_CH2&quot;/&amp;gt; &amp;lt;Signal Name=&quot;USART1_RX&quot;/&amp;gt; &amp;lt;/Pin&amp;gt; Each peripheral has a IP/@Version, which leads to a configuration file containing even more data. Don’t cha just love the smell of freshly unpacked data in the morning? For this device’s GPIO peripheral we’ll look for any pins with the USART1_TX signal in the mcu/IP/GPIO-STM32F103x8_gpio_v1_0_Modes.xml file: &amp;lt;GPIO_Pin PortName=&quot;PB&quot; Name=&quot;PB6&quot;&amp;gt; &amp;lt;PinSignal Name=&quot;USART1_TX&quot;&amp;gt; &amp;lt;RemapBlock Name=&quot;USART1_REMAP1&quot;&amp;gt; &amp;lt;SpecificParameter Name=&quot;GPIO_AF&quot;&amp;gt; &amp;lt;PossibleValue&amp;gt;__HAL_AFIO_REMAP_USART1_ENABLE&amp;lt;/PossibleValue&amp;gt; &amp;lt;/SpecificParameter&amp;gt; &amp;lt;/RemapBlock&amp;gt; &amp;lt;/PinSignal&amp;gt; &amp;lt;/GPIO_Pin&amp;gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;GPIO_Pin PortName=&quot;PA&quot; Name=&quot;PA9&quot;&amp;gt; &amp;lt;PinSignal Name=&quot;USART1_TX&quot;&amp;gt; &amp;lt;RemapBlock Name=&quot;USART1_REMAP0&quot; DefaultRemap=&quot;true&quot;/&amp;gt; &amp;lt;/PinSignal&amp;gt; &amp;lt;/GPIO_Pin&amp;gt; So USART1_TX maps to pin PB6 with USART1_REMAP1 or pin PA9 with USART1_REMAP0. The STM32F1 series remap signals either in (overlapping) groups or not at all. This is controlled by the AFIO_MAPRx registers, where we can find PB6/PA9 again: The __HAL_AFIO_REMAP_USART1_ENABLE in the XML is actually just a C function name, and is placed by CubeMX in the generated init code. void HAL_UART_MspInit(UART_HandleTypeDef* huart) { GPIO_InitTypeDef GPIO_InitStruct; if(huart-&amp;gt;Instance==USART1) { /* Peripheral clock enable */ __HAL_RCC_USART1_CLK_ENABLE(); /**USART1 GPIO Configuration PB6 ------&amp;gt; USART1_TX PB7 ------&amp;gt; USART1_RX */ GPIO_InitStruct.Pin = GPIO_PIN_6; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; HAL_GPIO_Init(GPIOB, &amp;amp;GPIO_InitStruct); GPIO_InitStruct.Pin = GPIO_PIN_7; GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_NOPULL; HAL_GPIO_Init(GPIOB, &amp;amp;GPIO_InitStruct); __HAL_AFIO_REMAP_USART1_ENABLE(); } } The IP files do contain a very large amount of information, however, it’s mostly directed at the code generation capabilities of the CubeMX project exporter, and as such, not very useful as stand-alone information. For example, the above GPIO signal information relies on the existence of a __HAL_AFIO_REMAP_USART1_ENABLE() function that performs the remapping. The mapping between the bits in the AFIO_MAPRx registers and the remap groups is therefore encoded in two separate places: these xml files, and the family’s CubeHAL. The mcu/IP/NVIC-STM32F103G_Modes.xml configuration file, used to configure the NVIC in the CubeMX, exemplifies this quite well: here we see the first 10 interrupt vectors paired with additional metadata (PossibleValue/@Value seems to contain some : separated conditionals for visibility inside the GUI tool). &amp;lt;RefParameter Comment=&quot;Interrupt Table&quot; Name=&quot;IRQn&quot; Type=&quot;list&quot;&amp;gt; &amp;lt;PossibleValue Comment=&quot;Non maskable interrupt&quot; Value=&quot;NonMaskableInt_IRQn:N,IF_HAL::HAL_RCC_NMI_IRQHandler:CSSEnabled&quot;/&amp;gt; &amp;lt;PossibleValue Comment=&quot;Hard fault interrupt&quot; Value=&quot;HardFault_IRQn:N,W1:::&quot;/&amp;gt; &amp;lt;PossibleValue Comment=&quot;Memory management fault&quot; Value=&quot;MemoryManagement_IRQn:Y,W1:::&quot;/&amp;gt; &amp;lt;PossibleValue Comment=&quot;Prefetch fault, memory access fault&quot; Value=&quot;BusFault_IRQn:Y,W1:::&quot;/&amp;gt; &amp;lt;PossibleValue Comment=&quot;Undefined instruction or illegal state&quot; Value=&quot;UsageFault_IRQn:Y,W1:::&quot;/&amp;gt; &amp;lt;PossibleValue Comment=&quot;System service call via SWI instruction&quot; Value=&quot;SVCall_IRQn:Y,RTOS::NONE:&quot;/&amp;gt; &amp;lt;PossibleValue Comment=&quot;Debug monitor&quot; Value=&quot;DebugMonitor_IRQn:Y::NONE:&quot;/&amp;gt; &amp;lt;PossibleValue Comment=&quot;Pendable request for system service&quot; Value=&quot;PendSV_IRQn:Y,RTOS::NONE:&quot;/&amp;gt; &amp;lt;PossibleValue Comment=&quot;System tick timer&quot; Value=&quot;SysTick_IRQn:Y:::&quot;/&amp;gt; &amp;lt;PossibleValue Comment=&quot;Window watchdog interrupt&quot; Value=&quot;WWDG_IRQn:Y:WWDG:HAL_WWDG_IRQHandler:&quot;/&amp;gt; However, their actual position in the interrupt vector table is missing, and so this data cannot be used to extract a valid interrupt table. Instead an alias is used here to pair the interrupt with its actual table position, as defined in the STM32F103xB CMSIS header file. For example, the WWDG interrupt vector is located at position 16 (=16+0), while the SVCall vector is located at position 11 (=16-5), or 5 positions behind the UsageFault vector: /*!&amp;lt; Interrupt Number Definition */ typedef enum { NonMaskableInt_IRQn = -14, /*!&amp;lt; 2 Non Maskable Interrupt */ HardFault_IRQn = -13, /*!&amp;lt; 3 Cortex-M3 Hard Fault Interrupt */ MemoryManagement_IRQn = -12, /*!&amp;lt; 4 Cortex-M3 Memory Management Interrupt */ BusFault_IRQn = -11, /*!&amp;lt; 5 Cortex-M3 Bus Fault Interrupt */ UsageFault_IRQn = -10, /*!&amp;lt; 6 Cortex-M3 Usage Fault Interrupt */ SVCall_IRQn = -5, /*!&amp;lt; 11 Cortex-M3 SV Call Interrupt */ DebugMonitor_IRQn = -4, /*!&amp;lt; 12 Cortex-M3 Debug Monitor Interrupt */ PendSV_IRQn = -2, /*!&amp;lt; 14 Cortex-M3 Pend SV Interrupt */ SysTick_IRQn = -1, /*!&amp;lt; 15 Cortex-M3 System Tick Interrupt */ WWDG_IRQn = 0, /*!&amp;lt; Window WatchDog Interrupt */ // ... } IRQn_Type; So keep in mind that this data is not meant to be a sensible hardware description format and it just often lacks basic information that would make it much more useful. Then again, the only consumer of this information is supposed to be CubeMX for its fairly narrow goal of code generation. Clock Tree Let’s look at another very interesting data source in CubeMX: the clock configuration wizard: What’s so interesting about this configurator is that it knows what the maximum frequencies of the respective clock segments are, and more importantly, how to set the prescalers to resolve these issues and this for every device. You surely know where this is going by know. Yup, it’s backed by data, and here is what it looks like rendered with graphviz. Here is a beautified excerpt from plugins/clock/STM32F102.xml, which only shows the connections highlighted in red. Note how the text in the nodes maps to the Element/@type and Element/@id attributes, and how the Element/Output and Element/Input children declare a (unique) @signalId and which node they are connecting to: &amp;lt;Tree id=&quot;ClockTree&quot;&amp;gt; &amp;lt;!-- HSE --&amp;gt; &amp;lt;Element id=&quot;HSEOSC&quot; type=&quot;variedSource&quot; refParameter=&quot;HSE_VALUE&quot;&amp;gt; &amp;lt;Output signalId=&quot;HSE&quot; to=&quot;HSEDivPLL&quot;/&amp;gt; &amp;lt;/Element&amp;gt; &amp;lt;!-- PLL div input from HSE --&amp;gt; &amp;lt;Element id=&quot;HSEDivPLL&quot; type=&quot;devisor&quot; refParameter=&quot;HSEDivPLL&quot;&amp;gt; &amp;lt;Input signalId=&quot;HSE&quot; from=&quot;HSEOSC&quot;/&amp;gt; &amp;lt;Output signalId=&quot;HSE_PLL&quot; to=&quot;PLLSource&quot;/&amp;gt; &amp;lt;/Element&amp;gt; &amp;lt;Tree id=&quot;PLL&quot;&amp;gt; &amp;lt;!-- PLLsource MUX source pour PLL mul --&amp;gt; &amp;lt;Element id=&quot;PLLSource&quot; type=&quot;multiplexor&quot; refParameter=&quot;PLLSourceVirtual&quot;&amp;gt; &amp;lt;Input signalId=&quot;HSE_PLL&quot; from=&quot;HSEDivPLL&quot; refValue=&quot;RCC_PLLSOURCE_HSE&quot;/&amp;gt; &amp;lt;Output signalId=&quot;VCOInput&quot; to=&quot;VCO2output&quot;/&amp;gt; &amp;lt;/Element&amp;gt; &amp;lt;Element id=&quot;VCO2output&quot; type=&quot;output&quot; refParameter=&quot;VCOOutput2Freq_Value&quot;&amp;gt; &amp;lt;Input signalId=&quot;VCOInput&quot; from=&quot;PLLSource&quot;/&amp;gt; &amp;lt;Output signalId=&quot;VCO2Input&quot; to=&quot;PLLMUL&quot;/&amp;gt; &amp;lt;/Element&amp;gt; &amp;lt;Element id=&quot;PLLMUL&quot; type=&quot;multiplicator&quot; refParameter=&quot;PLLMUL&quot;&amp;gt; &amp;lt;Input signalId=&quot;VCO2Input&quot; from=&quot;VCO2output&quot;/&amp;gt; &amp;lt;Output signalId=&quot;PLLCLK&quot; to=&quot;SysClkSource&quot;/&amp;gt; &amp;lt;/Element&amp;gt; &amp;lt;/Tree&amp;gt; &amp;lt;!--Sysclock mux --&amp;gt; &amp;lt;Element id=&quot;SysClkSource&quot; type=&quot;multiplexor&quot; refParameter=&quot;SYSCLKSource&quot;&amp;gt; &amp;lt;Input signalId=&quot;PLLCLK&quot; from=&quot;PLLMUL&quot; refValue=&quot;RCC_SYSCLKSOURCE_PLLCLK&quot;/&amp;gt; &amp;lt;Output signalId=&quot;SYSCLK&quot; to=&quot;SysCLKOutput&quot;/&amp;gt; &amp;lt;/Element&amp;gt; &amp;lt;Element id=&quot;SysCLKOutput&quot; type=&quot;output&quot; refParameter=&quot;SYSCLKFreq_VALUE&quot;&amp;gt; &amp;lt;Input signalId=&quot;SYSCLK&quot; from=&quot;SysClkSource&quot;/&amp;gt; &amp;lt;Output signalId=&quot;SYSCLKOUT&quot; to=&quot;AHBPrescaler&quot;/&amp;gt; &amp;lt;/Element&amp;gt; &amp;lt;!-- AHB input**SYSclock** --&amp;gt; &amp;lt;Element id=&quot;AHBPrescaler&quot; type=&quot;devisor&quot; refParameter=&quot;AHBCLKDivider&quot;&amp;gt; &amp;lt;Input signalId=&quot;SYSCLKOUT&quot; from=&quot;SysCLKOutput&quot;/&amp;gt; &amp;lt;Output signalId=&quot;HCLK&quot; to=&quot;AHBOutput&quot;/&amp;gt; &amp;lt;/Element&amp;gt; &amp;lt;!-- AHB input**SYSclock** output**FHCLK,HCLK,Diviseurcortex,APB1,APB2 --&amp;gt; &amp;lt;Element id=&quot;AHBOutput&quot; type=&quot;activeOutput&quot; refParameter=&quot;HCLKFreq_Value&quot;&amp;gt; &amp;lt;Input signalId=&quot;HCLK&quot; from=&quot;AHBPrescaler&quot;/&amp;gt; &amp;lt;Output to=&quot;FCLKCortexOutput&quot; signalId=&quot;AHBCLK&quot;/&amp;gt; &amp;lt;Output to=&quot;FSMClkOutput&quot; signalId=&quot;AHBCLK&quot;/&amp;gt; &amp;lt;Output to=&quot;SDIOClkOutput&quot; signalId=&quot;AHBCLK&quot;/&amp;gt; &amp;lt;Output to=&quot;HCLKDiv2&quot; signalId=&quot;AHBCLK&quot;/&amp;gt; &amp;lt;Output to=&quot;HCLKOutput&quot; signalId=&quot;AHBCLK&quot;/&amp;gt; &amp;lt;Output to=&quot;TimSysPresc&quot; signalId=&quot;AHBCLK&quot;/&amp;gt; &amp;lt;Output to=&quot;APB1Prescaler&quot; signalId=&quot;AHBCLK&quot;/&amp;gt; &amp;lt;Output to=&quot;APB2Prescaler&quot; signalId=&quot;AHBCLK&quot;/&amp;gt; &amp;lt;/Element&amp;gt; &amp;lt;/Tree&amp;gt; We still don’t know how CubeMX is able to do it actual calculations, because the clock graph above doesn’t contain any numbers at all. Some digging around later we can trace the Element/@refParameter attribute to the IP/RCC-STM32F102_rcc_v1_0_Modes.xml which contains *drumroll* numbers, and lots of ‘em: &amp;lt;!-- Les frequences des sources --&amp;gt; &amp;lt;RefParameter Name=&quot;HSE_VALUE&quot; Min=&quot;4000000&quot; Max=&quot;16000000&quot; Display=&quot;value/1000000&quot; Unit=&quot;MHz&quot;/&amp;gt; &amp;lt;!-- frequence PLL --&amp;gt; &amp;lt;RefParameter Name=&quot;VCOOutput2Freq_Value&quot; Min=&quot;1000000&quot; Max=&quot;25000000&quot; Display=&quot;value/1000000&quot; Unit=&quot;MHz&quot;/&amp;gt; &amp;lt;!-- les diviseurs --&amp;gt; &amp;lt;RefParameter Name=&quot;HSEDivPLL&quot; DefaultValue=&quot;RCC_HSE_PREDIV_DIV1&quot;&amp;gt; &amp;lt;PossibleValue Comment=&quot;1&quot; Value=&quot;RCC_HSE_PREDIV_DIV1&quot;/&amp;gt; &amp;lt;PossibleValue Comment=&quot;2&quot; Value=&quot;RCC_HSE_PREDIV_DIV2&quot;/&amp;gt; &amp;lt;/RefParameter&amp;gt; &amp;lt;!-- Les multiplicateurs --&amp;gt; &amp;lt;RefParameter Name=&quot;PLLMUL&quot; DefaultValue=&quot;RCC_PLL_MUL2&quot;&amp;gt; &amp;lt;PossibleValue Comment=&quot;2&quot; Value=&quot;RCC_PLL_MUL2&quot;/&amp;gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;PossibleValue Comment=&quot;16&quot; Value=&quot;RCC_PLL_MUL16&quot;/&amp;gt; &amp;lt;/RefParameter&amp;gt; &amp;lt;!-- Les frequences des signaux --&amp;gt; &amp;lt;!-- SYS clock freq de l&apos;output --&amp;gt; &amp;lt;RefParameter Name=&quot;SYSCLKFreq_VALUE&quot; Max=&quot;72000000&quot; Display=&quot;value/1000000&quot; Unit=&quot;MHz&quot;/&amp;gt; &amp;lt;!-- diviseur AHB 1..512 --&amp;gt; &amp;lt;RefParameter Name=&quot;AHBCLKDivider&quot; DefaultValue=&quot;RCC_SYSCLK_DIV1&quot;&amp;gt; &amp;lt;PossibleValue Comment=&quot;1&quot; Value=&quot;RCC_SYSCLK_DIV1&quot;/&amp;gt; &amp;lt;PossibleValue Comment=&quot;2&quot; Value=&quot;RCC_SYSCLK_DIV2&quot;/&amp;gt; &amp;lt;PossibleValue Comment=&quot;4&quot; Value=&quot;RCC_SYSCLK_DIV4&quot;/&amp;gt; &amp;lt;PossibleValue Comment=&quot;8&quot; Value=&quot;RCC_SYSCLK_DIV8&quot;/&amp;gt; &amp;lt;PossibleValue Comment=&quot;16&quot; Value=&quot;RCC_SYSCLK_DIV16&quot;/&amp;gt; &amp;lt;PossibleValue Comment=&quot;64&quot; Value=&quot;RCC_SYSCLK_DIV64&quot;/&amp;gt; &amp;lt;PossibleValue Comment=&quot;128&quot; Value=&quot;RCC_SYSCLK_DIV128&quot;/&amp;gt; &amp;lt;PossibleValue Comment=&quot;256&quot; Value=&quot;RCC_SYSCLK_DIV256&quot;/&amp;gt; &amp;lt;PossibleValue Comment=&quot;512&quot; Value=&quot;RCC_SYSCLK_DIV512&quot;/&amp;gt; &amp;lt;/RefParameter&amp;gt; &amp;lt;!-- AHB out freq --&amp;gt; &amp;lt;RefParameter Name=&quot;HCLKFreq_Value&quot; Max=&quot;72000000&quot; Display=&quot;value/1000000&quot; Unit=&quot;MHz&quot;/&amp;gt; Did you know that ST is a French-Italian company? Cos those XML comments clearly aren’t in English. 🤔 Well, that and they seem keen on calling it a “devisor” when they really mean “divider”. What is this, I don’t even. French comments in XML Anyways, here you can see the RefParameter/@min and RefParameter/@max frequency values as well as prescaler values encoded as PossibleValue/@Comment, which are all used by CubeMX to check and fix your clock tree. That’s pretty amazing actually. Ok, so I’m not going into the data of their board support packages, because I don’t think any health insurance covers this much exposure to XML, especially not XML containing French comments. But feel free to take a look at your own risk, it’s just waiting there in plugins/boardmanager/boards for your prying eyes. Let’s move on to how we can extract this data programmatically and use it to bring order to chaos, one example at a time. A bit like the Avengers franchise *drags out blog post to infinity* Generating Device Files The goal of finding machine-readable device description data obviously was to write a program to import, clean-up and convert it into a format that’s more agreeable to our use-case of generating a HAL. Ironically the Device File Generator (DFG) started out in mid 2013 with the innocently named commit “Cheap and simple parsing of the XML files”. It’s not cheap and simple anymore. The DFG started out as a glorified XPath wrapper in xpcc, but then quickly devolved into some messy monster, that pulled in data from all over the place and arranged it without much concept. Back then we were busy building porting the HAL, writing sensor drivers and building robots, so we didn’t approach this problem structurally, and rather fixed bugs when they occurred. I won’t talk about xpcc’s DFG architecture issues in detail, instead I’ll be showing you the problems it caused us. This way, the lessons learned are more transferable to other format (*cough* Device Tree *cough*), since the device data is immutable whereas the DFG’s architecture is not. Note that I rewrote the DFG from scratch for modm, so you can have a look at the source code while reading this. I’m continuing to use the STM32F103RBT6 for illustration, but this all works very similarly for all STM32 and AVR devices. Device Identifiers We needed a way to identify what device to build our HAL for, and of course we use the manufacturers identifier, since it’s (hopefully) unique. We also needed to split up the identifier string, so that the HAL can query its traits to select what code templates to use. For example, in xpcc we split stm32f103rbt6 into: stm32 f1 103 r b ​ {platform}{family}{name}{pin-id}{size-id} Note how we forgot the t6 suffix. If we compare this with the documentation on the ST ordering information scheme, you’ll see why this was a huge mistake: Yup, that’s right, we forgot to encode the package type, causing the DFG to select the first device matching STM32F103RB! And that would be the STM32F103RBHx device, since it occurs first in families.xml. &amp;lt;Mcu Name=&quot;STM32F103R(8-B)Hx&quot; PackageName=&quot;TFBGA64&quot; RefName=&quot;STM32F103RBHx&quot;&amp;gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;Mcu Name=&quot;STM32F103R(8-B)Tx&quot; PackageName=&quot;LQFP64&quot; RefName=&quot;STM32F103RBTx&quot;&amp;gt; So we actually used the definitions for the TFBGA64 packaged device instead of the LQFP64 packaged device. 🤦‍ Incredibly this didn’t cause immediate problems, since we first focussed on the STM32F3 and F4 families, whose functionality is almost identical between packages. However, we did notice some changes when a new version of CubeMX was released which added or reordered devices in families.xml. And then all hell broke loose when I added support for parsing the STM32F1 device family, which couples peripheral features to memory size and(!) pin count: “32 KB Flash(1)” aka. this table isn’t complicated enough already If you’re a hardware engineer at $vendor, PLEASE DON’T DO THIS! This is pure punishment for anyone writing software for these chips. PLEASE DO NOT DO THIS! You should not have to query for combinations of identifier traits to get your hardware feature set. Expand your device lineup into new (orthogonal) identifier space instead. To be fair, the STM32F1 family was the first ST product to feature a Cortex-M processor and they didn’t use this approach for any of their other STM32 families. I forgive you, ST. So for modm I looked very carefully at how to split the identifier into traits. I made the trait composition and naming transparent to the DFG, it only operates on a dictionary of items, sharing the same identifier mechanism with the AVRs. Since we currently don’t have any information that depends on the temperature range, I left it out for now. Similarly, the device revision is not considered either. stm32 f1 03 r b t ​ {platform}{family}{name}{pin}{size}{package} Note how both the xpcc and modm identifier encodings differ from the official ST ordering scheme. Since we are sharing some code across vendors (like the Cortex-M startup code), we need to have a common naming scheme, at least for {platform} and {family} or the equivalent for other vendors. Also note that {name} now does not contain part the trailing 1 of the family. This is to prevent the problem in xpcc where the code template authors only checked for the {name} instead of the {family} and {name}, for example, id[&quot;name&quot;] == &quot;103&quot; vs. id[&quot;family&quot;] == &quot;f1&quot; and id[&quot;name&quot;] == &quot;03&quot;. This lead to issues when we ported some peripheral drivers to the L1 family (similar to F0/L0, F4/L4 and F7/H7). Encoding Commonality You’ve undoubtedly already noticed that the AVR and CubeMX data is quite verbose and noisy. We didn’t want to use this data directly, hence the DFG. However, we wanted to go a step further and cut down on duplicated data, so that we have an easier time verifying the output of the DFG by not having to look through thousands of files, but rather dozens. At the time of this writing, families.xml contains 1171 STM32 devices, but modm-devices/devices/stm32 only contains 62 device files, that’s ~19x less files than devices. We observed that ST clusters their devices on their website, in their technical documentation and in their software offerings. The coarsest regular cluster pattern is the family, which denotes the type of Cortex-M code used among other features. The subfamilies are then more or less arbitrarily clustered around whatever combination of functionality ST wanted to bring to market, but the cluster patterns of pin count, memory size and package are very regular and often explicitly called out. We wanted to reflect this in our data structure too. This STM32F4x9 feature matrix is extremely regular. The Device Tree format deals with data duplication by allowing data specialization through an inheritance tree and tree inclusion nodes. However, you still have to create one leaf node for every device, so in the best case you’d have one DT per device, or if you moved common data up the inheritance tree, you’d have more files than devices. We decided instead to merge our data trees for devices within similar enough clusters and then filter out the data for one device on access. We use logical OR (|) to combine identifier traits to declare what devices are merged. You’ll recognize the &amp;lt;naming-schema&amp;gt; from the previous chapter: &amp;lt;device platform=&quot;stm32&quot; family=&quot;f1&quot; name=&quot;03&quot; pin=&quot;c|r|t|v&quot; size=&quot;8|b&quot; package=&quot;h|i|t|u&quot;&amp;gt; &amp;lt;naming-schema&amp;gt;{platform}{family}{name}{pin}{size}{package}&amp;lt;/naming-schema&amp;gt; &amp;lt;valid-device&amp;gt;stm32f103c8t&amp;lt;/valid-device&amp;gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;valid-device&amp;gt;stm32f103rbt&amp;lt;/valid-device&amp;gt; This device file for the F103x8/b devices therefore contains all that match the identifier pattern of r&quot;stm32f103[crtv][8b][hitu]&quot;. The engine extracting the data set for a single device will first construct a list of all possible identifier strings via the naming schema and the device combinations: 4*2*4 = 32 identifiers in this example. It then filters these identifiers by the list in &amp;lt;valid-device&amp;gt;, since not every combination actually exists. Whatever device file contains the requested identifier string is then used. The identifier schema does not have to include all traits either, it only has to be unambiguous. For example the AVR device identifier schema does not contain {platform} but we can infer it anyways: &amp;lt;device platform=&quot;avr&quot; family=&quot;mega&quot; name=&quot;48|88|168|328&quot; type=&quot;|a|p|pa&quot;&amp;gt; &amp;lt;naming-schema&amp;gt;at{family}{name}{type}&amp;lt;/naming-schema&amp;gt; It first seems unnecessary to do this reverse lookup, but it gives us a very important property for free: The extractor does not need to know anything about the identifier, and still understands the mapping of string to traits. So passing stm32f103rbt is now understood as stm32 f1 03 r b t. The disadvantage is having to first build all identifier strings, before returning the corresponding device file. However, this mapping can be cached. The device file can now use the traits as filters by prefixing them with device-. For our example, the device file continues with declaring the core driver instance, which contains the memory map and vector table. The devices here only differ in Flash size, otherwise they are identical: &amp;lt;driver name=&quot;core&quot; type=&quot;cortex-m3&quot;&amp;gt; &amp;lt;memory device-size=&quot;8&quot; name=&quot;flash&quot; access=&quot;rx&quot; start=&quot;0x8000000&quot; size=&quot;65536&quot;/&amp;gt; &amp;lt;memory device-size=&quot;b&quot; name=&quot;flash&quot; access=&quot;rx&quot; start=&quot;0x8000000&quot; size=&quot;131072&quot;/&amp;gt; &amp;lt;memory name=&quot;sram1&quot; access=&quot;rwx&quot; start=&quot;0x20000000&quot; size=&quot;20480&quot;/&amp;gt; &amp;lt;vector position=&quot;0&quot; name=&quot;WWDG&quot;/&amp;gt; &amp;lt;vector position=&quot;1&quot; name=&quot;PVD&quot;/&amp;gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;vector position=&quot;42&quot; name=&quot;USBWakeUp&quot;/&amp;gt; By applying some simple combinatorics math we can find the minimal trait set that uniquely describes this difference and can push this filter as far up the data tree as possible while still being unambiguous and therefore losslessly reconstructible for all merged device data. This is all done for the sole purpose of optimizing for human readability, so an embedded engineer with some experience can just look at this data and say: “This filter looks too noisy to me, so something is probably is wrong here” 🤓 *sound of datasheet pages flipping*. Here is an example of what I so dramatically complained about before: The STM32F1 peripheral feature set is coupled to the device’s pin count: F103 devices with just 36 pins have fewer instances of these peripherals: &amp;lt;driver name=&quot;i2c&quot; type=&quot;stm32&quot;&amp;gt; &amp;lt;instance value=&quot;1&quot;/&amp;gt; &amp;lt;instance device-pin=&quot;c|r|v&quot; value=&quot;2&quot;/&amp;gt; &amp;lt;/driver&amp;gt; &amp;lt;driver name=&quot;spi&quot; type=&quot;stm32&quot;&amp;gt; &amp;lt;instance value=&quot;1&quot;/&amp;gt; &amp;lt;instance device-pin=&quot;c|r|v&quot; value=&quot;2&quot;/&amp;gt; &amp;lt;/driver&amp;gt; &amp;lt;driver name=&quot;usart&quot; type=&quot;stm32&quot;&amp;gt; &amp;lt;instance value=&quot;1&quot;/&amp;gt; &amp;lt;instance value=&quot;2&quot;/&amp;gt; &amp;lt;instance device-pin=&quot;c|r|v&quot; value=&quot;3&quot;/&amp;gt; &amp;lt;/driver&amp;gt; Of course both the pin count and the package influence the number of available GPIOs and signals. The algorithm here detected that using the pin count as a filter is enough to safely reconstruct the tree, so the device-package is missing (it prioritizes traits further “left” in the identifier): &amp;lt;driver name=&quot;gpio&quot; type=&quot;stm32-f1&quot;&amp;gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;gpio device-pin=&quot;r|v&quot; port=&quot;c&quot; pin=&quot;10&quot;/&amp;gt; &amp;lt;gpio device-pin=&quot;r|v&quot; port=&quot;c&quot; pin=&quot;11&quot;&amp;gt; &amp;lt;signal driver=&quot;adc&quot; instance=&quot;1&quot; name=&quot;exti11&quot;/&amp;gt; &amp;lt;signal driver=&quot;adc&quot; instance=&quot;2&quot; name=&quot;exti11&quot;/&amp;gt; &amp;lt;/gpio&amp;gt; &amp;lt;gpio device-pin=&quot;r|v&quot; port=&quot;c&quot; pin=&quot;12&quot;/&amp;gt; &amp;lt;gpio device-pin=&quot;c|r|v&quot; port=&quot;c&quot; pin=&quot;13&quot;&amp;gt; &amp;lt;signal driver=&quot;rtc&quot; name=&quot;out&quot;/&amp;gt; &amp;lt;signal driver=&quot;rtc&quot; name=&quot;tamper&quot;/&amp;gt; &amp;lt;/gpio&amp;gt; The device- filter traits are ORed, multiple filters on the same node ANDed, and the nodes themselves ORed together again. Keen observers will point out that this can create overly broad filters which would make for incorrect reconstruction. For these cases we have to create two nodes with the same data, but different filters to avoid ambiguity. Here is an example from the STM32F4{27,29,37,39} device file: &amp;lt;gpio port=&quot;c&quot; pin=&quot;3&quot;&amp;gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;signal device-name=&quot;27|37&quot; device-pin=&quot;a|i|v|z&quot; af=&quot;12&quot; driver=&quot;fmc&quot; name=&quot;sdcke0&quot;/&amp;gt; &amp;lt;signal device-name=&quot;29|39&quot; device-pin=&quot;a|b|i|n|z&quot; af=&quot;12&quot; driver=&quot;fmc&quot; name=&quot;sdcke0&quot;/&amp;gt; &amp;lt;/gpio&amp;gt; Hm, but that filter does look suspiciously noisy, doesn’t it? This filter pattern is repeated for the sdne[1:0] and sdnwe signals, which all belong to the SDRAM controller in the FMC. And according to this data set they seem to be unavailable for the LQFP100 package? Hm, better call Saul check the datasheets: Huh, but the signals do exist for the LQFP100 package!? “FMC: Yes(1)”. Oh, FFS! I checked with CubeMX and the GPIO configurator doesn’t allow you to set SDRAM signals in the LQFP100 package, and there are no STM32F4[23]7[BN] devices, so everything is fine, I guess? Nothing to see here folks, move along, the filter algorithm encoded this shit correctly. 🙃 Anyways, I like our device file format a lot, since it describes the device’s hardware in such a compact and concise form. However, it doesn’t scale graciously at all for data that shares less commonalities between devices in the current clusters. Data Pipeline For my rewrite of the DFG for modm I wanted to improve the correctness of device merges, remove device specific knowledge as much as possible, support multiple output formats and rename less data. I’ve already hinted at solutions to some of these in the previous chapters, so let’s have a proper look at them now. The DFG has three parts: frontend, optimizer and backend. Here yellow stands for input data, blue for data conversion, red for intermediate representation (IR) and green for output data. I’ve already covered the vendor input data and the device merging in much detail. All the ugly is in the parser, it reads the CubeMX data in the same manner I’ve described previously, performs plausibility and format checks on it, and finally normalizes it into a simple Python dictionary. This is just mostly mind-numbingly stupid code to write, since you have to XPath query the CubeMX sources, deal with all the edge cases in the results and normalize all data relative to all devices. Ugly to write, ugly to read, but it gets the job done. Additional curated data gets injected in this step too. The CubeMX data contains a hardware IP version, which seems to correlate loosely to the peripherals feature set, however, I didn’t find it very useful to distinguish between them. So instead I looked up how all peripherals work in the documentation and grouped them again manually. The device file driver/@type name comes from this data. For example, here we can see that the entire STM32 platform only has three different I2C hardware implementations, one of which only differs with the addition of a digital noise filter. &apos;i2c&apos;: [{ &apos;instances&apos;: &apos;*&apos;, &apos;groups&apos;: [ { # This hardware can go up to 1MHz (Fast Mode Plus) &apos;hardware&apos;: &apos;stm32-extended&apos;, &apos;features&apos;: [], &apos;devices&apos;: [{&apos;family&apos;: [&apos;f0&apos;, &apos;f3&apos;, &apos;f7&apos;]}] },{ &apos;hardware&apos;: &apos;stm32l4&apos;, &apos;features&apos;: [&apos;dnf&apos;], &apos;devices&apos;: [{&apos;family&apos;: [&apos;l4&apos;]}] },{ # Some F4 have a digital noise filter &apos;hardware&apos;: &apos;stm32&apos;, &apos;features&apos;: [&apos;dnf&apos;], &apos;devices&apos;: [{&apos;family&apos;: [&apos;f4&apos;], &apos;name&apos;: [&apos;27&apos;, &apos;29&apos;, &apos;37&apos;, &apos;39&apos;, &apos;46&apos;, &apos;69&apos;, &apos;79&apos;]}] },{ &apos;hardware&apos;: &apos;stm32&apos;, &apos;features&apos;: [], &apos;devices&apos;: &apos;*&apos; } ] }] All names of peripherals, instances, signals are preserved as they are, so that the name matches the documentation. The only exception are names that wouldn’t be valid identifiers in most programming languages. For our STM32F103RBT example, we split up and duplicate these system signals: SYS_JTCK-SWCLK =&amp;gt; sys.jtck + sys.swclk SYS_JTDO-TRACESWO =&amp;gt; sys.jtdo + sys.traceswo SYS_JTMS-SWDIO =&amp;gt; sys.jtms + sys.swdio The dictionary returned by the parser is then passed onto a platform specific converter that transforms it into the DFGs intermediate representation. Here the raw data is formatted into a glorified tree structure, which has similar semantics to a very restricted form of XML (ie. attributes are stored separately from its children) and annotates each node with the device’s identifier. Here the memory maps and the interrupt vector table is added to the name=&quot;core&quot; driver node we saw before. The raw data already contains the memories and vectors with the right naming scheme, so it’s easy to just add them here. for section in p[&quot;memories&quot;]: memory_node = core_driver.addChild(&quot;memory&quot;) memory_node.setAttributes([&quot;name&quot;, &quot;access&quot;, &quot;start&quot;, &quot;size&quot;], section) for vector in p[&quot;interrupts&quot;]: vector_node = core_driver.addChild(&quot;vector&quot;) vector_node.setAttributes([&quot;position&quot;, &quot;name&quot;], vector) # sort the node children by start address and size core_driver.addSortKey(lambda e: (int(e[&quot;start&quot;], 16), int(e[&quot;size&quot;])) if e.name == &quot;memory&quot; else (-1, -1)) # sort the node children by vector number and name core_driver.addSortKey(lambda e: (int(e[&quot;position&quot;]), e[&quot;name&quot;]) if e.name == &quot;vector&quot; else (-1, &quot;&quot;)) I’m adding two sort keys to the core driver node here, to bring the entire tree into canonical order. This an absolute requirement for the reproducibility of the results, otherwise I wouldn’t be able to tell what data changed if the line order came out differently on each invocation. It’s time to merge the device IRs now. The device clustering is curated manually, by a large list of identifier trait groups. I considered using some kind of heuristic to automate this, but this works really well, particularly for the AVR and STM32F1 devices. It’s difficult to come up with a metric that accurately describes how annoyed I feel when looking at wrongfully merged device files with lotsa noisy filters. 😤 The STM32F103 devices are split into these four groups: { &apos;family&apos;: [&apos;f1&apos;], &apos;name&apos;: [&apos;03&apos;], &apos;size&apos;: [&apos;4&apos;, &apos;6&apos;] },{ &apos;family&apos;: [&apos;f1&apos;], &apos;name&apos;: [&apos;03&apos;], &apos;size&apos;: [&apos;8&apos;, &apos;b&apos;] },{ &apos;family&apos;: [&apos;f1&apos;], &apos;name&apos;: [&apos;03&apos;], &apos;size&apos;: [&apos;c&apos;, &apos;d&apos;, &apos;e&apos;] },{ &apos;family&apos;: [&apos;f1&apos;], &apos;name&apos;: [&apos;03&apos;], &apos;size&apos;: [&apos;f&apos;, &apos;g&apos;] } In case you’re curious how bad it would be with just one large F103 group, here is a gist with the resulting device file. It’s not as bad as it could be, but still much harder to read. At this point the merged IR for our F103RBT device basically already looks like the finished device file, including identifier filters: device &amp;lt;&amp;gt; stm32f103[c|r|t|v][8|b][h|i|t|u] . driver &amp;lt;name:core type:cortex-m3&amp;gt; . memory &amp;lt;name:flash access:rx start:0x8000000 size:65536&amp;gt; stm32f103[c|r|t|v]8[h|t|u] . memory &amp;lt;name:flash access:rx start:0x8000000 size:131072&amp;gt; stm32f103[c|r|t|v]b[h|i|t|u] . memory &amp;lt;name:sram1 access:rwx start:0x20000000 size:20480&amp;gt; . vector &amp;lt;position:0 name:WWDG&amp;gt; ... . vector &amp;lt;position:42 name:USBWakeUp&amp;gt; . driver &amp;lt;name:i2c type:stm32&amp;gt; . instance &amp;lt;value:1&amp;gt; . instance &amp;lt;value:2&amp;gt; stm32f103[c|r|v][8|b][h|i|t|u] . driver &amp;lt;name:spi type:stm32&amp;gt; . instance &amp;lt;value:1&amp;gt; . instance &amp;lt;value:2&amp;gt; stm32f103[c|r|v][8|b][h|i|t|u] I’ve already described the device file format above, however, one additional testing step is done before the DFG is finished: A copy of every single device file is taken before merging, so that it can be compared with the device files that are extracted from this merged one. This is a brute-force test to make sure the filter algorithms did perform correctly. On a side note, the conversion from IR to device file format can be performed at any time, so that last merge step is strictly speaking optional. This is useful for debugging but also if you want to output this data in a format that does not support a merge mechanism similar to the device file’s one, like plain JSON. Using Device Files So now that we have all this data, let’s have some fun with it. modm-devices comes not only with the DFG but also with a device file parser, which can be used like this: &amp;gt;&amp;gt;&amp;gt; import modm.parser, glob &amp;gt;&amp;gt;&amp;gt; devices = {} &amp;gt;&amp;gt;&amp;gt; for filename in glob.glob(&quot;path/to/modm-devices/devices/**/*.xml&quot;): &amp;gt;&amp;gt;&amp;gt; for device in modm.parser.DeviceParser().parse(filename).get_devices(): &amp;gt;&amp;gt;&amp;gt; devices[device.partname] = device &amp;gt;&amp;gt;&amp;gt; devices[&quot;stm32f103rbt&quot;].properties {&apos;driver&apos;: [{&apos;memory&apos;: [{&apos;access&apos;: &apos;rx&apos;, &apos;name&apos;: &apos;flash&apos;, &apos;size&apos;: &apos;131072&apos;, &apos;start&apos;: &apos;0x8000000&apos;}, {&apos;access&apos;: &apos;rwx&apos;, &apos;name&apos;: &apos;sram1&apos;, &apos;size&apos;: &apos;20480&apos;, &apos;start&apos;: &apos;0x20000000&apos;}], &apos;name&apos;: &apos;core&apos;, &apos;type&apos;: &apos;cortex-m3&apos;, ... }] } There are some built-in convenience functions for accessing some of the common data in the device files: &amp;gt;&amp;gt;&amp;gt; device = devices[&quot;stm32f103rbt&quot;] &amp;gt;&amp;gt;&amp;gt; device.identifier OrderedDict([(&apos;platform&apos;, &apos;stm32&apos;), (&apos;family&apos;, &apos;f1&apos;), (&apos;name&apos;, &apos;03&apos;), (&apos;pin&apos;, &apos;r&apos;), (&apos;size&apos;, &apos;b&apos;), (&apos;package&apos;, &apos;t&apos;)]) &amp;gt;&amp;gt;&amp;gt; device.has_driver(&quot;usart:avr&quot;) False &amp;gt;&amp;gt;&amp;gt; device.has_driver(&quot;usart:stm32&quot;) True &amp;gt;&amp;gt;&amp;gt; device.get_driver(&quot;usart:stm32&quot;) {&apos;instance&apos;: [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;], &apos;name&apos;: &apos;usart&apos;, &apos;type&apos;: &apos;stm32&apos;} I’ve also written a short stats script that allows you to compute some very basic information about the device file collection: $ python3 tools/device/scripts/stats --count 1355 devices $ python3 tools/device/scripts/stats --driver { &quot;ac&quot;: 234, &quot;adc&quot;: 1339, &quot;aes&quot;: 133, &quot;awex&quot;: 26, &quot;bandgap&quot;: 8, &quot;battery_protection&quot;: 7, &quot;bdma&quot;: 20, &quot;bod&quot;: 30, &quot;can&quot;: 683, &quot;ccl&quot;: 30, &quot;cell_balancing&quot;: 5, &quot;cfd&quot;: 2, &quot;charger_detect&quot;: 4, &quot;clk&quot;: 45, &quot;clock&quot;: 242, &quot;comp&quot;: 577, &quot;core&quot;: 1355, ... } stats also allows you to dump expanded JSON for a prefix of devices and then query that with the tool of your choice to, for example, get all the I2C related signals on port B for the STM32F4 device family. Not sure why you’d want that, but it’s possible. $ python3 tools/device/scripts/stats --json stm32f4 | jq &apos;[.[] | .device.driver[] | select(.name == &quot;gpio&quot;).gpio[] | . as $gpio | .signal[]? | select(.driver == &quot;i2c&quot; and $gpio.port == &quot;b&quot;) | ($gpio.port + $gpio.pin + &quot;:&quot; + .name)] | unique&apos; [ &quot;b10:scl&quot;, &quot;b11:sda&quot;, &quot;b12:smba&quot;, &quot;b3:sda&quot;, &quot;b4:sda&quot;, &quot;b5:smba&quot;, &quot;b6:scl&quot;, &quot;b7:sda&quot;, &quot;b8:scl&quot;, &quot;b8:sda&quot;, &quot;b9:sda&quot; ] I’ll discuss in more detail how we use the device files in the next blog post about the modm library. Try it Yourself The device file as well as the DFG are available on GitHub for you to play with. It automatically downloads and extracts all the raw data into modm-devices/tools/generator/raw-device-data folder. git clone --recursive --depth=1 https://github.com/modm-io/modm-devices.git cd modm-devices/tools/generator # Extract and generate STM32 device data make extract-data-stm32 make generate-stm32 # Extract and generate AVR device data make extract-data-avr make generate-avr Not everything I described here is fully implemented, for example, the clock graph extractor is just a proof-of-concept for now. modm-devices is also supposed to be a Python package installable via pip, but that’s not implemented yet. Please help me maintain this project, I only used devices from a few STM32 families, so it’s difficult to judge the correctness of some of this data. If you know of any other machine readable data, please open an issue or preferrably a pull request. Two more device file checks are currently not implemented: a XML schema validation, and a semantical checker, that verifies the contents consistency. For example, every GPIO signal should be associable with a driver, and no signal name should start with a number (otherwise difficult to map into most programming languages). These are ideas for the future. With some effort and additional data sources (CMSIS-SVD files for example), directly outputting to Device Tree format should be possible too. I leave that one to the experts though. 😇 Conclusion It was important to use not to bind this data to any preconceptions of its use by, for example, integrating it tightly into our HAL generator. Instead we’ve very carefully separated modm-devices from our use of it, so that it can stand on its own and be integrated into all sorts of projects by the community. You’re not bound to using this in code either, you can also generate Markdown documentation, or maybe build your own GPIO configurator as a web UI. You can go and use it as is with its Python DeviceFile interface, however, for larger projects, I’d recommend you write your own wrapper class, that can format the data as you need it. The Device File format may change at any time, so that I can fit in new data or once I don’t like the format anymore, change it completely. So don’t depend on the format directly. The next few blog posts will be about applying this data in our own modm library, how CMSIS-SVD compares to CMSIS Headers as additional data sources, and what it means to model check your HAL with this data. On a Personal Note The last 5 years working on this have been quite a ride. It has completely changed my view on embedded software engineering and it took a while for me understand this different way of thinking. As far as I know, nobody has deployed hardware description methods on such a large and diverse device base. And we’re just getting started. I’ve been fortunate to have found similarly minded people in the RCA, who provided me with valuable feedback and thoughtful discussions, who mentored me and tolerated my rants about our robot’s code quality. The RCA is self organized, so we don’t have anyone telling us what to do, or how to do it. As a result, we do reinvent the wheel a lot, sometimes for worse, but mostly for the better, like with this project. During this time I’ve not had the best experience with the “professional” C/C++ embedded community. There are too many established developers convinced of their own opinions that won’t stop arguing until they’ve “won” (just ask about using C++ on µCs and bring some 🍿). Together with the growth in amateur interest in embedded software (absolutely not a bad thing), this completely drowned out any worthwhile online discussions on new approaches to embedded software that are different from the “approved” norm. I’m not talking so much about the programming language itself, which is relatively exchangeable for HALs (a rather unpopular opinion), but about HAL design concepts and perhaps most importantly, support tools. Let me give you an example: ST has committed at least 4-6 engineers to porting its devices to Arm Mbed OS. Good for ST, that’s a lot of money. But: ST only supports 55 of their ~1100 STM32 targets on Mbed OS, with every single one of them ported by hand. This means at least all startup code and linkerscripts are mostly duplicated for each target and all GPIO signal data is added manually by an unfortunate soul with all the side-effects of manual labor. That’s insane, as you’ve seen above, ST is already maintaining and using this data already to generate code with CubeMX. How is this not automated? (I dared to utter this simple observation about two years ago while working at Arm on Mbed OS and it turned out to be surprisingly unpopular. Touchy folks. 🙃) Fortunately, in the last few years there was some significant progress in enabling (new) programming languages on embedded, like MicroPython, Javascript runtimes and perhaps the most significant of them: Embedded in Rust. I’ve been particularly impressed with the progress of the community surrounding @japaricious, who are currently tackling some very hard issues, like IO signal grouping or safe DMA APIs. I’ve kinda written this blog post for them, since I think they are best organized to actually use it and they don’t seem afraid to tackle these issues. (Your move, C++ people!) Formatting of all data excerpts is possibly copyrighted by their respective owners and if so used here in fair use. However, the data itself are facts which cannot be copyrighted.</summary></entry><entry><title type="html">The Curious Case of xpcc’s Error Model</title><link href="http://blog.salkinium.com/xpccs-error-model/" rel="alternate" type="text/html" title="The Curious Case of xpcc’s Error Model" /><published>2017-03-04T00:00:00+01:00</published><updated>2017-03-04T00:00:00+01:00</updated><id>http://blog.salkinium.com/xpccs-error-model</id><content type="html" xml:base="http://blog.salkinium.com/xpccs-error-model/">&lt;p&gt;In hindsight it is quite apparent that &lt;a href=&quot;http://xpcc.io&quot;&gt;xpcc&lt;/a&gt; and therefore also the &lt;a href=&quot;https://twitter.com/RCA_eV&quot;&gt;@RCA_eV robot code&lt;/a&gt; was missing a good error model.
Until now xpcc’s way of dealing with failures included using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static_assert&lt;/code&gt; at compile time and returning error codes at runtime whenever it was deemed necessary. We never considered runtime assertions, nor catching hardware errors like the ARM Cortex-M Fault exceptions. We crashed and burned, a few times literally.&lt;/p&gt;

&lt;p&gt;So what can we do that is simple to use and efficient on AVR and Cortex-M devices, but still powerful enough to be useful? It’s time we thought about our error model.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update 2019: For &lt;a href=&quot;https://modm.io&quot;&gt;xpcc’s successor modm&lt;/a&gt; this error model got improved for efficiency and flexibility, however, the main principle is still the same. &lt;a href=&quot;https://modm.io/reference/module/modm-architecture-assert&quot;&gt;See the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modm:architecture:assert&lt;/code&gt; docs&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.roboterclub.rwth-aachen.de/&quot;&gt;The RCA robots&lt;/a&gt; are controlled by a number of software components that communicate by Remote Procedure Calls (PRCs) via an event loop locally or over CAN.
We call this Cross Platform Component Communication (XPCC) and it’s an under-appreciated (and under-documented) &lt;a href=&quot;http://xpcc.io/api/group__xpcc__comm.html&quot;&gt;part of the xpcc framework&lt;/a&gt;.
It allows us to distribute components over many microcontrollers if needed and helps us understand what is happening in the robot at runtime by listening in on the CAN bus.&lt;/p&gt;

&lt;p&gt;However, we are constantly fine tuning our robots before and after a match and if we accidentally leave the CAN bus disconnected the robot turns into a (very expensive) paper weight and we loose the game. It is therefore paramount that we detect this situation on CAN initialization and let the robot emit loud and annoying sounds so that the &lt;del&gt;slaves&lt;/del&gt; students can fix it. There are several other places in the initialization that must not fail for the same reason.&lt;/p&gt;

&lt;p&gt;It wasn’t clear to us how and where to handle this type of failure though. Should the initialization code return an error code? What if we forgot to check it? Isn’t this a recurring problem?
It seemed like a good opportunity to heartily consult The Internet™ on the topic of error models, since surely other, smarter people have solved this problem already. Oh boy.&lt;/p&gt;

&lt;h2 id=&quot;the-research&quot;&gt;The Research&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://joeduffyblog.com/2016/02/07/the-error-model/&quot;&gt;Joe Duffy wrote a fantastically detailed article on the many considerations that went into the error model used in the Midori research project&lt;/a&gt;. (You should read his &lt;a href=&quot;http://joeduffyblog.com/2015/11/03/blogging-about-midori/&quot;&gt;entire series on Midori&lt;/a&gt;, there is a lot of gold there.)&lt;/p&gt;

&lt;p&gt;There are couple of points in there that resonated very strongly with me:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://joeduffyblog.com/2016/02/07/the-error-model/#unchecked-exceptions&quot;&gt;“Unchecked Exceptions”&lt;/a&gt;: We can’t use C++ exceptions since the AVR toolchain does not support it. But even if we could, we wouldn’t, for the many reasons pointed out in this section. It’s actually quite horrifying to me how bad a match C++ exception are for a reliable system.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://joeduffyblog.com/2016/02/07/the-error-model/#to-build-a-reliable-system&quot;&gt;“To Build a Reliable System”&lt;/a&gt;: XPCC deals with failures prominently: RPC delivery can fail, components can decline RPCs (“I’m busy”) or simply fail during their execution (“I couldn’t grab this object”). We have to deal with these failures in order to get a reliable system that doesn’t get stuck on the first failure. You’d be surprised how many failures there can be during a Eurobot game under real world conditions. The fact that we can relatively simply retry actions or ultimately give up and move on is actually quite amazing.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://joeduffyblog.com/2016/02/07/the-error-model/#bugs-arent-recoverable-errors&quot;&gt;“Bugs Aren’t Recoverable Errors!”&lt;/a&gt;: This was the most important realization for me. When we are talking about the system clock or the CAN bus not initializing correctly, these are bugs. You cannot recover from them and the robot is stuck. However, XPCC failures as described above are recoverable errors and it’s fine for them to happen happen in normal operation.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://joeduffyblog.com/2016/02/07/the-error-model/#abandonment&quot;&gt;“Abandonment”&lt;/a&gt;: xpcc didn’t have a concept of abandonment and it doesn’t call any libc &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit()&lt;/code&gt; functions. There are a couple of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while(1)&lt;/code&gt; loops in the vector table (and hard fault handler), but there is no controlled teardown (with reporting) of failures. It’s crash’n’burn all the way down.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Of course Midori’s goal of writing an entire operating system from scratch is a little higher on the scale of epicness than us coding our robots. And considering that they rolled their own language and compiler to implement this error model, it’s pretty clear that our solution can’t really compete with their very thorough approach.&lt;/p&gt;

&lt;h2 id=&quot;the-proposal&quot;&gt;The Proposal&lt;/h2&gt;

&lt;p&gt;We propose to continue returning error codes for recoverable errors but use assertions for bugs which can lead to abandonment. There is something appealing about the simplicity of using an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assert(condition)&lt;/code&gt; in the code, so we decided to expand the function signature:&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;xpcc_assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Yes, we’re using C-style &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;strings&quot;&lt;/code&gt; to declare the assertion location and failure type instead of using enumerations or similar.
We came to the conclusion that it is a lot simpler to encode structured information using strings rather than keeping all error enumerations in sync to prevent duplicates.
Strings also consume significantly less memory than using a stringified test condition or a “pretty” function string, or even just &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__LINE__&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__FILE__&lt;/code&gt; strings. It also makes it trivial to print the failure.
It made sense to us that the developer writing code with assertions categorizes the failure for the developer calling the code. It’s often difficult to assess the exact reason &lt;em&gt;why&lt;/em&gt; an assertion failed from the stringified test condition alone.&lt;/p&gt;

&lt;p&gt;When an assertion fails, it calls all registered assertion handlers one by one.
Assertion handlers have this signature:&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Abondonment&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The identifiers allows these failure handlers to assess the scope and type of failure programmatically and return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fail&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DontCare&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ignore&lt;/code&gt;.
If any of them returns &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fail&lt;/code&gt; or all of them return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DontCare&lt;/code&gt;, then execution is abandoned. Otherwise if at least one of them &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ignore&lt;/code&gt; the assertion, execution continues.
This allows us to ignore some select failures that we don’t care about.&lt;/p&gt;

&lt;p&gt;The abandonment handler is called last and has the same signature as the assertion handler. It is required that all assertion handlers are not blocking, so that they can all get called, and whatever blocking code is required can then run in the abandonment handler, where execution is trapped until the next reset anyway.&lt;/p&gt;

&lt;h2 id=&quot;the-example&quot;&gt;The Example&lt;/h2&gt;

&lt;p&gt;For our problem with CAN bus timout, an assertion is called and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context&lt;/code&gt; contains the instance of the CAN (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt;) that failed initialization.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Can1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// [...] initialize CAN peripheral&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// wait for CAN bus to be ready&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deadlockPreventer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// max ~1ms&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;busIsReady&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deadlockPreventer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;xpcc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delayMicroseconds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;xpcc_assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deadlockPreventer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;can&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;init&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;timeout&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;An assertion handler then compares the first three characters to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;can&quot;&lt;/code&gt; and return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fail&lt;/code&gt; and execution is abandoned:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;xpcc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Abandonment&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;can_assertion_handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strncmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;can&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xpcc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Abandonment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xpcc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Abandonment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DontCare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Register assertion handler with system&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;XPCC_ASSERTION_HANDLER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;can_assertion_handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The abandon handler finally prints the failed assertion to the log and makes some loud bleepy noises:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;xpcc_abandon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;XPCC_LOG_ERROR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Assertion &apos;%s.%s.%s&apos; (0x%p) failed! Abandoning!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Make some noise!&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PiezoBuzzer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setOutput&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;PiezoBuzzer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;xpcc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delayMilliseconds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;PiezoBuzzer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;xpcc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delayMilliseconds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;On an STM32 this prints:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Assertion &apos;can.init.timeout&apos; (0x00000001) failed! Abandoning!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We also log internal robot state via UART backed by a ring buffer of fixed size. If too much is logged at once, the buffer runs out of space, and we loose log output, which is undesirable. However, we cannot wait synchronously for space to become available in the buffer either, as this would impair the timing loops in our robot code.
Since continuing the game is obviously more important than preserving the log, we therefore ignore this failure in game mode:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Abandonment&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;logger_buffer_overflow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strncmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;uart&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strncmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;tx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strncmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;overflow&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xpcc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Abandonment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ignore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xpcc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Abandonment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DontCare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Register assertion handler with system&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;XPCC_ASSERTION_HANDLER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;logger_buffer_overflow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note how the assertion handlers only react to the failures they care about and otherwise leaving the decision to other, potentially more specialized handlers.&lt;/p&gt;

&lt;h2 id=&quot;the-implementation&quot;&gt;The Implementation&lt;/h2&gt;

&lt;p&gt;Since we want to use assertions a lot in our code, but still keep the code size overhead as low as possible, we use two optimizations: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xpcc_assert&lt;/code&gt; is actually a macro which:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;moves the condition test out of the function into the calling context, and&lt;/li&gt;
  &lt;li&gt;concatenates the module, location and failure strings into one big string.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define xpcc_assert(condition, module, location, failure, context) \
    if (condition) {} else { \
        xpcc_assert_fail(FLASH_STORAGE(module &quot;\0&quot; location &quot;\0&quot; failure), (uintptr_t) context); }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We cannot change that the test condition has to always be evaluated, but we don’t have to pass it as an argument into the assert function. That would require the compiler to cast the test result into a numeric value and move it into a register to comply with the ABI. If we branch outside of the assertion, the compiler can test the CPU flags directly.&lt;/p&gt;

&lt;p&gt;Similarly, by concatenating the assertion identifier strings into one long string, the compiler only has to populate one register so it can save the code that fetches the other two pointers. (ARMv7-M use literal pools for constants, while AVRs generate them ad-hoc using several load instructions, both actually quite expensive for code size.) The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xpcc_assert_fail&lt;/code&gt; function then breaks the long string apart and passes them to the failure handlers as individual arguments.&lt;/p&gt;

&lt;p&gt;Also note the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FLASH_STORAGE&lt;/code&gt; macro, which keeps the strings in Flash on AVRs and thus does not use any SRAM as it would normally do. This means that assertion handlers on AVRs need to use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*_P&lt;/code&gt; variants of the string compare functions. This is an acceptable caveat for us, since assertion and abandon handlers are part of the application and not the library and there don’t need to be shared across platforms.&lt;/p&gt;

&lt;h3 id=&quot;registering-assertion-handlers&quot;&gt;Registering assertion handlers&lt;/h3&gt;

&lt;p&gt;The tricky part is how to register the assertion handlers to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xpcc_assert_fail&lt;/code&gt; function. We use the linker to collect all assertion handlers across the entire executable and place pointers to them into the same linker section using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XPCC_ASSERTION_HANDLER&lt;/code&gt; macro. Note how it forces the assertion handler to have the right signature by using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xpcc::AssertionHandler&lt;/code&gt; type:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define XPCC_ASSERTION_HANDLER(handler) \
    __attribute__((section(XPCC_ASSERTION_LINKER_SECTION), used)) \
    const xpcc::AssertionHandler \
    handler ## _assertion_handler_ptr = handler
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Adding custom linker sections to ARM Cortex-M devices is trivial, especially since xpcc generates the linkerscript from a central template. It’s literally just adding these lines:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ld&quot;&gt;.assertion : ALIGN(4)
{
    __assertion_table_start = .;
    KEEP(*(.assertion))
    __assertion_table_end = .;
} &amp;gt;FLASH
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xpcc_assert_fail&lt;/code&gt; which calls all assertion handlers is pretty simple. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xpcc_abandon&lt;/code&gt; here is a weak function that can be overwritten by the application:&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AssertionHandler&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__assertion_table_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AssertionHandler&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__assertion_table_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;xpcc_assert_fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;identifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// split up the identifier back into three pointers&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;identifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;failure&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// initialize with DontCare in case no assertion handlers were registered&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Abandonment&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Abandonment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DontCare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// call all assertion handlers&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;AssertionHandler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__assertion_table_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__assertion_table_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// abandon if all returned DontCare, or any returned&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Abandonment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DontCare&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;or&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Abandonment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;xpcc_abandon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This code is the same for Linux and OS X, except we need to adapt the section names, so that the dynamic linker can generate symbols for these custom sections at load time. The section names must not have a period in their name and the symbols follow a certain naming convention, all of which are different for these platforms:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;platform&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;section name&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;symbol names&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;AVR &lt;br /&gt; Cortex-M&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;.assertion&quot;&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__assertion_table_start&lt;/code&gt; &lt;br /&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__assertion_table_end&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;OS X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;__DATA,xpcc_assertion&quot;&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;section$start$__DATA$xpcc_assertion&quot;&lt;/code&gt;&lt;br /&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;section$end$__DATA$xpcc_assertion&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Linux&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;xpcc_assertion&quot;&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__start_xpcc_assertion&lt;/code&gt; &lt;br /&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__stop_xpcc_assertion&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;To access the symbols on OS X you need to bind them to their assembly name:&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AssertionHandler&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__assertion_table_start&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__asm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;section$start$__DATA$xpcc_assertion&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AssertionHandler&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__assertion_table_end&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__asm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;section$end$__DATA$xpcc_assertion&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3 Feb 2018 – Update:&lt;/strong&gt; We define some default assertion handlers inside the xpcc library source, which is first compiled into the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libxpcc.a&lt;/code&gt; archive, then linked against by the application. However, the linker by default only searches archives for &lt;em&gt;referenced&lt;/em&gt; symbols, which our handlers are obviously not, and therefore these handlers are omitted from the final executable. This can cause some very subtle and annoying bugs!&lt;/p&gt;

&lt;p&gt;The solution is to wrap the archive in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-Wl,--whole-archive -lxpcc -Wl,--no-whole-archive&lt;/code&gt;. The &lt;a href=&quot;https://sourceware.org/binutils/docs/ld/Options.html#Options&quot;&gt;GNU ld documentation&lt;/a&gt; describes this quite well: “For each archive mentioned on the command line after the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--whole-archive&lt;/code&gt; option, include every object file in the archive in the link, rather than searching the archive for the required object files.”&lt;/p&gt;

&lt;p&gt;Note that this just makes all symbols &lt;em&gt;visible&lt;/em&gt; to the linker, it does not force inclusion of all symbols, especially not if you pass the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--gc-sections&lt;/code&gt; option as well.&lt;/p&gt;

&lt;h4 id=&quot;avrs-are-annoying&quot;&gt;AVRs are annoying&lt;/h4&gt;

&lt;p&gt;The most pain was getting this to work on AVRs though. The issue is that their address space is limited to 16-bit and instructions and data are placed into physically separate memories each with their own 16-bit address space. Or in other words, &lt;a href=&quot;https://en.wikipedia.org/wiki/Harvard_architecture&quot;&gt;AVRs implement a Harvard architecture&lt;/a&gt; and one does not simply read data from the instruction memory on a Harvard architecture. AVRs load their read-only data from Flash to SRAM at boot time, &lt;em&gt;including all strings&lt;/em&gt;, since there is no way of telling from a 16-bit address whether it points to the instruction or the data memory. Hey, don’t look at me, it’s a 8-bit CPU, you get what you pay for!&lt;/p&gt;

&lt;p&gt;This does, however, mean that there now need to be two versions of the same section in memory. GNU ld deals with this by allowing to specify two addresses per section: &lt;a href=&quot;https://sourceware.org/binutils/docs/ld/Output-Section-LMA.html&quot;&gt;the virtual address (VMA) and the load address (LMA)&lt;/a&gt;.
For read-only data the LMA is in Flash somewhere, while the VMA is in SRAM and they are both &lt;em&gt;different&lt;/em&gt; memories even when the section addresses overlap numerically!&lt;/p&gt;

&lt;p&gt;Let me illustrate the problem with a simplified excerpt of the linkerscript itself.
You can see the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.data&lt;/code&gt; section is appended onto the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text&lt;/code&gt; memory after the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.text&lt;/code&gt; section (LMA), but placed into the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; memory too (VMA):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ld&quot;&gt;MEMORY
{
    text   (rx)   : ORIGIN = 0, LENGTH = 8k
    data   (rw!x) : ORIGIN = 0x800060, LENGTH = 0xffa0
}
/* everything in Flash */
.text :
{
    *(.progmem*) /* things tagged with `PROGMEM` go here! */
    *(.text*)    /* the actual code */
} &amp;gt; text
/* everything in SRAM */
.data :
{
    *(.data*)    /* modifiable data */
    *(.rodata*)  /* read-only data */
} &amp;gt; data AT&amp;gt; text
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is shown more obviously in the listing of the linked executable:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Sections:
Idx Name            Size      VMA       LMA       File off  Algn
  0 .text           00000850  00000000  00000000  000000b4  2**1
  1 .data           00000014  00800100  00000850  00000904  2**0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So what we need to do is simply™ append our section to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text&lt;/code&gt; memory after the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.data&lt;/code&gt; section, right? Well…
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;avr-gcc&lt;/code&gt; uses its own linkerscripts (which can be found in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;avr-binutils/avr/lib/ldscripts&lt;/code&gt;), so we cannot just add our custom section as we did for the ARM platform.
Fortunately, GNU ld allows to extend default linkerscript using the &lt;a href=&quot;https://sourceware.org/binutils/docs/ld/Miscellaneous-Commands.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INSERT [ AFTER | BEFORE ] output_section&lt;/code&gt; command&lt;/a&gt;.
We can pass this script to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;avr-ld&lt;/code&gt; via the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-T&lt;/code&gt; option:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SECTIONS
{
    .xpcc_assertion : ALIGN(2)
    {
        __assertion_table_start = .;
        KEEP(*(.assertion))
        __assertion_table_end = .;
    }
}
INSERT AFTER .data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This places the section exactly where we want it:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Sections:
Idx Name            Size      VMA       LMA       File off  Algn
  0 .text           00000850  00000000  00000000  000000b4  2**1
  1 .data           00000014  00800100  00000850  00000904  2**0
  2 .xpcc_assertion 00000006  00000864  00000864  00000918  2**1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The code for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xpcc_assert_fail&lt;/code&gt; also needs to be adapted for reading from Flash:&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// use *_P string functions from &amp;lt;avr/pgmspace.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;identifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strlen_P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;failure&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strlen_P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// we can&apos;t access the function pointer directly, cos it&apos;s not in RAM&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;AssertionHandler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__assertion_table_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__assertion_table_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table_addr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// first fetch the function pointer from flash, then jump to it&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;AssertionHandler&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AssertionHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pgm_read_word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;table_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Well, that was easy. This code works fine until the AVR &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.text + .data&lt;/code&gt; section size gets so large that it pushes the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.xpcc_assertion&lt;/code&gt; section above the 64kB address boundary (AVRs can have up to 128kB Flash, don’t ask /o\). Then &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;table_addr&lt;/code&gt; would wrap around and read garbage. For us this is an acceptable caveat. I mean, if you really get to &lt;em&gt;that&lt;/em&gt; point, you should sit down and ask yourself some hard questions about your life.&lt;/p&gt;

&lt;h2 id=&quot;the-evaluation&quot;&gt;The Evaluation&lt;/h2&gt;

&lt;p&gt;So what are the properties of our solution?&lt;/p&gt;

&lt;h3 id=&quot;overhead&quot;&gt;Overhead&lt;/h3&gt;

&lt;p&gt;Our assertions are a simple concept, with a very low overall code size overhead and when the assertion succeeds also low execution time penalty, even on AVRs.
There is obviously an unavoidable overhead for checking the test condition, safety doesn’t come for free.
But what is the code size penalty per assertion in the code? We’ll benchmark using this assertion:&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;xpcc_assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;can&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;init&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;timeout&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In AVRs, the assembly shows a simple condition check, a branch over for when the assertion passes, otherwise 4 loads and a call to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xpcc_assert_fail&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;2e4:   81 11       cpse r24, r1    ; condition check
2e6:   05 c0       rjmp .+10       ; branch over
2e8:   60 e0       ldi  r22, 0x01  ; context is 16-bit
2ea:   70 e0       ldi  r23, 0x00  ; constant and 1
2ec:   83 ea       ldi  r24, 0xA3  ; load ptr to progmem string
2ee:   90 e0       ldi  r25, 0x00  ; progmem below text, hence 0 here
2f0:   5d d1       rcall   .+698   ; call &amp;lt;xpcc_assert_fail&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On ARMv7-M the assembly is a little different. The simple condition check branches over if the assertion passes, otherwise &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mov&lt;/code&gt;es and loads the two arguments before loading and calling &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xpcc_assert_fail&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;80001ca:   f003 01ff and.w r1, r3, #255  ; condition check
80001cc:   b913      cbnz  r3, 80001d8   ; branch over
80001d0:   2100      movs  r1, #1        ; context is constant and 1
80001d2:   4803      ldr   r0, [pc, #12] ; load value @ 80001e0
80001d4:   4b03      ldr   r3, [pc, #12] ; load value @ 80001e4
80001d6:   4798      blx   r3            ; call &amp;lt;xpcc_assert_fail&amp;gt;
...                                      ; hey look, a literal pool
80001e0:   08000d8c  .word   0x08000d8c  ; pointer to string
80001e4:   08000521  .word   0x08000521  ; pointer to function
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The minimal code overheads per assertion call are 14B on AVR and 20B on ARMv7-M, but depending on the complexity of the test condition, more code can be generated.
However, if an assertion fails a time penalty exists: All assertion handlers will be called always. Furthermore everything executes on the currently active stack, maybe we’ll change that in the future.&lt;/p&gt;

&lt;h3 id=&quot;atomicity&quot;&gt;Atomicity&lt;/h3&gt;

&lt;p&gt;A failed assert disables interrupts since its implementation is not reentrant!
Also keep in mind that our ARMv7-M HardFault handler also eventually calls &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xpcc_assert_fail&lt;/code&gt; and due to its hardcoded priority, it cannot be interrupted anyway. So it’s best to always have the same behavior everywhere.&lt;/p&gt;

&lt;p&gt;The abandon handler may choose to re-enable interrupts if required, for example to allow the UART driver to print the failure reason.
Furthermore if mission critical systems need to continue running, then the abandon handler can keep them alive. For us this would include maybe putting the robot in a mechanically safe configuration before shutting down the motor drivers.&lt;/p&gt;

&lt;h3 id=&quot;nesting&quot;&gt;Nesting&lt;/h3&gt;

&lt;p&gt;Failing an assertion while already handling a failed assertion is not allowed and leads to an immediate termination (aka. an infinte loop). This can happen quicker than you think. Remember the abandon handler printing the failure over UART? What if the failure is the UART buffer overflowing? Yeah, that.&lt;/p&gt;

&lt;h3 id=&quot;documentation&quot;&gt;Documentation&lt;/h3&gt;

&lt;p&gt;There is no way of knowing if the function you’re calling can fail an assert, except from documentation. This can be a big issue, especially when inadvertently failing assertions from inside an interrupt context, which would call all assertion handlers and the abandon handler from this context too.&lt;/p&gt;

&lt;p&gt;This is a difficult problem to fix in general, but it doesn’t need to be solved perfectly: The application could be compiled in “assertion debug mode” where every assertion calls an “awareness” handler regardless of the test condition. This could also help with profiling assertion usage.&lt;/p&gt;

&lt;h3 id=&quot;ignoring-assertions&quot;&gt;Ignoring Assertions&lt;/h3&gt;

&lt;p&gt;It is a bit weird that contrary to C++ exceptions, the caller cannot handle the assertion directly at the call site, but only globally.
We tried to make it easier by allowing declarations of global assertion handlers anywhere, so that they can at least be declared closer to the call site.
But if you ignore an assertion, execution will continue, and there is no way to let the caller know that an assertion occurred, except to set a flag in shared memory:&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;assertion_failed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Abandonment&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ignore_uart_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uintptr_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strncmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;uart&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;assertion_failed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xpcc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Abandonment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ignore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xpcc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Abandonment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DontCare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;XPCC_ASSERTION_HANDLER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ignore_uart_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;caller_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;call_function_with_assertion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;assertion_failed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;assertion_failed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// do something else&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Admittedly, this is an edge case and the vast amount of assertion failures cannot be ignored, as there is nothing the caller can do and abandonment is exactly the right choice.&lt;/p&gt;

&lt;h3 id=&quot;abandonment-causes&quot;&gt;Abandonment Causes&lt;/h3&gt;

&lt;p&gt;As food for thought, here are the causes of abandonment in Midori and the possible implementations in xpcc. Note that AVRs don’t have fault handlers, they just quietly choke on their bits until they die in a plume of blue smoke.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;bug description&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;xpcc implementation&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;An incorrect cast&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;undetectable at runtime&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;An attempt to dereference a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt; pointer&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Hard Fault or unpredictable (AVR)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;An attempt to access an array outside of its bounds&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;detectable only with wrapper code&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Divide-by-zero&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Hard Fault or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xpcc_assert&lt;/code&gt; (software)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;An unintended mathematical over/underflow&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;detectable only with wrapper code&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Out-of-memory&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xpcc_assert&lt;/code&gt; in dynamic allocator&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Stack overflow&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Hard Fault or undetectable (AVR)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Explicit abandonment&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xpcc_assert(false, ...)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Contract failures&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;not a part of C/C++ (sadly)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Assertion failures&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;uh, well, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xpcc_assert&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;the-conclusion&quot;&gt;The Conclusion&lt;/h2&gt;

&lt;p&gt;Our solution isn’t anywhere near as polished and well thought out as Midori’s, but considering our restrictions it’s not completely terrible.
I would claim that it works for enough of our use cases to be useful and it allows for a lot of flexibility in responding to failed assertions.
Our approach of encoding the failure as a string is novel in the context of microcontrollers and is very efficient too.&lt;/p&gt;

&lt;p&gt;We see this as a good enough alternative to C++ exceptions and will be using it a lot in xpcc.&lt;/p&gt;</content><author><name>Niklas Hauser</name><email>niklas@salkinium.com</email></author><summary type="html">In hindsight it is quite apparent that xpcc and therefore also the @RCA_eV robot code was missing a good error model. Until now xpcc’s way of dealing with failures included using static_assert at compile time and returning error codes at runtime whenever it was deemed necessary. We never considered runtime assertions, nor catching hardware errors like the ARM Cortex-M Fault exceptions. We crashed and burned, a few times literally. So what can we do that is simple to use and efficient on AVR and Cortex-M devices, but still powerful enough to be useful? It’s time we thought about our error model. Update 2019: For xpcc’s successor modm this error model got improved for efficiency and flexibility, however, the main principle is still the same. See the modm:architecture:assert docs.</summary></entry><entry><title type="html">Computing and Asserting Baudrate Settings at Compile Time</title><link href="http://blog.salkinium.com/computing-baudrates-at-compile-time/" rel="alternate" type="text/html" title="Computing and Asserting Baudrate Settings at Compile Time" /><published>2015-06-08T00:00:00+02:00</published><updated>2015-06-08T00:00:00+02:00</updated><id>http://blog.salkinium.com/computing-baudrates-at-compile-time</id><content type="html" xml:base="http://blog.salkinium.com/computing-baudrates-at-compile-time/">&lt;p&gt;Prescaler and baudrate calculations are a tricky topic.
I have had many situations where the baudrate turned out to be off by a couple of percent, which was enough to render my serial output streams unreadable.
Sure, calculating the baudrate error beforehand would have saved me some hours of useless debugging, however, that would require understanding the often complicated mathematical formula hidden somewhere in the depths of the datasheet describing the prescaler vs. baudrate relationship.&lt;/p&gt;

&lt;p&gt;And &lt;em&gt;that&lt;/em&gt; seemed to be more work than just using a logic analyzer to measure the resulting error.
Of course, this felt like using a sledgehammer to crack a nut and it was neither a fast nor practical solution.&lt;/p&gt;

&lt;p&gt;I think there exists a better solution and I think it can be done using pure C++.
This solution needs to be able to:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;compute the best possible prescaler settings for the desired baudrate, and&lt;/li&gt;
  &lt;li&gt;notify me when the desired baudrate cannot be achieved without unresonable error.&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;qualifying-baudrates&quot;&gt;Qualifying Baudrates&lt;/h2&gt;

&lt;p&gt;An important characteristic of clock prescalers is their finite range and resolution, which has an obvious impact on baudrate generation.&lt;/p&gt;

&lt;p&gt;Let’s look at the characteristics of the three most commonly used prescalers:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;the power-of-two prescaler,&lt;/li&gt;
  &lt;li&gt;the linear prescaler, and&lt;/li&gt;
  &lt;li&gt;the fractional prescaler.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;power-of-two&quot;&gt;Power of Two&lt;/h4&gt;

&lt;p&gt;This type of prescaler is often used to clock peripherals which do not require a high resolution and can operate in a wide range of frequencies such as ADCs and even SPI.
It’s behaviour is described by this formula:&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;prescaler_power_of_two.svg&quot; /&gt;&lt;/p&gt;
&lt;/center&gt;

&lt;h4 id=&quot;linear&quot;&gt;Linear&lt;/h4&gt;

&lt;p&gt;Linear prescalers are the most common type of prescaler found in microcontrollers. They typically generate clocks for timers and synchonous communication peripherals such as I&lt;sup&gt;2&lt;/sup&gt;C and SPI.
Since the divisor must not be zero for obvious reasons, the input values are either mapped so that writing a zero turns the peripheral off, or the hardware adds a one to the input (mapping 0⟶1, 1⟶2, etc…).&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;prescaler_linear.svg&quot; /&gt;&lt;/p&gt;
&lt;/center&gt;

&lt;h4 id=&quot;fractional&quot;&gt;Fractional&lt;/h4&gt;

&lt;p&gt;This prescaler is used whenever a clock is required, which cannot be generated purely by integer division. The most typical application is baudrate generation for asynchronous communication such as UART.
The divisor is usually formatted as a fixed point binary fractional.
It must be understood that these prescalers cannot generate a &lt;em&gt;true&lt;/em&gt; fractional output frequency, but use a &lt;a href=&quot;http://en.wikipedia.org/wiki/Dual-modulus_prescaler&quot;&gt;dual-modulus hardware logic&lt;/a&gt;, so that the desired output frequency is met &lt;strong&gt;on average&lt;/strong&gt;!&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;prescaler_fractional.svg&quot; /&gt;&lt;/p&gt;
&lt;/center&gt;

&lt;h4 id=&quot;analysis&quot;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;Here is the graphical comparison of these three prescaler functions, plotting 10 input values onto the normalized output value for all three functions. The power-of-two prescaler is light gray, the linear prescaler dark gray and is overlaid on the fractional prescaler:&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;prescaler_graphs.svg&quot; /&gt;&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;There are three very interesting observations to be made:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;the power-of-two prescaler falls a lot faster than the others: In 10 steps it reaches &lt;sup&gt;1&lt;/sup&gt;/&lt;sub&gt;1024&lt;/sub&gt; instead of &lt;sup&gt;1&lt;/sup&gt;/&lt;sub&gt;10&lt;/sub&gt; for the linear prescaler.&lt;/li&gt;
  &lt;li&gt;neither the power-of-two nor the linear prescaler can generate anything between 1.0 and 0.5.&lt;/li&gt;
  &lt;li&gt;the distribution of generatable output frequencies is (obviously) not evenly spaced.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All prescalers are not particularly suited to generate high arbitrary output frequencies.
This also goes for the fractional prescaler, which can only switch between two fixed frequencies.&lt;/p&gt;

&lt;p&gt;Assume you have a SPI slave that can be clocked up to 30 MHz, however your primary clock input is 40 MHz.
A fractional prescaler will clock the slave half the time with 40 MHz and the other half with 20 MHz to achieve the desired 30 MHz on average.
However, the slave might start to glitch on the 40 MHz part of the clocking, due to its electrical and timing characteristics, therefore this is not a practical solution.&lt;/p&gt;

&lt;h2 id=&quot;choosing-divisors&quot;&gt;Choosing Divisors&lt;/h2&gt;

&lt;p&gt;So now that we know the formulas and properties of the most common prescalers, let’s find out how we can choose the best divisor for a desired baudrate.&lt;/p&gt;

&lt;p&gt;Between two generatable baudrates &lt;em&gt;B&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt; and &lt;em&gt;B&lt;sub&gt;n+1&lt;/sub&gt;&lt;/em&gt; lies a half-point for which there is an equal amount of baudrate error when choosing either &lt;em&gt;n&lt;/em&gt; or &lt;em&gt;n+1&lt;/em&gt; as a divisor.
The formula for calculating this half-point is trivial:&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;prescaler_half_point.svg&quot; /&gt;&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;So the general approach here is to find an divisor pair (&lt;em&gt;n, n+1&lt;/em&gt;) so that the desired baudrate &lt;em&gt;B&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; lies between &lt;em&gt;B&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt; and &lt;em&gt;B&lt;sub&gt;n+1&lt;/sub&gt;&lt;/em&gt; and then choose the divisor whose baudrate is closer to the desired one.
So if &lt;em&gt;B&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; is above the half-point, we choose &lt;em&gt;n&lt;/em&gt;, otherwise &lt;em&gt;n+1&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;It is important to understand that we &lt;strong&gt;cannot&lt;/strong&gt; use this approach on the divisors directly, since there is no linear correlation between the input and output frequency.
This becomes clear in the prescaler plot above, where the half-point between 1.0 and 0.5 for the linear prescaler clearly does not lie on divisor 1.5, but somewhere around 1.3!&lt;/p&gt;

&lt;h4 id=&quot;power-of-two-1&quot;&gt;Power of Two&lt;/h4&gt;

&lt;p&gt;However, with some more math we can calculate the exact divisor &lt;em&gt;ratio&lt;/em&gt; of this half-point.
We start with the power-of-two prescaler, where &lt;em&gt;B&lt;sub&gt;n+1&lt;/sub&gt;&lt;/em&gt; is always half of &lt;em&gt;B&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt;:&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;prescaler_p2_1.svg&quot; /&gt;&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;By entering these into our half-point formula we get:&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;prescaler_p2_2.svg&quot; /&gt;&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;However, since we wanted a divisor and not a baudrate, we divide the input frequency with the half-point baudrate:&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;prescaler_p2_3.svg&quot; /&gt;&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;Choosing the divisor with the least error for any desired baudrate becomes easy now.
Here is a code example (taken from the &lt;a href=&quot;https://github.com/roboterclubaachen/xpcc/blob/develop/src/xpcc/architecture/platform/driver/spi/at90_tiny_mega/spi_master.hpp.in?ts=4#L69&quot;&gt;AVR’s SPI module&lt;/a&gt;):&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;desired_div&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input_frequency&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;desired_baudrate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nearest_div&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;desired_div&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;4.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;desired_div&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;4.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;desired_div&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;4.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;desired_div&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;4.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;desired_div&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;4.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;   &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;desired_div&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;4.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;   &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
									   &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;))))));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;First the divisor of the input frequency and the desired baudrate is computed.
This divisor is then compared with all half-point divisors of our prescaler and the best value is chosen.&lt;/p&gt;

&lt;p&gt;Notice how this algorithm will choose a divisor of 128 when the desired baudrate is too slow, and a divisor of 2 when it is too fast.
This mirrors the range limitation of the AVR’s SPI prescaler!&lt;/p&gt;

&lt;h4 id=&quot;linear-1&quot;&gt;Linear&lt;/h4&gt;

&lt;p&gt;Unfortunately this elegant solution is not available for the properties of the linear prescaler.
Here &lt;em&gt;B&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt; and &lt;em&gt;B&lt;sub&gt;n+1&lt;/sub&gt;&lt;/em&gt; are defined as follows:&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;prescaler_lin_1.svg&quot; /&gt;&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;Using these definition in our half-point formula gets us nowhere really:&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;prescaler_lin_2.svg&quot; /&gt;&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;And the half-point divisor is just insulting:&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;prescaler_lin_3.svg&quot; /&gt;&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;However, a quick look at the value table of this formula does reinforce a suspicion:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;em&gt;n&lt;/em&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;em&gt;d&lt;sub&gt;half(n)&lt;/sub&gt;&lt;/em&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;approx.&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4/3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1.33333&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12/5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2.40000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;24/7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.42857&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;40/9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4.44444&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;60/11&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5.45455&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;84/13&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6.46154&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;112/15&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7.46667&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;144/17&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8.47059&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;180/19&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9.47368&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The divisors seem to approach &lt;em&gt;(n + 1/2)&lt;/em&gt; for larger values, which is indeed the case and becomes clear when looking at the series expansion for &lt;em&gt;n&lt;/em&gt; to infinity:&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;prescaler_lin_4.svg&quot; /&gt;&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;Not that this is of any help to us, it’s just nice to know ☺&lt;/p&gt;

&lt;h4 id=&quot;fractional-1&quot;&gt;Fractional&lt;/h4&gt;

&lt;p&gt;Just… no. It doesn’t get better.&lt;/p&gt;

&lt;h4 id=&quot;generic&quot;&gt;Generic&lt;/h4&gt;

&lt;p&gt;Okay, so even after this small binge into the underlying mathematics we still do not know how to choose a divisor for linear and fractional prescalers.&lt;/p&gt;

&lt;p&gt;There is of course a generic solution where we just brute force this:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;compute the desired divisor for the desired baudrate,&lt;/li&gt;
  &lt;li&gt;get &lt;em&gt;n&lt;/em&gt; and &lt;em&gt;n+1&lt;/em&gt; using &lt;em&gt;floor(desired_div)&lt;/em&gt; and &lt;em&gt;ceil(desired_div)&lt;/em&gt;,&lt;/li&gt;
  &lt;li&gt;compute the according baudrates &lt;em&gt;B&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt; and &lt;em&gt;B&lt;sub&gt;n+1&lt;/sub&gt;&lt;/em&gt;,&lt;/li&gt;
  &lt;li&gt;compare with the half-point baudrate and choose accordingly.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here is a code example of this algorithm (taken from the &lt;a href=&quot;https://github.com/roboterclubaachen/xpcc/blob/develop/src/xpcc/architecture/platform/driver/uart/at90_tiny_mega/uart.hpp.in?ts=4#L66&quot;&gt;AVR’s UART module&lt;/a&gt;):&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// calculate the fractional prescaler value&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;desired&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input_frequency&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;desired_baudrate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// respect the prescaler range of 1 to 4096&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;div_floor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;floor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;desired&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;floor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;desired&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;div_ceil&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ceil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;desired&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4096&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4096&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ceil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;desired&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// calculate the baudrates above and below the requested baudrate&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baud_lower&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input_frequency&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;div_ceil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baud_upper&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input_frequency&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;div_floor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// calculate the half-point between the upper and lower baudrate&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baud_middle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;baud_upper&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baud_lower&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// decide which divisor is closer to a possible baudrate&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// lower baudrate means higher divisor!&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nearest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;baudrate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baud_middle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;div_ceil&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;div_floor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// map to correct range (0 is 1, 1 is 2, etc…)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prescaler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nearest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This algorithm can be adapted to work with non-continuous ranges (as in &lt;em&gt;2&lt;sup&gt;n&lt;/sup&gt;&lt;/em&gt; for the power-of-two prescaler) and also with fractional prescaler using binary scaling.&lt;/p&gt;

&lt;h2 id=&quot;choosing-tolerances&quot;&gt;Choosing Tolerances&lt;/h2&gt;

&lt;p&gt;Although these algorithms will choose the divisor with the least baudrate error, we want to have some form of control over &lt;em&gt;how much&lt;/em&gt; error is still acceptable.&lt;/p&gt;

&lt;p&gt;We are only looking at relative error which is defined as:&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;prescaler_relative_error.svg&quot; /&gt;&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;A set of default tolerances should be chosen so that without any effort required from the programmer, they act as a useful guard against unreasonable baudrate errors.
So, how much error is still acceptable?&lt;/p&gt;

&lt;p&gt;For internal peripherals like ADCs, which usually have a power-of-two prescaler and can operate in a wide range of frequencies, we chose a ±10% default tolerance.&lt;/p&gt;

&lt;p&gt;For synchronous protocols such as SPI and I&lt;sup&gt;2&lt;/sup&gt;C, the master clocks the bus and the exact baudrate does not really matter.
Of course, when operating the aforementioned SPI slave at 30 MHz you want to be reasonably certain that you aren’t clocking it at 35 MHz, which causes it to glitch.
So for xpcc we chose a ±5% default tolerance.&lt;/p&gt;

&lt;p&gt;However, asynchronous protocols simply do not allow for much tolerance.
The relative baudrate error tolerance for UART with 8N1 configuration (8 databits, 1 startbit and 1 stopbit) as shown below is only ±5%. The sample point of the stop bit may only shift by at most ±&lt;em&gt;t&lt;sub&gt;Symbol&lt;/sub&gt; /2&lt;/em&gt; and with 10 bits to read, one &lt;em&gt;t&lt;sub&gt;Symbol&lt;/sub&gt;&lt;/em&gt; equals one tenth of the symbol transmission time, hence a relative tolerance of ±5%. For example, the tolerance for 7-bit transfers (9 baudtimes) increases to ±5.56%.&lt;/p&gt;

&lt;center&gt;
  &lt;p&gt;&lt;img invertible=&quot;&quot; src=&quot;prescaler_uart.svg&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;However, since both transmitter and receiver may not generate the exact baudrate, the error must not exceed &lt;strong&gt;±5% in total&lt;/strong&gt;, which in the worst case (one too fast, one too slow) imposes a tight allowed deviation of +2.5% and -2.5% on the modules respectively.
In xpcc we therefore chose ±2% default tolerance for linear prescalers and ±1% for fractional prescalers.&lt;/p&gt;

&lt;p&gt;If a generated baudrate is found to be outside of the default tolerance, this information must be conveyed to the programmer!
Of course, (s)he must able to overwrite the default tolerances to make them more or less restrictive, depending on the application.&lt;/p&gt;

&lt;h2 id=&quot;at-compile-time&quot;&gt;At Compile Time&lt;/h2&gt;

&lt;p&gt;Now, we could slack off and just implement all this at runtime.
There are a couple of issues with this on a microcontroller:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It’s simply inefficient: How often do you set your baudrates? Once?&lt;/li&gt;
  &lt;li&gt;How do you communicate to the programmer that your generated baudrate is above your declared tolerance? Serial output?&lt;/li&gt;
  &lt;li&gt;What is the runtime supposed to do with a test failure? Automatically switch to another baudrate?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Especially on AVRs the computational toll of using floating point and 32bit values to compute a one-time value is quite immense.
Even if you have multiple baudrates that you need to switch to at runtime, it is cheaper in both storage and execution time to use a lookup table!&lt;/p&gt;

&lt;p&gt;However, the second and third points are the real culprit.
It would be plain stupid to even attempt to output an error string over UART that the generated (UART) baudrate is outside of the declared tolerance.
Automatically switching to another baudrate is even more stupid, as this defies the purpose of having chosen a particular baudrate.&lt;/p&gt;

&lt;p&gt;No, this is a problem that can and must be solved at compile time.
Fortunately with C++11 is has become possible to use constexpr functions and static assertions, which make compile-time computation and communication a lot easier.&lt;/p&gt;

&lt;h4 id=&quot;implementation&quot;&gt;Implementation&lt;/h4&gt;

&lt;p&gt;Here is the full compile-time implementation of the AVR’s SPI initialize method:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * Initializes the hardware and sets the baudrate.
 *
 * @tparam	SystemClock
 * 		the currently active system clock
 * @tparam	baudrate
 * 		the desired baudrate in Hz
 * @tparam	tolerance
 * 		the allowed relative tolerance for the resulting baudrate
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SystemClock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baudrate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;uint16_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tolerance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tolerance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FivePercent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// calculate the nearest prescaler from the baudrate&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;desired&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SystemClock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Spi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baudrate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nearest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nearest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;4.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nearest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;4.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nearest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;4.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nearest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;4.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nearest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;4.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;   &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nearest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;4.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;   &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
										   &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;))))));&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// check if we found a prescaler which generates&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// a baudrate within the declared tolerance&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;assertBaudrateInTolerance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;SystemClock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Spi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nearest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// available baudrate&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;baudrate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;					&lt;span class=&quot;c1&quot;&gt;// desired baudrate&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;tolerance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;				&lt;span class=&quot;c1&quot;&gt;// allowed tolerance&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// translate the prescaler into the bitmapping&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Prescaler&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prescaler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nearest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Prescaler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Div128&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nearest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Prescaler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Div64&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nearest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Prescaler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Div32&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nearest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Prescaler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Div16&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nearest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;   &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Prescaler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Div8&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nearest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;   &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Prescaler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Div4&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
							   &lt;span class=&quot;n&quot;&gt;Prescaler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Div2&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;))))));&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// do the actual initialization at runtime&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prescaler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The primary algorithm has already been described before.
What’s new is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SystemClock&lt;/code&gt; which is a static class that contains the current clock tree configuration (also computed at compile time using similar methods).
On the AVR this contains the compile-time constant &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SystemClock::Spi&lt;/code&gt; with the input clock frequency of the SPI peripheral.
This unburdens the programmer to know from which clock domain the peripheral is clocked.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assertBaudrateInTolerance&lt;/code&gt; is given &lt;em&gt;B&lt;sub&gt;available&lt;/sub&gt;&lt;/em&gt;, &lt;em&gt;B&lt;sub&gt;desired&lt;/sub&gt;&lt;/em&gt; and the allowed tolerance and raises a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static_assert&lt;/code&gt; if the test fails.
The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nearest&lt;/code&gt; divisor is then mapped onto the register bit representation and this is then used to initialize the prescaler and peripheral.&lt;/p&gt;

&lt;p&gt;And all of this happens at compile-time, the runtime only knows one 8bit program-space constant and simply copies it into the prescaler register.&lt;/p&gt;

&lt;h4 id=&quot;usage&quot;&gt;Usage&lt;/h4&gt;

&lt;p&gt;All the programmer has to write is this:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Spi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;systemClock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MHz8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// with ±5% tolerance&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Should you want to change the SPI baudrate at runtime, you can do that simply by re-initializing with a different baudrate:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 4.4 MHz with explicit ±10% tolerance&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Spi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;systemClock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4400000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xpcc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Tolerance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TenPercent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Changing prescaler values often requires the peripheral to be switched off and then restarted.
Calling the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;initialize&lt;/code&gt; method again guarantees correct operation.
The overhead of this is only the loading of the compile-time constant which contains the prescaler value for 4 MHz and a call to the real initialize method of the peripheral.&lt;/p&gt;

&lt;p&gt;If you have several baudrates that you need to choose at runtime, a switch-case “lookup table” is still more efficient than a computation at runtime (while guaranteeing tolerance compliance):&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;baudrate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Spi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;systemClock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MHz8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Spi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;systemClock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MHz4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Spi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;systemClock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MHz2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Spi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;systemClock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MHz1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It is apparent that the usage is incredibly simple.&lt;/p&gt;

&lt;h4 id=&quot;on-failures&quot;&gt;On Failures&lt;/h4&gt;

&lt;p&gt;Should the tolerance check fail, then the compiler will show you the baudrate it computed.
Unfortunately the output is relatively unreadable, since there are templates involved. However, it’s still better than nothing, so stop complaining.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Here I want *exactly* 115.2kBaud! No problem.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Uart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;systemClock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;115200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xpcc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Tolerance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exact&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Compiling the above example on an AVR clocked with 16MHz will lead to a static assertion failure, since the desired baudrate of 115.2kBaud cannot be generated:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface.hpp: In instantiation of &apos;static void xpcc::Peripheral::assertBaudrateInTolerance() [with long unsigned int available = 111111ul; long unsigned int requested = 115200ul; unsigned int tolerance = 0u]&apos;:
...
interface.hpp:94:3: error: static assertion failed: The closest available baudrate exceeds the tolerance of the requested baudrate!
   static_assert(xpcc::Tolerance::isValueInTolerance(requested, available, tolerance),
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can see that the closest available baudrate seems to be 111.1kBaud which has a full 3.5% relative error, which would not even have been allowed with the default tolerance.&lt;/p&gt;

&lt;p&gt;Now you can just start trying different baudrates, for example 38.4kBaud, which has almost no error with the actual baudrate being 38.461kBaud.
Piece a cake, am I right?&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;Apart from the technical elegance of computing these values at compile-time, there is a real improvement in the programmer’s experience of using prescalers:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;You are declaring &lt;strong&gt;what&lt;/strong&gt; you want, not &lt;strong&gt;how&lt;/strong&gt; to get it.&lt;/li&gt;
  &lt;li&gt;You can now specify and enforce baudrate &lt;em&gt;quality&lt;/em&gt; directly in your code.&lt;/li&gt;
  &lt;li&gt;There is no need to read the datasheet anymore, trial and error suffices.&lt;/li&gt;
  &lt;li&gt;The compiler can give you an alternative baudrate with &lt;em&gt;zero&lt;/em&gt; error!&lt;/li&gt;
  &lt;li&gt;Your code is your documentation, since tolerance compliance is enforced.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Of course, the framework developers now have to do the grunt work of understanding how the prescaler works and implement the algorithms accordingly.
However, the reward outweighs the effort many times over, and might save you a lot of time not having to debug your prescaler calculations.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;This post was first published at blog.xpcc.io.&lt;/em&gt;&lt;/p&gt;</content><author><name>Niklas Hauser</name><email>niklas@salkinium.com</email></author><summary type="html">Prescaler and baudrate calculations are a tricky topic. I have had many situations where the baudrate turned out to be off by a couple of percent, which was enough to render my serial output streams unreadable. Sure, calculating the baudrate error beforehand would have saved me some hours of useless debugging, however, that would require understanding the often complicated mathematical formula hidden somewhere in the depths of the datasheet describing the prescaler vs. baudrate relationship. And that seemed to be more work than just using a logic analyzer to measure the resulting error. Of course, this felt like using a sledgehammer to crack a nut and it was neither a fast nor practical solution. I think there exists a better solution and I think it can be done using pure C++. This solution needs to be able to: compute the best possible prescaler settings for the desired baudrate, and notify me when the desired baudrate cannot be achieved without unresonable error.</summary></entry><entry><title type="html">Typesafe Register Access in C++</title><link href="http://blog.salkinium.com/typesafe-register-access-in-c++/" rel="alternate" type="text/html" title="Typesafe Register Access in C++" /><published>2015-02-25T00:00:00+01:00</published><updated>2015-02-25T00:00:00+01:00</updated><id>http://blog.salkinium.com/typesafe-register-access-in-c++</id><content type="html" xml:base="http://blog.salkinium.com/typesafe-register-access-in-c++/">&lt;p&gt;When you are writing software for microcontrollers, reading and writing hardware registers becomes second nature.
Registers and bit mappings are typically “modeled” using C preprocessor defines, and usually provided to you by your cross compiler toolchain in device specific header files.&lt;/p&gt;

&lt;p&gt;Setting up and toggling PG13 on the STM32F4 this way looks rather… unreadable:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// set push-pull, output&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;GPIOG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OSPEEDR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIOG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OSPEEDR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;GPIOG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MODER&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIOG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MODER&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;GPIOG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OTYPER&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;GPIOG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PUPDR&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;GPIOG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ODR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// toggle&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// delay&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It did not really dawn on me how primitive this concept was until I was forced to model a memory map myself for one of our many &lt;a href=&quot;http://xpcc.io/api/group__driver.html&quot;&gt;device drivers&lt;/a&gt;.
Since I have never been a friend of using the C preprocessor in C++ unless absolutely necessary, it seemed like a good opportunity to research how best to implement this in pure C++.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;existing-concepts&quot;&gt;Existing Concepts&lt;/h2&gt;

&lt;p&gt;Martin Moene has compiled &lt;a href=&quot;http://www.eld.leidenuniv.nl/~moene/Home/papers/accu/overload95-register/&quot;&gt;an excellent  overview&lt;/a&gt; of the relevant publications regarding C++ hardware register access.
Perhaps the most relevant of those is a paper written by Ken Smith titled &lt;a href=&quot;http://yogiken.files.wordpress.com/2010/02/c-register-access.pdf&quot;&gt;“C++ Hardware Register Access Redux”&lt;/a&gt; written in 2010.&lt;/p&gt;

&lt;p&gt;Smith’s policy based design is quite complete and there even exists a &lt;a href=&quot;https://github.com/JinShil/memory_mapped_io&quot;&gt;functioning implementation&lt;/a&gt; by Jin Shil keyed to embedded systems — albeit in the D programming language.&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;
The author has implemented part of the STM32F4 memory map with these classes and uses them in a simple &lt;a href=&quot;https://github.com/JinShil/stm32f42_discovery_demo/blob/0f355d63bd7823f593ef770db1703bc2cf3454a6/source/start.d#L253&quot;&gt;D program for toggling a pin&lt;/a&gt; (a C++ version would look similar):&lt;/p&gt;

&lt;div class=&quot;language-d highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// set push-pull, output&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;GPIOG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OSPEEDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OSPEEDR13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;GPIOG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MODER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MODER13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;     &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;GPIOG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OTYPER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OT13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;       &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;GPIOG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PUPDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PUPDR13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;     &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;GPIOG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ODR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ODR13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIOG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ODR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ODR13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// toggle&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// delay&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4 Mar 2015 – Update:&lt;/strong&gt; I seem to have completely missed &lt;a href=&quot;https://github.com/kensmith/cppmmio&quot;&gt;Ken Smith’s own implementation&lt;/a&gt;. He also has a &lt;a href=&quot;https://github.com/kensmith/cortex-from-scratch&quot;&gt;Cortex-M example&lt;/a&gt;.&lt;br /&gt;
&lt;strong&gt;5 Mar 2015 – Update:&lt;/strong&gt; For an excellent example of a similar implementation for the AVR using C++11, see &lt;a href=&quot;https://github.com/chrism333/yalla&quot;&gt;the yalla library&lt;/a&gt;.&lt;br /&gt;
&lt;strong&gt;8 Sep 2015 – Update:&lt;/strong&gt; There also exists the &lt;a href=&quot;https://github.com/kvasir-io/Kvasir/tree/master/Lib/Register&quot;&gt;Kvasir register implementation&lt;/a&gt; which has a few more tricks up its sleeve regarding atomicity and efficiency. Impressive.&lt;/p&gt;

&lt;p&gt;Here are a few of my observations:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;How does one generate the C++ memory map? By hand for every device? How do you keep it up-to-date for new devices?&lt;/li&gt;
  &lt;li&gt;The above code is syntactically already a huge improvement. However, its semantics are just as cryptic. What does writing value &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3&lt;/code&gt; into register &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GPIOG.OSPEEDR.OSPEEDR13&lt;/code&gt; actually mean?&lt;/li&gt;
  &lt;li&gt;The papers compiled by Moene are assuming we want to access the devices internal memory. For devices connected via an external bus, accessing a memory location can be an expensive operation, which can take a long time and even fail.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;high-effort-solution&quot;&gt;High Effort Solution&lt;/h4&gt;

&lt;p&gt;Even though Smith’s policy based design does not carry a runtime penalty, implementing and maintaining it clearly comes with some overhead.
Every device family requires its own memory map implementation, which would be crazy to code by hand. Not only for the sheer effort required, but also since this would be incredibly prone to errors. (&lt;a href=&quot;https://github.com/JinShil/stm32_datasheet_to_d&quot;&gt;Jin Shin seems to have realized this too&lt;/a&gt;.)
If the manufacturer adds a new device to the family, you would have to update and perhaps extend this memory map implementation.&lt;/p&gt;

&lt;p&gt;A generator is required, which converts a computer readable memory map into the C++ counterpart and this with as little additional effort as possible.
Notice that the existing memory files in your compiler toolchain (the ones with the defines) only provide you with names for memory addresses, bits and configuration, but lacks the information required for generating the correct policies.&lt;/p&gt;

&lt;p&gt;Therefore you would need to find an “annotated” memory map, which is probably only available directly from the manufacturer. Atmel has so-called “Part Description Files” hidden somewhere deep in AVR Studio, which are used by the avr-gcc developers to generate the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io.h&lt;/code&gt; memory files for the AVRs. ST Microelectronics has similar files hidden in their STM32Cube initialization code generator.&lt;/p&gt;

&lt;p&gt;I know this, because xpcc uses exactly these memory maps to generate its &lt;a href=&quot;https://github.com/roboterclubaachen/xpcc/tree/develop/src/xpcc/architecture/platform/devices&quot;&gt;own device files&lt;/a&gt;. I can tell you that writing and maintaining a parser for these files is painful, since they are littered with inconsistencies. I cannot imagine maintaining this for the entire memory map. The errors in Atmel’s memory maps drive me crazy enough.&lt;/p&gt;

&lt;p&gt;So unless the manufacturer goes the extra mile and publishes their device memory maps preferably open-source on GitHub (unlikely) or directly provide the C++ implementations themselves (even less likely), the burden to generate these implementations and keep them up-to-date is placed on the library maintainers.
That’s not really an option.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;17 Mar 2015 – Update:&lt;/strong&gt; As part of &lt;a href=&quot;http://cmsis.arm.com&quot;&gt;CMSIS&lt;/a&gt;, ARM has standardized &lt;a href=&quot;http://www.keil.com/pack/doc/CMSIS/SVD/html/index.html&quot;&gt;System View Description (SVD)&lt;/a&gt; files which describe the memory map of vendor devices. These files could be the foundation for generation, however, a vendor-specific EULA needs to be agreed to before download.&lt;br /&gt;
&lt;strong&gt;12 Sep 2015 – Update:&lt;/strong&gt; Paul has created a &lt;a href=&quot;https://github.com/posborne/cmsis-svd&quot;&gt;GitHub repository containing most SVD files and a python parser&lt;/a&gt;. This could be a gamechanger!&lt;/p&gt;

&lt;h4 id=&quot;semantics-matter&quot;&gt;Semantics Matter&lt;/h4&gt;

&lt;p&gt;Let me put forward this blunt theory:
Regardless of how elegantly register access is realized in a language, there is hardly a semantical advantage of this, since you are still writing magic numbers into a lot of magic registers (in a more beautiful and type-safe way though).&lt;/p&gt;

&lt;p&gt;In xpcc the above code is reduced to these three equivalent &lt;em&gt;and&lt;/em&gt; self-explanatory lines:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;GpioG13&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;configure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Gpio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OutputType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PushPull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;GpioG13&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setOutput&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;GpioG13&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toggle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// delay&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Notice how there are no registers in this code whatsoever and how clear the meaning of the code becomes.
It seems to be much more useful to implement a clean hardware abstraction layer, than a form of register access.&lt;/p&gt;

&lt;p&gt;This does not mean that elegant register access is pointless, however, its level of abstraction might be too low for your library to benefit from.
It might be an enrichment for the library developers (Smith proposes unit testing register access), but usually a higher level of abstraction is required.&lt;/p&gt;

&lt;h4 id=&quot;missed-the-bus&quot;&gt;Missed The Bus&lt;/h4&gt;

&lt;p&gt;An external device is typically connected through a serial bus like UART, SPI or I&lt;sup&gt;2&lt;/sup&gt;C, which is very slow compared to any internal bus.
Even the few devices using a parallel bus interface (like external RAM) most often multiplex their address and data lines to minimize the amount of required pins. It’s probably fair to say “Internal &amp;gt; Parallel &amp;gt; SPI &amp;gt; UART &amp;gt; I&lt;sup&gt;2&lt;/sup&gt;C” in terms of transfer speed.&lt;/p&gt;

&lt;p&gt;Since a typical read-modify-write means accessing the bus twice, a naive implementation of our example code would yield 8 bus accesses for setting up the port and another 2 for every pin toggle.
That only takes a few cycles using the internal bus&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;, but would easily stretch to micro- and milliseconds on an external serial bus, which makes it impractical to busy-wait during this time.&lt;/p&gt;

&lt;p&gt;There is another problem. Consider the following memory layout of an external accelerometer:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rw: | Config1 | Config2 | Config3 | Config4 |
       0x20      0x21      0x22      0x23

ro: | Status | XL | XH | YL | YH | ZL | ZH |
       0x30   0x31 0x32 0x33 0x34 0x35 0x36
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Both the configuration registers as well as the read-only registers are all placed in one continuos memory block.
The most usual serial interfaces of external devices auto-increment their start address, so that we can efficiently write or read a continuos block of memory.
This would allow us one bus access to write the four configuration bytes, and not have to access the bus four times to write only one byte each time.
Similarly, we also do not want to access each of the read-only registers separately.&lt;/p&gt;

&lt;p&gt;However, such a register block access is not considered in Smith’s design nor in Jin Shin’s implementation.
It is also “merely” an optimization when using a different bus type, but it still breaks with the existing interface.&lt;/p&gt;

&lt;p&gt;Considering this and the ideas on semantics, I would argue that devices connected through an external bus require a different level of abstraction.&lt;/p&gt;

&lt;h2 id=&quot;what-now&quot;&gt;What Now?&lt;/h2&gt;

&lt;p&gt;If you have read to here the situation seems a bit hopeless.
The existing solutions are difficult to implement and maintain, provide little semantical advantages and do not work well over external busses.
And I still have no idea how to model the memory map of my external devices.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;So let us ignore the internal memory.&lt;/em&gt; We already have a way of using it with the defines and with a good hardware abstraction layer there should be no need to access them directly.&lt;/p&gt;

&lt;h4 id=&quot;modelling-registers&quot;&gt;Modelling Registers&lt;/h4&gt;

&lt;p&gt;Instead, let’s focus on how to model register content of external devices and ignore the bus for the moment.&lt;/p&gt;

&lt;p&gt;Registers can be made up of three things:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Bits: a single bit (position &lt;em&gt;N&lt;/em&gt;),&lt;/li&gt;
  &lt;li&gt;Configurations: a combination of bits where the meaning does not correspond to its numeric value (position &lt;em&gt;[N, M]&lt;/em&gt;)&lt;/li&gt;
  &lt;li&gt;Values: a numeric value (position &lt;em&gt;[N, M]&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example of an 8bit register: Control&lt;/p&gt;

&lt;center&gt;
&lt;img invertible=&quot;&quot; src=&quot;control_register.svg&quot; /&gt;
&lt;/center&gt;

&lt;ul&gt;
  &lt;li&gt;Bit &lt;em&gt;7&lt;/em&gt;: Enable&lt;/li&gt;
  &lt;li&gt;Bit &lt;em&gt;6&lt;/em&gt;: Full Scale&lt;/li&gt;
  &lt;li&gt;Configuration &lt;em&gt;[5, 4]&lt;/em&gt;: Prescaler
    &lt;ul&gt;
      &lt;li&gt;00: Divide by 1&lt;/li&gt;
      &lt;li&gt;01: Divide by 2&lt;/li&gt;
      &lt;li&gt;10: Divide by 4&lt;/li&gt;
      &lt;li&gt;11: Divide by 8&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Value &lt;em&gt;[3, 1]&lt;/em&gt;: Start-Up Delay in ms&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There should be an easy way to access all of this information in the register.&lt;/p&gt;

&lt;h4 id=&quot;static-constexpr&quot;&gt;static constexpr&lt;/h4&gt;

&lt;p&gt;The first idea and implementation was a bit messy.
I wanted to make every bit a static constant expression of class &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bit&lt;/code&gt;.
Similar constructs are possible for configurations and values.
Using operator and constructor overloading these constant expressions could be converted and assigned and OR’ed in a type-safe way.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Control&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Register8&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EN&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bit7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FS&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bit6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Prescaler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Group&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitPosition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Config&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Mask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;0b11&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitPosition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Config&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DivideBy1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitPosition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Config&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DivideBy2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x01&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitPosition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Config&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DivideBy4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x02&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitPosition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Config&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DivideBy8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x03&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitPosition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I actually &lt;a href=&quot;https://github.com/roboterclubaachen/xpcc/commit/ef55cb32a57b129af8a068f5b6c043eac2512312#diff-ba8846bac2db804c7b7c4a5d477002a0R159&quot;&gt;implemented most of this&lt;/a&gt; (with a bunch of ugly macros to reduce the verbosity of it).
Then I realized that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static constexpr&lt;/code&gt; members require an external instantiation for the linker, which would place them somewhere in memory.
This is because the C++11 standard permits taking the address of a static constexpr member, and only instantiated members actually have an address.&lt;/p&gt;

&lt;p&gt;What a dealbreaker.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;30 Aug 2015 – Update:&lt;/strong&gt; Using a better approach, C. Biffle has implemented &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bitfields&lt;/code&gt;, which models &lt;a href=&quot;https://github.com/cbiffle/etl/blob/master/biffield/README.mkdn&quot;&gt;memory-mapped register banks for his ETL library&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;strongly-typed-enumerations&quot;&gt;Strongly-Typed Enumerations&lt;/h2&gt;

&lt;p&gt;Which C++ type does not need to be instantiated to be used? Yes, enums.
However, C++03 enums convert to integers pretty quickly, but thankfully, in C++11 we have strongly-typed enums which don’t do that.&lt;/p&gt;

&lt;h4 id=&quot;register-bits&quot;&gt;Register Bits&lt;/h4&gt;

&lt;p&gt;Using strongly-typed enums we can describe the bits of the example register as such:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Control&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;EN&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bit7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;///&amp;lt; bit documentation&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;FS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bit6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;PRE1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bit5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;PRE0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bit4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;DEL2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bit3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;DEL1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bit2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;DEL0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bit1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flags8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;Control_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Since strongly-typed enums do not have any predefined operators, they are wrapped into the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flags8&lt;/code&gt; &lt;a href=&quot;http://xpcc.io/api/structxpcc_1_1_flags.html&quot;&gt;template class&lt;/a&gt;&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;, which adds the necessary constructors and bitwise operator overloading to them and returns them as a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flags8&lt;/code&gt; type.&lt;sup id=&quot;fnref:4&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;This means, you can handle all its register bits as you would expect:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Control_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;control&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;control&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;control&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;control&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;control&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PRE1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isSet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;control&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;control&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PRE1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PRE0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;control&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DEL0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;noneSet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;control&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PRE1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PRE0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allSet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;control&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You still get raw access if you really need it:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;raw&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;control&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// the underlying type&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;control&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And the access is type-safe, you cannot use bits from two different registers:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Control2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;DIS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bit4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;HS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bit3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flags8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;Control2_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;control&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// compile error&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can even overload functions on argument type now:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Control_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;control&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Control2_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;control&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// calls #1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Control2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DIS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;// calls #2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;register-configurations&quot;&gt;Register Configurations&lt;/h4&gt;

&lt;p&gt;Configurations are also described as a strongly-typed enum and then wrapped into the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Configuration&lt;/code&gt; &lt;a href=&quot;http://xpcc.io/api/structxpcc_1_1_configuration.html&quot;&gt;template class&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Prescaler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Div1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;				&lt;span class=&quot;c1&quot;&gt;///&amp;lt; configuration documentation&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Div2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PRE0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Div4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PRE1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Div8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PRE1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PRE0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Configuration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Prescaler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bit5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bit4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;Prescaler_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prescaler&lt;/code&gt; enum values are already shifted in this example (hence the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(Bit5 | Bit4)&lt;/code&gt; mask), however you can also declare the prescaler values non-shifted and let the wrapper shift it:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Prescaler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Div1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Div2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Div4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Div8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Configuration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Control_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Prescaler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;0b11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Prescaler_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Why? If you have two or more configurations with the same selections in the same register,  you can simply add another one:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Configuration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Prescaler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;0b11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;Prescaler2_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Configurations can be used inline:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Control_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;control&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Prescaler_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Prescaler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Div2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Control_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;control&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Prescaler_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But do not have to:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Prescaler_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;control&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Prescaler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Div2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Prescaler_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;control&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Prescaler&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prescaler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Prescaler_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;control&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;register-values&quot;&gt;Register Values&lt;/h4&gt;

&lt;p&gt;Values are described using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Value&lt;/code&gt; &lt;a href=&quot;http://xpcc.io/api/structxpcc_1_1_value.html&quot;&gt;template class&lt;/a&gt; which masks and shifts the value as required.
In our example the value has a width of 3 bits and needs to be shifted 1 bit:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;Delay_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This can be used the same way as the Configuration:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Control_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;control&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Prescaler_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Prescaler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Div2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Delay_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Control_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;control&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Delay_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Delay_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;control&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Delay_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;control&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Delay_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;control&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;efficiency&quot;&gt;Efficiency&lt;/h4&gt;

&lt;p&gt;These classes are using as much &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;constexpr&lt;/code&gt; as possible, so constexpr constructors, constexpr operator overloading and constexpr methods.
This means whatever can be computed at compile time, will be computed at compile time.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Control_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;control&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Prescaler_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Prescaler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Div2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Delay_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// is just fancy syntax sugar coating for&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;control&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xA4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Of course if your Configuration or Value class has to extract a value at runtime, the masking and shifting will happen at runtime. Not all that surprising.&lt;/p&gt;

&lt;h2 id=&quot;what-about-the-bus&quot;&gt;What About The Bus?&lt;/h2&gt;

&lt;p&gt;The above code works on a copy of the register content in the hosts RAM.
To understand why this makes a lot of sense for external devices, consider the accelerometer memory map from previously:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rw: | Config1 | Config2 | Config3 | Config4 |
       0x20      0x21      0x22      0x23

ro: | Status | XL | XH | YL | YH | ZL | ZH |
       0x30   0x31 0x32 0x33 0x34 0x35 0x36
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In our device driver we would reserve 4 bytes for buffering the configuration registers, 1 byte for the status register and 6 bytes for the data.&lt;/p&gt;

&lt;p&gt;Usually, configuration registers are not changed by the external hardware itself, so you can modify the local copy of the configuration register and then only need to write the result once to the external hardware.
During device driver initialization you can also prepare all configuration registers and then write all 4 at once.&lt;/p&gt;

&lt;p&gt;Similarly the status and data bytes can be read in one bus access and buffered locally for further computations.&lt;/p&gt;

&lt;p&gt;At the very basic level, the driver needs to provide functions to update the registers content:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// bool because bus access can fail&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;updateControl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Control_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setMask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clearMask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0xff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Control_t&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;getControl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rawBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;updateControl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// is equivalent to&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Control_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;control&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getControl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;control&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;control&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;updateControl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;control&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;However providing meaningful setters and getters makes your code much more usable:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;updateControl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;disable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;updateControl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Control_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Control&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;setPrescaler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Prescaler&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prescaler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;updateControl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prescaler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Prescaler_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Prescaler&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getPrescaler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Prescaler_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getControl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For working examples of this concept have a look at the &lt;a href=&quot;http://xpcc.io/api/classxpcc_1_1_itg3200.html&quot;&gt;ITG3200&lt;/a&gt;, &lt;a href=&quot;http://xpcc.io/api/classxpcc_1_1_lis302dl.html&quot;&gt;LIS302&lt;/a&gt; and &lt;a href=&quot;http://xpcc.io/api/classxpcc_1_1_lis3dsh.html&quot;&gt;LIS3DSH&lt;/a&gt; device drivers.
These drivers use &lt;a href=&quot;http://xpcc.io/api/group__resumable.html&quot;&gt;resumable functions&lt;/a&gt; to make bus access non-blocking.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Don’t bother with a pure C++ model of your internal memory.&lt;/li&gt;
  &lt;li&gt;Better invest the time in a useful hardware abstraction layer.&lt;/li&gt;
  &lt;li&gt;Buffer often accessed registers of external devices locally.&lt;/li&gt;
  &lt;li&gt;Use the typesafe C++ access classes for these registers as presented.&lt;/li&gt;
  &lt;li&gt;Be aware of the overhead of using an external bus.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;This post was first published at blog.xpcc.io.&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;D seems to be a lot better suited for compile time evaluations than C++. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;This is different from dektop-class CPUs, where even the internal bus is magnitudes slower than the CPU. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;You actually need to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XPCC_FLAGS8(Control)&lt;/code&gt;, which expands to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;typedef Flags8&amp;lt;Control&amp;gt; Control_t;&lt;/code&gt; and some magic enum operator overloading. &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;While researching for this post I discovered an almost identical &lt;a href=&quot;https://github.com/grisumbras/enum-flags&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flags&lt;/code&gt; class on Github&lt;/a&gt;. However, it is not written for embedded targets and has a slightly different field of application. &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Niklas Hauser</name><email>niklas@salkinium.com</email></author><summary type="html">When you are writing software for microcontrollers, reading and writing hardware registers becomes second nature. Registers and bit mappings are typically “modeled” using C preprocessor defines, and usually provided to you by your cross compiler toolchain in device specific header files. Setting up and toggling PG13 on the STM32F4 this way looks rather… unreadable: // set push-pull, output GPIOG-&amp;gt;OSPEEDR = (GPIOG-&amp;gt;OSPEEDR &amp;amp; ~(3 &amp;lt;&amp;lt; 26)) | (3 &amp;lt;&amp;lt; 26); GPIOG-&amp;gt;MODER = (GPIOG-&amp;gt;MODER &amp;amp; ~(3 &amp;lt;&amp;lt; 26)) | (1 &amp;lt;&amp;lt; 26); GPIOG-&amp;gt;OTYPER &amp;amp;= ~(1 &amp;lt;&amp;lt; 13); GPIOG-&amp;gt;PUPDR &amp;amp;= ~(1 &amp;lt;&amp;lt; 13); while(true) { GPIOG-&amp;gt;ODR ^= (1 &amp;lt;&amp;lt; 13); // toggle // delay } It did not really dawn on me how primitive this concept was until I was forced to model a memory map myself for one of our many device drivers. Since I have never been a friend of using the C preprocessor in C++ unless absolutely necessary, it seemed like a good opportunity to research how best to implement this in pure C++.</summary></entry></feed>