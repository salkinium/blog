<!DOCTYPE html> <html lang="en-US"> <head prefix="og: http://ogp.me/ns#"> <meta charset="UTF-8" /> <meta http-equiv="X-UA-Compatible" content="ie=edge" /> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <meta name="mobile-web-app-capable" content="yes" /> <meta name="apple-mobile-web-app-capable" content="yes" /> <meta name="application-name" content="embedded entanglement" /> <meta name="apple-mobile-web-app-status-bar-style" content="#fff" /> <meta name="apple-mobile-web-app-title" content="embedded entanglement" /> <title> Introducing modm-devices: hardware descriptions for AVR and STM32 devices - embedded entanglement </title> <link rel="alternate" href="http://blog.salkinium.com/modm-devices/" hreflang="en-US" /> <link rel="canonical" href="http://blog.salkinium.com/modm-devices/" /> <meta name="description" content="reflecting on embedded software development" /> <meta name="referrer" content="no-referrer-when-downgrade" /> <meta property="fb:app_id" content="" /> <meta property="og:site_name" content="Introducing modm-devices: hardware descriptions for AVR and STM32 devices | Niklas Hauser" /> <meta property="og:title" content="Introducing modm-devices: hardware descriptions for AVR and STM32 devices | Niklas Hauser" /> <meta property="og:type" content="website" /> <meta property="og:url" content="http://blog.salkinium.com/modm-devices/" /> <meta property="og:description" content="reflecting on embedded software development" /> <meta property="og:image" content="" /> <meta property="og:image:width" content="640" /> <meta property="og:image:height" content="640" /> <meta name="twitter:card" content="summary" /> <meta name="twitter:title" content="Introducing modm-devices: hardware descriptions for AVR and STM32 devices | salkinium" /> <meta name="twitter:url" content="http://blog.salkinium.com/modm-devices/" /> <meta name="twitter:site" content="@salkinium" /> <meta name="twitter:creator" content="@salkinium" /> <meta name="twitter:description" content="reflecting on embedded software development" /> <meta name="twitter:image" content="" /> <link type="application/atom+xml" rel="alternate" href="http://blog.salkinium.com/feed.xml" title="embedded entanglement" /> <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicons/apple-touch-icon.png" /> <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png" /> <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png" /> <link rel="manifest" href="/assets/favicons/site.webmanifest" /> <link rel="mask-icon" href="/assets/favicons/safari-pinned-tab.svg" color="#5bbad5" /> <meta name="apple-mobile-web-app-title" content="Jekyll Klise" /> <meta name="application-name" content="Jekyll Klise" /> <meta name="msapplication-TileColor" content="#da532c" /> <meta name="theme-color" content="#2c2c2c" /> <link rel="stylesheet" href="/assets/css/style.css" /> </head> <body data-theme="dark" class="notransition"> <script> const body = document.body; const data = body.getAttribute("data-theme"); const initTheme = (state) => { if (state === "dark") { body.setAttribute("data-theme", "dark"); } else if (state === "light") { body.removeAttribute("data-theme"); } else { localStorage.setItem("theme", data); } }; initTheme(localStorage.getItem("theme")); setTimeout(() => body.classList.remove("notransition"), 75); </script> <div class="navbar" role="navigation"> <nav class="menu"> <input type="checkbox" id="menu-trigger" class="menu-trigger" /> <label for="menu-trigger"> <span class="menu-icon"> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <path d="M64,384H448V341.33H64Zm0-106.67H448V234.67H64ZM64,128v42.67H448V128Z" /> </svg> </span> </label> <a id="mode"> <svg class="mode-sunny" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <title>LIGHT</title> <line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> </svg> <svg class="mode-moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <title>DARK</title> <line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> </svg> </a> <div class="trigger"> <div class="trigger-container"><a class="menu-link" href="/">home</a><a class="menu-link" href="/archive/">archive</a><a class="menu-link" href="https://salkinium.com" target="_blank" rel="noopener" >about</a ><a class="menu-link rss" href="/feed.xml"> <svg xmlns="http://www.w3.org/2000/svg" width="17" height="17" viewBox="0 0 512 512" fill="#ED812E" > <title>RSS</title> <path d="M108.56,342.78a60.34,60.34,0,1,0,60.56,60.44A60.63,60.63,0,0,0,108.56,342.78Z" /> <path d="M48,186.67v86.55c52,0,101.94,15.39,138.67,52.11s52,86.56,52,138.67h86.66C325.33,312.44,199.67,186.67,48,186.67Z" /> <path d="M48,48v86.56c185.25,0,329.22,144.08,329.22,329.44H464C464,234.66,277.67,48,48,48Z" /> </svg> </a> </div> </div> </nav> </div> <div class="wrapper post"> <main class="page-content" aria-label="Content"> <article itemscope itemtype="https://schema.org/BlogPosting"> <header class="header"> <h1 class="header-title" itemprop="headline">Introducing modm-devices: hardware descriptions for AVR and STM32 devices</h1> <div class="post-meta"> <time datetime="2018-03-07T00:00:00+01:00" itemprop="datePublished"> Mar 07, 2018 </time> <span itemprop="author" itemscope itemtype="https://schema.org/Person"> <span itemprop="name">Niklas Hauser</span> </span> <time hidden datetime="" itemprop="dateModified"> Mar 07, 2018 </time> <span hidden itemprop="publisher" itemtype="Person">Niklas Hauser</span> <span hidden itemprop="image"></span> <span hidden itemprop="mainEntityOfPage"><p>For the last 2 years <a href="https://github.com/dergraaf">Fabian Greif</a> and I have been working on a secret project called <a href="https://github.com/modm-io/">modm: a toolkit for data-driven code generation</a>. In a nutshell, we feed detailed hardware description data for almost all AVR and STM32 targets into a code generator to create a C++ Hardware Abstraction Layer (HAL), startup &amp; linkerscript code, documentation and support tools.</p> <p>This isn’t exactly a new idea, after all very similar ideas have been floating around before, most notably in the Linux Kernel with its <a href="https://www.devicetree.org">Device Tree (DT) effort</a>. In fact, modm itself is based entirely on <a href="http://xpcc.io">xpcc</a> which matured the idea of data-driven HAL generation in the first place.</p> <p>However, for modm we focused on what goes on behind the scenes: how to <em>acquire</em> detailed target description data and how to <em>use</em> it with reasonable effort. We now have a toolbox that transcends its use as our C++ HAL generator and instead can be applied generically to any project in any language (*awkwardly winks at the Rust community*). That’s pretty powerful stuff.</p> <p>So let me first ease you into this topic with some historic background and then walk you through the data sources we use and the design decisions of our data engine. All with plenty of examples for you to follow along, just stay well clear of those hairy yaks in the distance.</p> <h2 id="the-origin-story">The Origin Story</h2> <p>All the usual suspects in this case were members of the <a href="http://www.roboterclub.rwth-aachen.de/">Roboterclub Aachen e. V.</a> (<a href="https://twitter.com/RCA_eV">@RCA_eV</a>). Around 2006 the team surrounding Fabian had built a communication library called RCCP for doing remote procedure calls over CAN. Back then the only affordable microcontrollers were AVRs, but neither were they powerful enough to perform all the computations needed for autonomy nor did they have enough pins to interface with all the motors and sensors we stuffed in our robots. So an embedded PC programmed in various languages did all the heavy lifting and talked via CAN to the AVR actuators and sensors.</p> <p>(It has been passed on for many generations of robot builders, that the embedded PC did a disk check once during its boot process, which rendered the robot unresponsive for a few minutes. Unfortunately it did this during the a <a href="http://www.eurobot.org">Eurobot</a> finals game and we lost due to that. Since then our robots don’t have a kernel in their critical path anymore.)</p> <p>RCCP was eventually refactored into the Cross Platform Component Communication (XPCC) library and open-sourced on Sourceforge in 2009. Around 2012 when Fabian was leaving us to go work on satellites at the German space agency (DLR), I took over stewardship of the project and moved it over to <a href="https://github.com/roboterclubaachen/xpcc">GitHub where it exists to this day</a>. It’s the foundation of all the RCAs robots.</p> <h3 id="from-avr-to-stm32">From AVR to STM32</h3> <p>By the time I joined in 2010, the team had been using C++ on AVRs for years. Around 2012 we finally outgrew the AVRs used to control our autonomous robots and switched over to Arm Cortex-M devices, specifically the STM32 series. So began the cumbersome task of porting the HAL that worked so well on the AVRs to the STM32F1 and F4 families, both of which have much more capable peripherals.</p> <p>We had inherited a C++ API that passed around static classes containing the peripheral abstraction to template classes wrapping these classes. It’s the clear anti-thesis of polymorphic interface design, almost a form of “compile time duck-typing”:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">GpioB0</span> <span class="p">{</span>
<span class="nl">public:</span> <span class="c1">// one class for every GPIO on the device</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">set</span><span class="p">(</span><span class="kt">bool</span> <span class="n">state</span><span class="p">);</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">SpiMaster0</span> <span class="p">{</span>
<span class="nl">public:</span> <span class="c1">// one class for every Spi peripheral</span>
    <span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">swap</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">data</span><span class="p">);</span>
<span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">SpiMaster</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ChipSelect</span> <span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">SensorDriver</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">uint8_t</span> <span class="n">read</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">ChipSelect</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="n">Gpio</span><span class="o">::</span><span class="n">Low</span><span class="p">);</span>
        <span class="kt">uint8_t</span> <span class="n">result</span> <span class="o">=</span> <span class="n">SpiMaster</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">foobar</span><span class="p">);</span>
        <span class="n">ChipSelect</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="n">Gpio</span><span class="o">::</span><span class="n">High</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// Hey look, a generic sensor driver</span>
<span class="n">SensorDriver</span><span class="o">&lt;</span> <span class="n">SpiMaster0</span><span class="p">,</span> <span class="n">GpioB0</span> <span class="o">&gt;</span> <span class="n">compass</span><span class="p">;</span>
<span class="kt">uint8_t</span> <span class="n">heading</span> <span class="o">=</span> <span class="n">compass</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
</code></pre></div></div> <center> <p><a href="http://www.stroustrup.com/good_concepts.pdf">C++ concepts</a> sure would be useful here for asserting <code class="language-plaintext highlighter-rouge">SpiMaster</code> traits. *cough*</p> </center> <p>This technique resulted in a rather unusual HAL, but when used <em>in moderation</em> it yields ridiculously small binary sizes! And this was absolutely a requirement on our AVRs which wanted to stuff full of control code for our autonomous robots.</p> <p>The size reduction didn’t so much come from using C++ features like templates, but from being able to very accurately dissect special cases into their own functions. This is particularly useful on AVRs where the IO memory map is very irregular and differs quite a bit between devices. Writing one function to handle all variations at runtime can be more expensive than writing a couple of specialized functions and letting the linker throw away all the unused ones.</p> <p>But it does have one significant and obvious disadvantage: Our HAL had to <em>have</em> a class for every peripheral you want to use. And adding these classes manually didn’t scale very well with us and it proved an even bigger problem for a device with the peripheral amount and features of an STM32. And so the inevitable happened: we started using preprocessor macros to “instantiate” these peripheral classes, or switched between different implementation with extensive, often nested, <code class="language-plaintext highlighter-rouge">#if/#else/#endif</code> trees. It was such an ugly solution.</p> <p>We also had a mechanism for generating code manually calling a Jinja2 template engine and committing the result, in fact, already <a href="https://github.com/roboterclubaachen/xpcc/commit/e239176#diff-41dfb98586123c4821a51af70cf93ae8">since Nov. 2009</a>. It was first used to create the AVR’s UART classes and slowly expanded to other platforms. But it didn’t really scale either because you still had to explicitly provide all the substitution data to the engine, which usually only was the number, or letter, identifying the peripheral.</p> <p>It wasn’t until 2013 that <a href="https://github.com/ekiwi">Kevin Läufer</a> generalized this idea by moving it into our <a href="http://scons.org">SCons-based</a> build system and collecting all template substitution data into one common file per target, which we just called “The Device File” (naming things is hard, ok?). This made it much easier to generate new peripheral drivers and it even did so on-the-fly during the build process due to being included into SCons’ dependency graph, which eliminated the need for manually committing these generated files and keeping them up-to-date.</p> <h3 id="first-steps">First Steps</h3> <p>The first draft of the <a href="https://github.com/roboterclubaachen/xpcc/commit/3fcf8cb">STM32F407’s device file</a> was assembled by hand and lacked a clear structure. In retrospect, we also had trouble deciding which data goes in the device file and which <a href="https://github.com/roboterclubaachen/xpcc/blob/826c43797d31513d128760c190b19bdc61ca2f6b/src/xpcc/architecture/platform/core/cortex/stm32/stm32.macros#L52-L168">stays embedded in the templates</a>, but, we didn’t sweat the details, since we had an entire library to refactor and a robot to build.</p> <p>The major limitation of our system of course was getting the required data and manually assembling it didn’t scale, and so we were stuck in the same bottleneck as before, albeit with a slightly better build process. And then, after researching how avr-gcc actually generate the <code class="language-plaintext highlighter-rouge">&lt;avr/io.h&gt;</code> headers, a solution presented itself: <a href="http://packs.download.atmel.com">Atmel publishes a bunch of XML files called Part Description Files</a>, or PDFs (lolwut?), containing the memory map of their AVR devices, and we just had to reformat this a little bit. Right? If only I knew what I was getting into…</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;module</span> <span class="na">name=</span><span class="s">"USART"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;instance</span> <span class="na">name=</span><span class="s">"USART0"</span> <span class="na">caption=</span><span class="s">"USART"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;register-group</span> <span class="na">name=</span><span class="s">"USART0"</span> <span class="na">name-in-module=</span><span class="s">"USART0"</span> <span class="na">offset=</span><span class="s">"0x00"</span> <span class="na">address-space=</span><span class="s">"data"</span> <span class="na">caption=</span><span class="s">"USART"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;signals&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"TXD"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PD1"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"RXD"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PD0"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"XCK"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PD4"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/signals&gt;</span>
  <span class="nt">&lt;/instance&gt;</span>
<span class="nt">&lt;/module&gt;</span>
<span class="nt">&lt;module</span> <span class="na">name=</span><span class="s">"TWI"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;instance</span> <span class="na">name=</span><span class="s">"TWI"</span> <span class="na">caption=</span><span class="s">"Two Wire Serial Interface"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;register-group</span> <span class="na">name=</span><span class="s">"TWI"</span> <span class="na">name-in-module=</span><span class="s">"TWI"</span> <span class="na">offset=</span><span class="s">"0x00"</span> <span class="na">address-space=</span><span class="s">"data"</span> <span class="na">caption=</span><span class="s">"Two Wire Serial Interface"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;signals&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"SDA"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PC4"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"SCL"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PC5"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/signals&gt;</span>
  <span class="nt">&lt;/instance&gt;</span>
<span class="nt">&lt;/module&gt;</span>
<span class="nt">&lt;module</span> <span class="na">name=</span><span class="s">"PORT"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;instance</span> <span class="na">name=</span><span class="s">"PORTB"</span> <span class="na">caption=</span><span class="s">"I/O Port"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;register-group</span> <span class="na">name=</span><span class="s">"PORTB"</span> <span class="na">name-in-module=</span><span class="s">"PORTB"</span> <span class="na">offset=</span><span class="s">"0x00"</span> <span class="na">address-space=</span><span class="s">"data"</span> <span class="na">caption=</span><span class="s">"I/O Port"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;signals&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"P"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PB0"</span> <span class="na">index=</span><span class="s">"0"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"P"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PB1"</span> <span class="na">index=</span><span class="s">"1"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"P"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PB2"</span> <span class="na">index=</span><span class="s">"2"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"P"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PB3"</span> <span class="na">index=</span><span class="s">"3"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"P"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PB4"</span> <span class="na">index=</span><span class="s">"4"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"P"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PB5"</span> <span class="na">index=</span><span class="s">"5"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"P"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PB6"</span> <span class="na">index=</span><span class="s">"6"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"P"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PB7"</span> <span class="na">index=</span><span class="s">"7"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/signals&gt;</span>
  <span class="nt">&lt;/instance&gt;</span>
</code></pre></div></div> <center> <p>Excerpt of the <code class="language-plaintext highlighter-rouge">ATmega328P.atdf</code> part description file.</p> </center> <p>It really turned out to be a great, but very much incomplete, source of information about AVRs. Even today, over 4 years later, <a href="https://github.com/modm-io/modm/blob/29f73690f43df87030a6dc2a8df56df1fa65ea6f/test/all/ignored.txt#L1-L114">110 AVR memory maps are still missing GPIO signal definitions</a>. So I did what any student with too much time on their hands would do: I began to <em>manually assemble</em> the missing information by downloading <em>all</em> existing AVR device datasheets, reading through <em>all</em> of them and collecting the pinouts in a spreadsheet. I then <em>manually reformatted</em> this data into a <a href="https://github.com/modm-io/modm-devices/blob/64ebb6cdc99e79e3cf405f10d4d00d21f095cf1b/tools/generator/dfg/avr/avr_io.py#L222-L1868">Python data structure, where it still exists today</a>. Don’t do this! I did get the job done, but I wasted two weeks of my life with this crap and even though I was being really diligent, I still made a lot of mistakes.</p> <center> <p><img src="atmega_io.png" alt="" /></p> <p>Ah, the insanities of youth 🙄</p> </center> <p>I also wrote a memory map comparison tool, which was really useful for understanding the batshit-insane AVR IO maps. Since the AVR can only address a certain amount of IO memory directly, the hardware engineers have to “compress” (more like “forcefully stuff”) the IO map and this quickly becomes very ugly. For example, the ATtiny*61 series features differential ADC inputs with selectable gains, configurable in 64 combinations, but register <code class="language-plaintext highlighter-rouge">ADMUX</code> only has space for 5 bits (<code class="language-plaintext highlighter-rouge">MUX0</code> - <code class="language-plaintext highlighter-rouge">MUX4</code>). So Atmel decided to cram <code class="language-plaintext highlighter-rouge">MUX5</code> into register <code class="language-plaintext highlighter-rouge">ADCSRB</code>:</p> <center> <p><img src="attiny_adc_mux.png" alt="" /></p> <p>Wait, did the <code class="language-plaintext highlighter-rouge">ADLAR</code> bit just move around? Nah, must be an illusion. 😒</p> </center> <p>This memory map comparison tool was vital in understanding how all the AVRs memory maps differ and coming up with strategies on how to map this functionality into our HAL. <a href="https://www.youtube.com/watch?v=KMU0tzLwhbE">It’s all about tools, tools, tools, tools</a>!</p> <h2 id="peeking-into-stm32cubemx">Peeking into STM32CubeMX</h2> <p>ST maintains the <a href="http://www.st.com/en/development-tools/stm32cubemx.html">CubeMX initialization code generator</a>, which contains “a pinout-conflict solver, a clock-tree setting helper, a power-consumption calculator, and an utility performing MCU peripheral configuration”. Hm, doesn’t that sound interesting? How did they implement these features, we wondered.</p> <p>Back in 2013 CubeMX was still called MicroXplorer and wasn’t nearly as nice to use as today. It also launched as a Windows-only application, even though it was clearly written in Java (those “beautiful” GUI elements give it away). Nevertheless, CubeMX indeed is a very useful application, giving you a number of visual configuration editors:</p> <center> <p><img src="stm32f103_cube_gpio.png" alt="" /></p> <p>Configuring the USART1_TX signal on pin PB6 on the popular STM32F103RBT.</p> </center> <p>During installation, CubeMX kindly unpacks a <em>huge</em> plaintext (!) database to disk at <code class="language-plaintext highlighter-rouge">STM32CubeMX.app/Contents/Resources/db</code> (on OSX) and even updates it for you on every app launch. This database consists out of a lot of XML files, one for every STM32 device in ST’s portfolio, plus detailed descriptions of peripheral configurations. It really is an insane amount of data.</p> <p>So I invite you to join me on a stroll through the colorful fields of XML that power the core of the CubeMX’s configurators. I’ll be using the STM32F103RBT, which is a very popular controller that can be found all ST Links and on the Plue Pill board available on ebay for a few bucks.</p> <h3 id="gpio-alternate-functions">GPIO Alternate Functions</h3> <p>We start by searching for the unique device identifier <code class="language-plaintext highlighter-rouge">STM32F103RBTx</code> in <code class="language-plaintext highlighter-rouge">mcu/families.xml</code> (which is &gt;30.000 lines long, btw). The minimal information about the device here is used by the parametric search engine in CubeMX.</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Mcu</span> <span class="na">Name=</span><span class="s">"STM32F103R(8-B)Tx"</span> <span class="na">PackageName=</span><span class="s">"LQFP64"</span> <span class="na">RefName=</span><span class="s">"STM32F103RBTx"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Core&gt;</span>ARM Cortex-M3<span class="nt">&lt;/Core&gt;</span>
    <span class="nt">&lt;Frequency&gt;</span>72<span class="nt">&lt;/Frequency&gt;</span>
    <span class="nt">&lt;Ram&gt;</span>20<span class="nt">&lt;/Ram&gt;</span>
    <span class="nt">&lt;Flash&gt;</span>128<span class="nt">&lt;/Flash&gt;</span>
    <span class="nt">&lt;Voltage</span> <span class="na">Max=</span><span class="s">"3.6"</span> <span class="na">Min=</span><span class="s">"2.0"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Current</span> <span class="na">Lowest=</span><span class="s">"1.7"</span> <span class="na">Run=</span><span class="s">"373.0"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Temperature</span> <span class="na">Max=</span><span class="s">"105.0"</span> <span class="na">Min=</span><span class="s">"-40.0"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Peripheral</span> <span class="na">Type=</span><span class="s">"ADC 12-bit"</span> <span class="na">MaxOccurs=</span><span class="s">"16"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Peripheral</span> <span class="na">Type=</span><span class="s">"CAN"</span> <span class="na">MaxOccurs=</span><span class="s">"1"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Peripheral</span> <span class="na">Type=</span><span class="s">"I2C"</span> <span class="na">MaxOccurs=</span><span class="s">"2"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Peripheral</span> <span class="na">Type=</span><span class="s">"RTC"</span> <span class="na">MaxOccurs=</span><span class="s">"1"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Peripheral</span> <span class="na">Type=</span><span class="s">"SPI"</span> <span class="na">MaxOccurs=</span><span class="s">"2"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Peripheral</span> <span class="na">Type=</span><span class="s">"Timer 16-bit"</span> <span class="na">MaxOccurs=</span><span class="s">"4"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Peripheral</span> <span class="na">Type=</span><span class="s">"USART"</span> <span class="na">MaxOccurs=</span><span class="s">"3"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Peripheral</span> <span class="na">Type=</span><span class="s">"USB Device"</span> <span class="na">MaxOccurs=</span><span class="s">"1"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/Mcu&gt;</span>
</code></pre></div></div> <p>Following the <code class="language-plaintext highlighter-rouge">Mcu/@Name</code> leads us to <code class="language-plaintext highlighter-rouge">STM32F103R(8-B)Tx.xml</code> containing what peripherals and how many (<code class="language-plaintext highlighter-rouge">mcu/IP/@InstanceName</code>) as well as what pins exists on this package and where and what alternate functions they can be connected to.</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Core&gt;</span>ARM Cortex-M3<span class="nt">&lt;/Core&gt;</span>
<span class="nt">&lt;Ram&gt;</span>20<span class="nt">&lt;/Ram&gt;</span>
<span class="nt">&lt;Flash&gt;</span>64<span class="nt">&lt;/Flash&gt;</span>
<span class="nt">&lt;Flash&gt;</span>128<span class="nt">&lt;/Flash&gt;</span>
<span class="c">&lt;!-- ... --&gt;</span>
<span class="nt">&lt;IP</span> <span class="na">InstanceName=</span><span class="s">"USART3"</span> <span class="na">Name=</span><span class="s">"USART"</span> <span class="na">Version=</span><span class="s">"sci2_v1_1_Cube"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;IP</span> <span class="na">InstanceName=</span><span class="s">"RCC"</span>    <span class="na">Name=</span><span class="s">"RCC"</span>   <span class="na">Version=</span><span class="s">"STM32F102_rcc_v1_0"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;IP</span> <span class="na">InstanceName=</span><span class="s">"NVIC"</span>   <span class="na">Name=</span><span class="s">"NVIC"</span>  <span class="na">Version=</span><span class="s">"STM32F103G"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;IP</span> <span class="na">InstanceName=</span><span class="s">"GPIO"</span>   <span class="na">Name=</span><span class="s">"GPIO"</span>  <span class="na">Version=</span><span class="s">"STM32F103x8_gpio_v1_0"</span><span class="nt">/&gt;</span>
<span class="c">&lt;!-- ... --&gt;</span>
<span class="nt">&lt;Pin</span> <span class="na">Name=</span><span class="s">"PB5"</span> <span class="na">Position=</span><span class="s">"57"</span> <span class="na">Type=</span><span class="s">"I/O"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Signal</span> <span class="na">Name=</span><span class="s">"I2C1_SMBA"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Signal</span> <span class="na">Name=</span><span class="s">"SPI1_MOSI"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Signal</span> <span class="na">Name=</span><span class="s">"TIM3_CH2"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/Pin&gt;</span>
<span class="nt">&lt;Pin</span> <span class="na">Name=</span><span class="s">"PB6"</span> <span class="na">Position=</span><span class="s">"58"</span> <span class="na">Type=</span><span class="s">"I/O"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Signal</span> <span class="na">Name=</span><span class="s">"I2C1_SCL"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Signal</span> <span class="na">Name=</span><span class="s">"TIM4_CH1"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Signal</span> <span class="na">Name=</span><span class="s">"USART1_TX"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/Pin&gt;</span>
<span class="nt">&lt;Pin</span> <span class="na">Name=</span><span class="s">"PB7"</span> <span class="na">Position=</span><span class="s">"59"</span> <span class="na">Type=</span><span class="s">"I/O"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Signal</span> <span class="na">Name=</span><span class="s">"I2C1_SDA"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Signal</span> <span class="na">Name=</span><span class="s">"TIM4_CH2"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Signal</span> <span class="na">Name=</span><span class="s">"USART1_RX"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/Pin&gt;</span>
</code></pre></div></div> <p>Each peripheral has a <code class="language-plaintext highlighter-rouge">IP/@Version</code>, which leads to a configuration file containing <em>even more</em> data. Don’t cha just love the smell of freshly unpacked data in the morning? For this device’s GPIO peripheral we’ll look for any pins with the <code class="language-plaintext highlighter-rouge">USART1_TX</code> signal in the <code class="language-plaintext highlighter-rouge">mcu/IP/GPIO-STM32F103x8_gpio_v1_0_Modes.xml</code> file:</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;GPIO_Pin</span> <span class="na">PortName=</span><span class="s">"PB"</span> <span class="na">Name=</span><span class="s">"PB6"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;PinSignal</span> <span class="na">Name=</span><span class="s">"USART1_TX"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;RemapBlock</span> <span class="na">Name=</span><span class="s">"USART1_REMAP1"</span><span class="nt">&gt;</span>
           <span class="nt">&lt;SpecificParameter</span> <span class="na">Name=</span><span class="s">"GPIO_AF"</span><span class="nt">&gt;</span>
               <span class="nt">&lt;PossibleValue&gt;</span>__HAL_AFIO_REMAP_USART1_ENABLE<span class="nt">&lt;/PossibleValue&gt;</span>
           <span class="nt">&lt;/SpecificParameter&gt;</span>
        <span class="nt">&lt;/RemapBlock&gt;</span>
    <span class="nt">&lt;/PinSignal&gt;</span>
<span class="nt">&lt;/GPIO_Pin&gt;</span>
<span class="c">&lt;!-- ... --&gt;</span>
<span class="nt">&lt;GPIO_Pin</span> <span class="na">PortName=</span><span class="s">"PA"</span> <span class="na">Name=</span><span class="s">"PA9"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;PinSignal</span> <span class="na">Name=</span><span class="s">"USART1_TX"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;RemapBlock</span> <span class="na">Name=</span><span class="s">"USART1_REMAP0"</span> <span class="na">DefaultRemap=</span><span class="s">"true"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/PinSignal&gt;</span>
<span class="nt">&lt;/GPIO_Pin&gt;</span>
</code></pre></div></div> <p>So <code class="language-plaintext highlighter-rouge">USART1_TX</code> maps to pin PB6 with <code class="language-plaintext highlighter-rouge">USART1_REMAP1</code> or pin PA9 with <code class="language-plaintext highlighter-rouge">USART1_REMAP0</code>. The STM32F1 series remap signals either in (overlapping) groups or not at all. This is controlled by the <code class="language-plaintext highlighter-rouge">AFIO_MAPRx</code> registers, where we can find PB6/PA9 again:</p> <center> <p><img src="stm32f103_usart1_remap.png" alt="" /></p> </center> <p>The <code class="language-plaintext highlighter-rouge">__HAL_AFIO_REMAP_USART1_ENABLE</code> in the XML is actually just a C function name, and is placed by CubeMX in the generated init code.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">HAL_UART_MspInit</span><span class="p">(</span><span class="n">UART_HandleTypeDef</span><span class="o">*</span> <span class="n">huart</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">GPIO_InitTypeDef</span> <span class="n">GPIO_InitStruct</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">huart</span><span class="o">-&gt;</span><span class="n">Instance</span><span class="o">==</span><span class="n">USART1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* Peripheral clock enable */</span>
        <span class="n">__HAL_RCC_USART1_CLK_ENABLE</span><span class="p">();</span>

        <span class="cm">/**USART1 GPIO Configuration
        PB6     ------&gt; USART1_TX
        PB7     ------&gt; USART1_RX
        */</span>
        <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Pin</span> <span class="o">=</span> <span class="n">GPIO_PIN_6</span><span class="p">;</span>
        <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Mode</span> <span class="o">=</span> <span class="n">GPIO_MODE_AF_PP</span><span class="p">;</span>
        <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Speed</span> <span class="o">=</span> <span class="n">GPIO_SPEED_FREQ_HIGH</span><span class="p">;</span>
        <span class="n">HAL_GPIO_Init</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GPIO_InitStruct</span><span class="p">);</span>

        <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Pin</span> <span class="o">=</span> <span class="n">GPIO_PIN_7</span><span class="p">;</span>
        <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Mode</span> <span class="o">=</span> <span class="n">GPIO_MODE_INPUT</span><span class="p">;</span>
        <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Pull</span> <span class="o">=</span> <span class="n">GPIO_NOPULL</span><span class="p">;</span>
        <span class="n">HAL_GPIO_Init</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GPIO_InitStruct</span><span class="p">);</span>

        <span class="n">__HAL_AFIO_REMAP_USART1_ENABLE</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The IP files do contain a very large amount of information, however, it’s mostly directed at the code generation capabilities of the CubeMX project exporter, and as such, not very useful as stand-alone information. For example, the above GPIO signal information relies on the existence of a <code class="language-plaintext highlighter-rouge">__HAL_AFIO_REMAP_USART1_ENABLE()</code> function that performs the remapping. The mapping between the bits in the <code class="language-plaintext highlighter-rouge">AFIO_MAPRx</code> registers and the remap groups is therefore encoded in two separate places: these xml files, and the family’s CubeHAL.</p> <p>The <code class="language-plaintext highlighter-rouge">mcu/IP/NVIC-STM32F103G_Modes.xml</code> configuration file, used to configure the NVIC in the CubeMX, exemplifies this quite well: here we see the first 10 interrupt vectors paired with additional metadata (<code class="language-plaintext highlighter-rouge">PossibleValue/@Value</code> seems to contain some <code class="language-plaintext highlighter-rouge">:</code> separated conditionals for visibility inside the GUI tool).</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;RefParameter</span> <span class="na">Comment=</span><span class="s">"Interrupt Table"</span> <span class="na">Name=</span><span class="s">"IRQn"</span> <span class="na">Type=</span><span class="s">"list"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"Non maskable interrupt"</span> <span class="na">Value=</span><span class="s">"NonMaskableInt_IRQn:N,IF_HAL::HAL_RCC_NMI_IRQHandler:CSSEnabled"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"Hard fault interrupt"</span> <span class="na">Value=</span><span class="s">"HardFault_IRQn:N,W1:::"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"Memory management fault"</span> <span class="na">Value=</span><span class="s">"MemoryManagement_IRQn:Y,W1:::"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"Prefetch fault, memory access fault"</span> <span class="na">Value=</span><span class="s">"BusFault_IRQn:Y,W1:::"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"Undefined instruction or illegal state"</span> <span class="na">Value=</span><span class="s">"UsageFault_IRQn:Y,W1:::"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"System service call via SWI instruction"</span> <span class="na">Value=</span><span class="s">"SVCall_IRQn:Y,RTOS::NONE:"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"Debug monitor"</span> <span class="na">Value=</span><span class="s">"DebugMonitor_IRQn:Y::NONE:"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"Pendable request for system service"</span> <span class="na">Value=</span><span class="s">"PendSV_IRQn:Y,RTOS::NONE:"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"System tick timer"</span> <span class="na">Value=</span><span class="s">"SysTick_IRQn:Y:::"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"Window watchdog interrupt"</span> <span class="na">Value=</span><span class="s">"WWDG_IRQn:Y:WWDG:HAL_WWDG_IRQHandler:"</span><span class="nt">/&gt;</span>
</code></pre></div></div> <p>However, their actual position in the interrupt vector table is missing, and so this data cannot be used to extract a valid interrupt table. Instead an alias is used here to pair the interrupt with its actual table position, as defined in the <a href="https://github.com/modm-io/cmsis-header-stm32/blob/master/stm32f1xx/Include/stm32f103xb.h#L86-L144">STM32F103xB CMSIS header file</a>.</p> <p>For example, the <code class="language-plaintext highlighter-rouge">WWDG</code> interrupt vector is located at position 16 (=16+0), while the <code class="language-plaintext highlighter-rouge">SVCall</code> vector is located at position 11 (=16-5), or 5 positions behind the <code class="language-plaintext highlighter-rouge">UsageFault</code> vector:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cm">/*!&lt; Interrupt Number Definition */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="n">NonMaskableInt_IRQn</span>   <span class="o">=</span> <span class="o">-</span><span class="mi">14</span><span class="p">,</span> <span class="cm">/*!&lt; 2 Non Maskable Interrupt                */</span>
  <span class="n">HardFault_IRQn</span>        <span class="o">=</span> <span class="o">-</span><span class="mi">13</span><span class="p">,</span> <span class="cm">/*!&lt; 3 Cortex-M3 Hard Fault Interrupt        */</span>
  <span class="n">MemoryManagement_IRQn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="cm">/*!&lt; 4 Cortex-M3 Memory Management Interrupt */</span>
  <span class="n">BusFault_IRQn</span>         <span class="o">=</span> <span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="cm">/*!&lt; 5 Cortex-M3 Bus Fault Interrupt         */</span>
  <span class="n">UsageFault_IRQn</span>       <span class="o">=</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="cm">/*!&lt; 6 Cortex-M3 Usage Fault Interrupt       */</span>
  <span class="n">SVCall_IRQn</span>           <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span>  <span class="cm">/*!&lt; 11 Cortex-M3 SV Call Interrupt          */</span>
  <span class="n">DebugMonitor_IRQn</span>     <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span>  <span class="cm">/*!&lt; 12 Cortex-M3 Debug Monitor Interrupt    */</span>
  <span class="n">PendSV_IRQn</span>           <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="cm">/*!&lt; 14 Cortex-M3 Pend SV Interrupt          */</span>
  <span class="n">SysTick_IRQn</span>          <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="cm">/*!&lt; 15 Cortex-M3 System Tick Interrupt      */</span>
  <span class="n">WWDG_IRQn</span>             <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="cm">/*!&lt; Window WatchDog Interrupt               */</span>
  <span class="c1">// ...</span>
<span class="p">}</span> <span class="n">IRQn_Type</span><span class="p">;</span>
</code></pre></div></div> <p>So keep in mind that this data is not meant to be a sensible hardware description format and it just often lacks basic information that would make it much more useful. Then again, the only consumer of this information is supposed to be CubeMX for its fairly narrow goal of code generation.</p> <h3 id="clock-tree">Clock Tree</h3> <p>Let’s look at another very interesting data source in CubeMX: the clock configuration wizard:</p> <center> <p><img src="stm32f103_cube_clock.gif" alt="" /></p> </center> <p>What’s so interesting about this configurator is that it <em>knows</em> what the maximum frequencies of the respective clock segments are, and more importantly, how to set the prescalers to resolve these issues and this for every device. You surely know where this is going by know. Yup, it’s backed by data, and here is what it looks like rendered with graphviz.</p> <center> <p><img src="stm32f100_clock.png" alt="" /></p> </center> <p>Here is a beautified excerpt from <code class="language-plaintext highlighter-rouge">plugins/clock/STM32F102.xml</code>, which only shows the connections highlighted in red. Note how the text in the nodes maps to the <code class="language-plaintext highlighter-rouge">Element/@type</code> and <code class="language-plaintext highlighter-rouge">Element/@id</code> attributes, and how the <code class="language-plaintext highlighter-rouge">Element/Output</code> and <code class="language-plaintext highlighter-rouge">Element/Input</code> children declare a (unique) <code class="language-plaintext highlighter-rouge">@signalId</code> and which node they are connecting to:</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Tree</span> <span class="na">id=</span><span class="s">"ClockTree"</span><span class="nt">&gt;</span>
  <span class="c">&lt;!-- HSE --&gt;</span>
  <span class="nt">&lt;Element</span> <span class="na">id=</span><span class="s">"HSEOSC"</span> <span class="na">type=</span><span class="s">"variedSource"</span> <span class="na">refParameter=</span><span class="s">"HSE_VALUE"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">signalId=</span><span class="s">"HSE"</span> <span class="na">to=</span><span class="s">"HSEDivPLL"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/Element&gt;</span>
  <span class="c">&lt;!-- PLL div input from HSE --&gt;</span>
  <span class="nt">&lt;Element</span> <span class="na">id=</span><span class="s">"HSEDivPLL"</span> <span class="na">type=</span><span class="s">"devisor"</span> <span class="na">refParameter=</span><span class="s">"HSEDivPLL"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Input</span> <span class="na">signalId=</span><span class="s">"HSE"</span> <span class="na">from=</span><span class="s">"HSEOSC"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">signalId=</span><span class="s">"HSE_PLL"</span> <span class="na">to=</span><span class="s">"PLLSource"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/Element&gt;</span>
  <span class="nt">&lt;Tree</span> <span class="na">id=</span><span class="s">"PLL"</span><span class="nt">&gt;</span>
    <span class="c">&lt;!-- PLLsource MUX source pour PLL mul --&gt;</span>
    <span class="nt">&lt;Element</span> <span class="na">id=</span><span class="s">"PLLSource"</span> <span class="na">type=</span><span class="s">"multiplexor"</span> <span class="na">refParameter=</span><span class="s">"PLLSourceVirtual"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;Input</span> <span class="na">signalId=</span><span class="s">"HSE_PLL"</span> <span class="na">from=</span><span class="s">"HSEDivPLL"</span> <span class="na">refValue=</span><span class="s">"RCC_PLLSOURCE_HSE"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;Output</span> <span class="na">signalId=</span><span class="s">"VCOInput"</span> <span class="na">to=</span><span class="s">"VCO2output"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/Element&gt;</span>
    <span class="nt">&lt;Element</span> <span class="na">id=</span><span class="s">"VCO2output"</span> <span class="na">type=</span><span class="s">"output"</span> <span class="na">refParameter=</span><span class="s">"VCOOutput2Freq_Value"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;Input</span> <span class="na">signalId=</span><span class="s">"VCOInput"</span> <span class="na">from=</span><span class="s">"PLLSource"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;Output</span> <span class="na">signalId=</span><span class="s">"VCO2Input"</span> <span class="na">to=</span><span class="s">"PLLMUL"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/Element&gt;</span>
    <span class="nt">&lt;Element</span> <span class="na">id=</span><span class="s">"PLLMUL"</span> <span class="na">type=</span><span class="s">"multiplicator"</span> <span class="na">refParameter=</span><span class="s">"PLLMUL"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;Input</span> <span class="na">signalId=</span><span class="s">"VCO2Input"</span> <span class="na">from=</span><span class="s">"VCO2output"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;Output</span> <span class="na">signalId=</span><span class="s">"PLLCLK"</span> <span class="na">to=</span><span class="s">"SysClkSource"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/Element&gt;</span>
  <span class="nt">&lt;/Tree&gt;</span>
  <span class="c">&lt;!--Sysclock mux --&gt;</span>
  <span class="nt">&lt;Element</span> <span class="na">id=</span><span class="s">"SysClkSource"</span> <span class="na">type=</span><span class="s">"multiplexor"</span> <span class="na">refParameter=</span><span class="s">"SYSCLKSource"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Input</span> <span class="na">signalId=</span><span class="s">"PLLCLK"</span> <span class="na">from=</span><span class="s">"PLLMUL"</span> <span class="na">refValue=</span><span class="s">"RCC_SYSCLKSOURCE_PLLCLK"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">signalId=</span><span class="s">"SYSCLK"</span> <span class="na">to=</span><span class="s">"SysCLKOutput"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/Element&gt;</span>
  <span class="nt">&lt;Element</span> <span class="na">id=</span><span class="s">"SysCLKOutput"</span> <span class="na">type=</span><span class="s">"output"</span> <span class="na">refParameter=</span><span class="s">"SYSCLKFreq_VALUE"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Input</span> <span class="na">signalId=</span><span class="s">"SYSCLK"</span> <span class="na">from=</span><span class="s">"SysClkSource"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">signalId=</span><span class="s">"SYSCLKOUT"</span> <span class="na">to=</span><span class="s">"AHBPrescaler"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/Element&gt;</span>
  <span class="c">&lt;!-- AHB input**SYSclock** --&gt;</span>
  <span class="nt">&lt;Element</span> <span class="na">id=</span><span class="s">"AHBPrescaler"</span> <span class="na">type=</span><span class="s">"devisor"</span> <span class="na">refParameter=</span><span class="s">"AHBCLKDivider"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Input</span> <span class="na">signalId=</span><span class="s">"SYSCLKOUT"</span> <span class="na">from=</span><span class="s">"SysCLKOutput"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">signalId=</span><span class="s">"HCLK"</span> <span class="na">to=</span><span class="s">"AHBOutput"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/Element&gt;</span>
  <span class="c">&lt;!-- AHB input**SYSclock** output**FHCLK,HCLK,Diviseurcortex,APB1,APB2 --&gt;</span>
  <span class="nt">&lt;Element</span> <span class="na">id=</span><span class="s">"AHBOutput"</span> <span class="na">type=</span><span class="s">"activeOutput"</span> <span class="na">refParameter=</span><span class="s">"HCLKFreq_Value"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Input</span> <span class="na">signalId=</span><span class="s">"HCLK"</span> <span class="na">from=</span><span class="s">"AHBPrescaler"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">to=</span><span class="s">"FCLKCortexOutput"</span> <span class="na">signalId=</span><span class="s">"AHBCLK"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">to=</span><span class="s">"FSMClkOutput"</span> <span class="na">signalId=</span><span class="s">"AHBCLK"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">to=</span><span class="s">"SDIOClkOutput"</span> <span class="na">signalId=</span><span class="s">"AHBCLK"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">to=</span><span class="s">"HCLKDiv2"</span> <span class="na">signalId=</span><span class="s">"AHBCLK"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">to=</span><span class="s">"HCLKOutput"</span> <span class="na">signalId=</span><span class="s">"AHBCLK"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">to=</span><span class="s">"TimSysPresc"</span> <span class="na">signalId=</span><span class="s">"AHBCLK"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">to=</span><span class="s">"APB1Prescaler"</span> <span class="na">signalId=</span><span class="s">"AHBCLK"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">to=</span><span class="s">"APB2Prescaler"</span> <span class="na">signalId=</span><span class="s">"AHBCLK"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/Element&gt;</span>
<span class="nt">&lt;/Tree&gt;</span>
</code></pre></div></div> <p>We still don’t know how CubeMX is able to do it actual calculations, because the clock graph above doesn’t contain any numbers at all. Some digging around later we can trace the <code class="language-plaintext highlighter-rouge">Element/@refParameter</code> attribute to the <code class="language-plaintext highlighter-rouge">IP/RCC-STM32F102_rcc_v1_0_Modes.xml</code> which contains *drumroll* numbers, and lots of ‘em:</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- Les frequences des sources --&gt;</span>
<span class="nt">&lt;RefParameter</span> <span class="na">Name=</span><span class="s">"HSE_VALUE"</span> <span class="na">Min=</span><span class="s">"4000000"</span> <span class="na">Max=</span><span class="s">"16000000"</span> <span class="na">Display=</span><span class="s">"value/1000000"</span> <span class="na">Unit=</span><span class="s">"MHz"</span><span class="nt">/&gt;</span>
<span class="c">&lt;!-- frequence PLL --&gt;</span>
<span class="nt">&lt;RefParameter</span> <span class="na">Name=</span><span class="s">"VCOOutput2Freq_Value"</span> <span class="na">Min=</span><span class="s">"1000000"</span> <span class="na">Max=</span><span class="s">"25000000"</span> <span class="na">Display=</span><span class="s">"value/1000000"</span> <span class="na">Unit=</span><span class="s">"MHz"</span><span class="nt">/&gt;</span>
<span class="c">&lt;!-- les diviseurs --&gt;</span>
<span class="nt">&lt;RefParameter</span> <span class="na">Name=</span><span class="s">"HSEDivPLL"</span> <span class="na">DefaultValue=</span><span class="s">"RCC_HSE_PREDIV_DIV1"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"1"</span> <span class="na">Value=</span><span class="s">"RCC_HSE_PREDIV_DIV1"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"2"</span> <span class="na">Value=</span><span class="s">"RCC_HSE_PREDIV_DIV2"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/RefParameter&gt;</span>
<span class="c">&lt;!-- Les multiplicateurs --&gt;</span>
<span class="nt">&lt;RefParameter</span> <span class="na">Name=</span><span class="s">"PLLMUL"</span> <span class="na">DefaultValue=</span><span class="s">"RCC_PLL_MUL2"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"2"</span> <span class="na">Value=</span><span class="s">"RCC_PLL_MUL2"</span><span class="nt">/&gt;</span>
  <span class="c">&lt;!-- ... --&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"16"</span> <span class="na">Value=</span><span class="s">"RCC_PLL_MUL16"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/RefParameter&gt;</span>
<span class="c">&lt;!-- Les frequences des signaux --&gt;</span>
<span class="c">&lt;!-- SYS clock freq de l'output --&gt;</span>
<span class="nt">&lt;RefParameter</span> <span class="na">Name=</span><span class="s">"SYSCLKFreq_VALUE"</span> <span class="na">Max=</span><span class="s">"72000000"</span> <span class="na">Display=</span><span class="s">"value/1000000"</span> <span class="na">Unit=</span><span class="s">"MHz"</span><span class="nt">/&gt;</span>
<span class="c">&lt;!-- diviseur AHB 1..512 --&gt;</span>
<span class="nt">&lt;RefParameter</span>  <span class="na">Name=</span><span class="s">"AHBCLKDivider"</span> <span class="na">DefaultValue=</span><span class="s">"RCC_SYSCLK_DIV1"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"1"</span> <span class="na">Value=</span><span class="s">"RCC_SYSCLK_DIV1"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"2"</span> <span class="na">Value=</span><span class="s">"RCC_SYSCLK_DIV2"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"4"</span> <span class="na">Value=</span><span class="s">"RCC_SYSCLK_DIV4"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"8"</span> <span class="na">Value=</span><span class="s">"RCC_SYSCLK_DIV8"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"16"</span> <span class="na">Value=</span><span class="s">"RCC_SYSCLK_DIV16"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"64"</span> <span class="na">Value=</span><span class="s">"RCC_SYSCLK_DIV64"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"128"</span> <span class="na">Value=</span><span class="s">"RCC_SYSCLK_DIV128"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"256"</span> <span class="na">Value=</span><span class="s">"RCC_SYSCLK_DIV256"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"512"</span> <span class="na">Value=</span><span class="s">"RCC_SYSCLK_DIV512"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/RefParameter&gt;</span>
<span class="c">&lt;!-- AHB out freq --&gt;</span>
<span class="nt">&lt;RefParameter</span> <span class="na">Name=</span><span class="s">"HCLKFreq_Value"</span> <span class="na">Max=</span><span class="s">"72000000"</span> <span class="na">Display=</span><span class="s">"value/1000000"</span> <span class="na">Unit=</span><span class="s">"MHz"</span><span class="nt">/&gt;</span>
</code></pre></div></div> <p>Did you know that ST is a French-Italian company? Cos those XML comments clearly aren’t in English. 🤔 Well, that and they seem keen on calling it a “devisor” when they really mean “divider”. What is this, I don’t even.</p> <center> <p><img src="not_anything_wrong.gif" alt="" /></p> <p>French comments in XML</p> </center> <p>Anyways, here you can see the <code class="language-plaintext highlighter-rouge">RefParameter/@min</code> and <code class="language-plaintext highlighter-rouge">RefParameter/@max</code> frequency values as well as prescaler values encoded as <code class="language-plaintext highlighter-rouge">PossibleValue/@Comment</code>, which are all used by CubeMX to check and fix your clock tree. That’s pretty amazing actually.</p> <p>Ok, so I’m not going into the data of their board support packages, because I don’t think any health insurance covers this much exposure to XML, especially not XML containing French comments. But feel free to take a look at your own risk, it’s just waiting there in <code class="language-plaintext highlighter-rouge">plugins/boardmanager/boards</code> for your prying eyes.</p> <p>Let’s move on to how we can extract this data programmatically and use it to bring order to chaos, one example at a time. A bit like the Avengers franchise *drags out blog post to infinity*</p> <h2 id="generating-device-files">Generating Device Files</h2> <p>The goal of finding machine-readable device description data obviously was to write a program to import, clean-up and convert it into a format that’s more agreeable to our use-case of generating a HAL. Ironically the Device File Generator (DFG) started out in mid 2013 with the innocently named commit <a href="https://github.com/roboterclubaachen/xpcc/commit/1532289">“Cheap and simple parsing of the XML files”</a>. It’s not cheap and simple anymore.</p> <p>The DFG started out as a glorified <a href="https://en.wikipedia.org/wiki/XPath">XPath</a> wrapper in xpcc, but then quickly devolved into some messy monster, that pulled in data from all over the place and arranged it without much concept. Back then we were busy building porting the HAL, writing sensor drivers and building robots, so we didn’t approach this problem structurally, and rather fixed bugs when they occurred.</p> <p>I won’t talk about xpcc’s DFG architecture issues in detail, instead I’ll be showing you the problems it caused us. This way, the lessons learned are more transferable to other format (*cough* Device Tree *cough*), since the device data is immutable whereas the DFG’s architecture is not.</p> <p>Note that I rewrote the DFG from scratch for modm, so <a href="https://github.com/modm-io/modm-devices">you can have a look at the source code</a> while reading this. I’m continuing to use the STM32F103RBT6 for illustration, but this all works very similarly for all STM32 and AVR devices.</p> <h3 id="device-identifiers">Device Identifiers</h3> <p>We needed a way to identify what device to build our HAL for, and of course we use the manufacturers identifier, since it’s (hopefully) unique. We also needed to split up the identifier string, so that the HAL can query its traits to select what code templates to use. For example, in xpcc we split <code class="language-plaintext highlighter-rouge">stm32f103rbt6</code> into:</p> <center> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   stm32     f1     103     r       b    ​
{platform}{family}{name}{pin-id}{size-id}
</code></pre></div> </div> </center> <p>Note how we forgot the <code class="language-plaintext highlighter-rouge">t6</code> suffix. If we compare this with the documentation on the ST ordering information scheme, you’ll see why this was a huge mistake:</p> <center> <p><img src="stm32f1_ordering_info_scheme.png" width="75%" /></p> </center> <p>Yup, that’s right, we forgot to encode the package type, causing the DFG to select the first device matching <code class="language-plaintext highlighter-rouge">STM32F103RB</code>! And that would be the <code class="language-plaintext highlighter-rouge">STM32F103RBHx</code> device, since it occurs first in <code class="language-plaintext highlighter-rouge">families.xml</code>.</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Mcu</span> <span class="na">Name=</span><span class="s">"STM32F103R(8-B)Hx"</span> <span class="na">PackageName=</span><span class="s">"TFBGA64"</span> <span class="na">RefName=</span><span class="s">"STM32F103RBHx"</span><span class="nt">&gt;</span>
<span class="c">&lt;!-- ... --&gt;</span>
<span class="nt">&lt;Mcu</span> <span class="na">Name=</span><span class="s">"STM32F103R(8-B)Tx"</span> <span class="na">PackageName=</span><span class="s">"LQFP64"</span>  <span class="na">RefName=</span><span class="s">"STM32F103RBTx"</span><span class="nt">&gt;</span>
</code></pre></div></div> <p>So we actually used the definitions for the TFBGA64 packaged device instead of the LQFP64 packaged device. 🤦‍ Incredibly this didn’t cause immediate problems, since we first focussed on the STM32F3 and F4 families, whose functionality is almost identical between packages.</p> <p>However, we did notice some changes when a new version of CubeMX was released which added or reordered devices in <code class="language-plaintext highlighter-rouge">families.xml</code>. And then all hell broke loose when I added support for parsing the STM32F1 device family, which couples peripheral features to memory size <em>and(!)</em> pin count:</p> <center> <p><img src="stm32f1_feature_package.png" width="80%" /><br /> “32 KB Flash<sup>(1)</sup>” aka. this table isn’t complicated enough already</p> </center> <p>If you’re a hardware engineer at $vendor, <em>PLEASE DON’T DO THIS!</em> This is pure punishment for anyone writing software for these chips. <strong>PLEASE DO NOT DO THIS!</strong> You should not have to query for <em>combinations</em> of identifier traits to get your hardware feature set. Expand your device lineup into new (orthogonal) identifier space instead.</p> <center> <p><img src="not_like_this.gif" alt="" /></p> </center> <p>To be fair, the STM32F1 family was the first ST product to feature a Cortex-M processor and they didn’t use this approach for any of their other STM32 families. I forgive you, ST.</p> <p>So for modm I looked very carefully at how to split the identifier into traits. I made the trait composition and naming transparent to the DFG, it only operates on a dictionary of items, sharing the same identifier mechanism with the AVRs. Since we currently don’t have any information that depends on the temperature range, I left it out for now. Similarly, the device revision is not considered either.</p> <center> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   stm32     f1     03    r     b      t    ​
{platform}{family}{name}{pin}{size}{package}
</code></pre></div> </div> </center> <p>Note how both the xpcc and modm identifier encodings differ from the official ST ordering scheme. Since we are sharing some code across vendors (like the Cortex-M startup code), we need to have a common naming scheme, at least for <code class="language-plaintext highlighter-rouge">{platform}</code> and <code class="language-plaintext highlighter-rouge">{family}</code> or the equivalent for other vendors.</p> <p>Also note that <code class="language-plaintext highlighter-rouge">{name}</code> now does not contain part the trailing <code class="language-plaintext highlighter-rouge">1</code> of the family. This is to prevent the problem in xpcc where the code template authors only checked for the <code class="language-plaintext highlighter-rouge">{name}</code> instead of the <code class="language-plaintext highlighter-rouge">{family}</code> <em>and</em> <code class="language-plaintext highlighter-rouge">{name}</code>, for example, <code class="language-plaintext highlighter-rouge">id["name"] == "103"</code> vs. <code class="language-plaintext highlighter-rouge">id["family"] == "f1" and id["name"] == "03"</code>. This lead to issues when we ported some peripheral drivers to the <code class="language-plaintext highlighter-rouge">L1</code> family (similar to <code class="language-plaintext highlighter-rouge">F0/L0</code>, <code class="language-plaintext highlighter-rouge">F4/L4</code> and <code class="language-plaintext highlighter-rouge">F7/H7</code>).</p> <h3 id="encoding-commonality">Encoding Commonality</h3> <p>You’ve undoubtedly already noticed that the AVR and CubeMX data is quite verbose and noisy. We didn’t want to use this data directly, hence the DFG. However, we wanted to go a step further and cut down on duplicated data, so that we have an easier time verifying the output of the DFG by not having to look through <em>thousands</em> of files, but rather <em>dozens</em>.</p> <p>At the time of this writing, <code class="language-plaintext highlighter-rouge">families.xml</code> contains 1171 STM32 devices, but <a href="https://github.com/modm-io/modm-devices/tree/5d5285ae1b6e889676b6d04a653d26977bf127e8/devices/stm32"><code class="language-plaintext highlighter-rouge">modm-devices/devices/stm32</code></a> only contains 62 device files, that’s ~19x less files than devices.</p> <p>We observed that ST clusters their devices on their website, in their technical documentation and in their software offerings. The coarsest regular cluster pattern is the family, which denotes the type of Cortex-M code used among other features. The subfamilies are then more or less arbitrarily clustered around whatever combination of functionality ST wanted to bring to market, but the cluster patterns of pin count, memory size and package are <em>very</em> regular and often explicitly called out. We wanted to reflect this in our data structure too.</p> <center> <p><img src="stm32f4x9_clusters.jpg" alt="" /><br /> This <a href="http://www.st.com/en/microcontrollers/stm32f469-479.html">STM32F4x9 feature matrix</a> is extremely regular.</p> </center> <p>The Device Tree format deals with data duplication by allowing data specialization through an inheritance tree and tree inclusion nodes. However, you still have to create one leaf node for every device, so in the best case you’d have one DT per device, or if you moved common data up the inheritance tree, you’d have more files than devices.</p> <p>We decided instead to <em>merge</em> our data trees for devices within similar enough clusters and then filter out the data for <em>one</em> device on access. We use logical OR (<code class="language-plaintext highlighter-rouge">|</code>) to combine identifier traits to declare what devices are merged. You’ll recognize the <code class="language-plaintext highlighter-rouge">&lt;naming-schema&gt;</code> from the previous chapter:</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;device</span> <span class="na">platform=</span><span class="s">"stm32"</span> <span class="na">family=</span><span class="s">"f1"</span> <span class="na">name=</span><span class="s">"03"</span> <span class="na">pin=</span><span class="s">"c|r|t|v"</span> <span class="na">size=</span><span class="s">"8|b"</span> <span class="na">package=</span><span class="s">"h|i|t|u"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;naming-schema&gt;</span>{platform}{family}{name}{pin}{size}{package}<span class="nt">&lt;/naming-schema&gt;</span>
  <span class="nt">&lt;valid-device&gt;</span>stm32f103c8t<span class="nt">&lt;/valid-device&gt;</span>
  <span class="c">&lt;!-- ... --&gt;</span>
  <span class="nt">&lt;valid-device&gt;</span>stm32f103rbt<span class="nt">&lt;/valid-device&gt;</span>
</code></pre></div></div> <p><a href="https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/devices/stm32/stm32f1-03-8_b.xml">This device file for the F103x8/b devices</a> therefore contains all that match the identifier pattern of <code class="language-plaintext highlighter-rouge">r"stm32f103[crtv][8b][hitu]"</code>. <a href="https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/tools/device/modm/device_file.py#L33-L51">The engine extracting the data set for a single device</a> will first construct a list of all possible identifier strings via the naming schema and the <code class="language-plaintext highlighter-rouge">device</code> combinations: 4*2*4 = 32 identifiers in this example. It then filters these identifiers by the list in <code class="language-plaintext highlighter-rouge">&lt;valid-device&gt;</code>, since not every combination actually exists. Whatever device file contains the requested identifier string is then used.</p> <p>The identifier schema does not have to include all traits either, it only has to be unambiguous. For example the AVR device identifier schema does not contain <code class="language-plaintext highlighter-rouge">{platform}</code> but we can infer it anyways:</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;device</span> <span class="na">platform=</span><span class="s">"avr"</span> <span class="na">family=</span><span class="s">"mega"</span> <span class="na">name=</span><span class="s">"48|88|168|328"</span> <span class="na">type=</span><span class="s">"|a|p|pa"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;naming-schema&gt;</span>at{family}{name}{type}<span class="nt">&lt;/naming-schema&gt;</span>
</code></pre></div></div> <p>It first seems unnecessary to do this reverse lookup, but it gives us a very important property for free: The extractor does not need to <em>know</em> anything about the identifier, and still understands the mapping of string to traits. So passing <code class="language-plaintext highlighter-rouge">stm32f103rbt</code> is now <em>understood</em> as <code class="language-plaintext highlighter-rouge">stm32 f1 03 r b t</code>. The disadvantage is having to first build all identifier strings, before returning the corresponding device file. However, this mapping can be cached.</p> <p>The device file can now use the traits as filters by prefixing them with <code class="language-plaintext highlighter-rouge">device-</code>. For our example, the device file continues with declaring the core driver instance, which contains the memory map and vector table. The devices here only differ in Flash size, otherwise they are identical:</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;driver</span> <span class="na">name=</span><span class="s">"core"</span> <span class="na">type=</span><span class="s">"cortex-m3"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;memory</span> <span class="na">device-size=</span><span class="s">"8"</span> <span class="na">name=</span><span class="s">"flash"</span> <span class="na">access=</span><span class="s">"rx"</span> <span class="na">start=</span><span class="s">"0x8000000"</span> <span class="na">size=</span><span class="s">"65536"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;memory</span> <span class="na">device-size=</span><span class="s">"b"</span> <span class="na">name=</span><span class="s">"flash"</span> <span class="na">access=</span><span class="s">"rx"</span> <span class="na">start=</span><span class="s">"0x8000000"</span> <span class="na">size=</span><span class="s">"131072"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;memory</span> <span class="na">name=</span><span class="s">"sram1"</span> <span class="na">access=</span><span class="s">"rwx"</span> <span class="na">start=</span><span class="s">"0x20000000"</span> <span class="na">size=</span><span class="s">"20480"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;vector</span> <span class="na">position=</span><span class="s">"0"</span> <span class="na">name=</span><span class="s">"WWDG"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;vector</span> <span class="na">position=</span><span class="s">"1"</span> <span class="na">name=</span><span class="s">"PVD"</span><span class="nt">/&gt;</span>
  <span class="c">&lt;!-- ... --&gt;</span>
  <span class="nt">&lt;vector</span> <span class="na">position=</span><span class="s">"42"</span> <span class="na">name=</span><span class="s">"USBWakeUp"</span><span class="nt">/&gt;</span>
</code></pre></div></div> <p>By applying some simple combinatorics math we can find the minimal trait set that uniquely describes this difference and can push this filter as far up the data tree as possible while still being unambiguous and therefore losslessly reconstructible for all merged device data. This is all done for the sole purpose of optimizing for human readability, so an embedded engineer with some experience can just look at this data and say: “This filter looks too noisy to me, so something is probably is wrong here” 🤓 *sound of datasheet pages flipping*.</p> <p>Here is an example of what I so dramatically complained about before: The STM32F1 peripheral feature set is coupled to the device’s pin count: F103 devices with just <a href="https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/devices/stm32/stm32f1-03-8_b.xml#L68-L109">36 pins have fewer instances of these peripherals</a>:</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;driver</span> <span class="na">name=</span><span class="s">"i2c"</span> <span class="na">type=</span><span class="s">"stm32"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;instance</span> <span class="na">value=</span><span class="s">"1"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;instance</span> <span class="na">device-pin=</span><span class="s">"c|r|v"</span> <span class="na">value=</span><span class="s">"2"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/driver&gt;</span>
<span class="nt">&lt;driver</span> <span class="na">name=</span><span class="s">"spi"</span> <span class="na">type=</span><span class="s">"stm32"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;instance</span> <span class="na">value=</span><span class="s">"1"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;instance</span> <span class="na">device-pin=</span><span class="s">"c|r|v"</span> <span class="na">value=</span><span class="s">"2"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/driver&gt;</span>
<span class="nt">&lt;driver</span> <span class="na">name=</span><span class="s">"usart"</span> <span class="na">type=</span><span class="s">"stm32"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;instance</span> <span class="na">value=</span><span class="s">"1"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;instance</span> <span class="na">value=</span><span class="s">"2"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;instance</span> <span class="na">device-pin=</span><span class="s">"c|r|v"</span> <span class="na">value=</span><span class="s">"3"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/driver&gt;</span>
</code></pre></div></div> <p>Of course both the pin count and the package influence the number of available GPIOs and signals. The algorithm here detected that using the pin count as a filter is enough to safely reconstruct the tree, so the <code class="language-plaintext highlighter-rouge">device-package</code> is missing (it prioritizes traits further “left” in the identifier):</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;driver</span> <span class="na">name=</span><span class="s">"gpio"</span> <span class="na">type=</span><span class="s">"stm32-f1"</span><span class="nt">&gt;</span>
  <span class="c">&lt;!-- ... --&gt;</span>
  <span class="nt">&lt;gpio</span> <span class="na">device-pin=</span><span class="s">"r|v"</span> <span class="na">port=</span><span class="s">"c"</span> <span class="na">pin=</span><span class="s">"10"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;gpio</span> <span class="na">device-pin=</span><span class="s">"r|v"</span> <span class="na">port=</span><span class="s">"c"</span> <span class="na">pin=</span><span class="s">"11"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;signal</span> <span class="na">driver=</span><span class="s">"adc"</span> <span class="na">instance=</span><span class="s">"1"</span> <span class="na">name=</span><span class="s">"exti11"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;signal</span> <span class="na">driver=</span><span class="s">"adc"</span> <span class="na">instance=</span><span class="s">"2"</span> <span class="na">name=</span><span class="s">"exti11"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/gpio&gt;</span>
  <span class="nt">&lt;gpio</span> <span class="na">device-pin=</span><span class="s">"r|v"</span> <span class="na">port=</span><span class="s">"c"</span> <span class="na">pin=</span><span class="s">"12"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;gpio</span> <span class="na">device-pin=</span><span class="s">"c|r|v"</span> <span class="na">port=</span><span class="s">"c"</span> <span class="na">pin=</span><span class="s">"13"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;signal</span> <span class="na">driver=</span><span class="s">"rtc"</span> <span class="na">name=</span><span class="s">"out"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;signal</span> <span class="na">driver=</span><span class="s">"rtc"</span> <span class="na">name=</span><span class="s">"tamper"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/gpio&gt;</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">device-</code> filter traits are ORed, multiple filters on the same node ANDed, and the nodes themselves ORed together again. Keen observers will point out that this can create overly broad filters which would make for incorrect reconstruction. For these cases we have to create two nodes with the same data, but different filters to avoid ambiguity. Here is an example from <a href="https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/devices/stm32/stm32f4-27_29_37_39.xml#L586-L587">the STM32F4{27,29,37,39} device file</a>:</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nt">&lt;gpio</span> <span class="na">port=</span><span class="s">"c"</span> <span class="na">pin=</span><span class="s">"3"</span><span class="nt">&gt;</span>
    <span class="c">&lt;!-- ... --&gt;</span>
    <span class="nt">&lt;signal</span> <span class="na">device-name=</span><span class="s">"27|37"</span> <span class="na">device-pin=</span><span class="s">"a|i|v|z"</span>   <span class="na">af=</span><span class="s">"12"</span> <span class="na">driver=</span><span class="s">"fmc"</span> <span class="na">name=</span><span class="s">"sdcke0"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;signal</span> <span class="na">device-name=</span><span class="s">"29|39"</span> <span class="na">device-pin=</span><span class="s">"a|b|i|n|z"</span> <span class="na">af=</span><span class="s">"12"</span> <span class="na">driver=</span><span class="s">"fmc"</span> <span class="na">name=</span><span class="s">"sdcke0"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/gpio&gt;</span>
</code></pre></div></div> <p>Hm, but that filter does look suspiciously noisy, doesn’t it? This filter pattern is repeated for the <a href="https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/devices/stm32/stm32f4-27_29_37_39.xml#L457-L458"><code class="language-plaintext highlighter-rouge">sdne[1:0]</code></a> and <a href="https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/devices/stm32/stm32f4-27_29_37_39.xml#L558-L559"><code class="language-plaintext highlighter-rouge">sdnwe</code></a> signals, which all belong to the SDRAM controller in the FMC. And according to this data set they seem to be unavailable for the LQFP100 package? Hm, better <del>call Saul</del> check the datasheets:</p> <center> <p><img src="stm32f4xx_fmc_sdcke0.png" width="65%" /></p> <p><img src="stm32f4xx_fmc_sdcke0_af.png" alt="" /> Huh, but the signals <em>do</em> exist for the LQFP100 package!?</p> <p><img src="stm32f4xx_fmc_100.png" alt="" /> “FMC: Yes<sup>(1)</sup>”. Oh, FFS!</p> </center> <p>I checked with CubeMX and the GPIO configurator doesn’t allow you to set SDRAM signals in the LQFP100 package, and there are no <code class="language-plaintext highlighter-rouge">STM32F4[23]7[BN]</code> devices, so everything is fine, I guess? Nothing to see here folks, move along, the filter algorithm encoded this shit correctly. 🙃</p> <center> <p><img src="do_not_want.gif" width="30%" /></p> </center> <p>Anyways, I like our device file format a lot, since it describes the device’s hardware in such a compact and concise form. However, it doesn’t scale graciously at all for data that shares less commonalities between devices in the current clusters.</p> <h3 id="data-pipeline">Data Pipeline</h3> <p>For my rewrite of the DFG for modm I wanted to improve the correctness of device merges, remove device specific knowledge as much as possible, support multiple output formats and rename less data. I’ve already hinted at solutions to some of these in the previous chapters, so let’s have a proper look at them now.</p> <center> <p><img src="dfg_architecture.png" alt="" /></p> </center> <p>The DFG has three parts: frontend, optimizer and backend. Here yellow stands for <span style="background-color:rgb(255,255,202);">input data</span>, blue for <span style="background-color:rgb(192,217,254);">data conversion</span>, red for <span style="background-color:rgb(250,202,199);">intermediate representation (IR)</span> and green for <span style="background-color:rgb(211,234,205);">output data</span>. I’ve already covered the vendor input data and the device merging in much detail.</p> <p><a href="https://github.com/modm-io/modm-devices/blob/8d38650186764c879309fd946b29e94821e6579d/tools/generator/dfg/stm32/stm_device_tree.py#L42-L345">All the ugly is in the parser</a>, it reads the CubeMX data in the same manner I’ve described previously, performs plausibility and format checks on it, and finally normalizes it into a simple Python dictionary. This is just mostly mind-numbingly stupid code to write, since you have to XPath query the CubeMX sources, deal with all the edge cases in the results and normalize all data relative to all devices. Ugly to write, ugly to read, but it gets the job done.</p> <p>Additional curated data gets injected in this step too. The CubeMX data contains a hardware IP version, which seems to correlate loosely to the peripherals feature set, however, I didn’t find it very useful to distinguish between them. So instead I looked up how all peripherals work in the documentation and <a href="https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/tools/generator/dfg/stm32/stm_peripherals.py#L298-L325">grouped them again manually</a>. The device file <code class="language-plaintext highlighter-rouge">driver/@type</code> name comes from this data.</p> <p>For example, here we can see that the entire STM32 platform only has three different I<sup>2</sup>C hardware implementations, one of which only differs with the addition of a digital noise filter.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">'i2c'</span><span class="p">:</span> <span class="p">[{</span>
    <span class="s">'instances'</span><span class="p">:</span> <span class="s">'*'</span><span class="p">,</span>
    <span class="s">'groups'</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="c1"># This hardware can go up to 1MHz (Fast Mode Plus)
</span>            <span class="s">'hardware'</span><span class="p">:</span> <span class="s">'stm32-extended'</span><span class="p">,</span>
            <span class="s">'features'</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s">'devices'</span><span class="p">:</span> <span class="p">[{</span><span class="s">'family'</span><span class="p">:</span> <span class="p">[</span><span class="s">'f0'</span><span class="p">,</span> <span class="s">'f3'</span><span class="p">,</span> <span class="s">'f7'</span><span class="p">]}]</span>
        <span class="p">},{</span>
            <span class="s">'hardware'</span><span class="p">:</span> <span class="s">'stm32l4'</span><span class="p">,</span>
            <span class="s">'features'</span><span class="p">:</span> <span class="p">[</span><span class="s">'dnf'</span><span class="p">],</span>
            <span class="s">'devices'</span><span class="p">:</span> <span class="p">[{</span><span class="s">'family'</span><span class="p">:</span> <span class="p">[</span><span class="s">'l4'</span><span class="p">]}]</span>
        <span class="p">},{</span>
            <span class="c1"># Some F4 have a digital noise filter
</span>            <span class="s">'hardware'</span><span class="p">:</span> <span class="s">'stm32'</span><span class="p">,</span>
            <span class="s">'features'</span><span class="p">:</span> <span class="p">[</span><span class="s">'dnf'</span><span class="p">],</span>
            <span class="s">'devices'</span><span class="p">:</span> <span class="p">[{</span><span class="s">'family'</span><span class="p">:</span> <span class="p">[</span><span class="s">'f4'</span><span class="p">],</span> <span class="s">'name'</span><span class="p">:</span> <span class="p">[</span><span class="s">'27'</span><span class="p">,</span> <span class="s">'29'</span><span class="p">,</span> <span class="s">'37'</span><span class="p">,</span> <span class="s">'39'</span><span class="p">,</span> <span class="s">'46'</span><span class="p">,</span> <span class="s">'69'</span><span class="p">,</span> <span class="s">'79'</span><span class="p">]}]</span>
        <span class="p">},{</span>
            <span class="s">'hardware'</span><span class="p">:</span> <span class="s">'stm32'</span><span class="p">,</span>
            <span class="s">'features'</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s">'devices'</span><span class="p">:</span> <span class="s">'*'</span>
        <span class="p">}</span>
    <span class="p">]</span>
<span class="p">}]</span>
</code></pre></div></div> <p>All names of peripherals, instances, signals are preserved as they are, so that the name matches the documentation. The only exception are names that wouldn’t be valid identifiers in most programming languages. For our STM32F103RBT example, we split up and duplicate these system signals:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SYS_JTCK-SWCLK    =&gt; sys.jtck + sys.swclk
SYS_JTDO-TRACESWO =&gt; sys.jtdo + sys.traceswo
SYS_JTMS-SWDIO    =&gt; sys.jtms + sys.swdio
</code></pre></div></div> <p>The dictionary returned by the parser is then passed onto <a href="https://github.com/modm-io/modm-devices/blob/8d38650186764c879309fd946b29e94821e6579d/tools/generator/dfg/stm32/stm_device_tree.py#L360-L487">a platform specific converter</a> that transforms it into the DFGs intermediate representation. Here the raw data is formatted into a glorified tree structure, which has similar semantics to a very restricted form of XML (ie. attributes are stored separately from its children) and annotates each node with the device’s identifier.</p> <p>Here the memory maps and the interrupt vector table is added to the <code class="language-plaintext highlighter-rouge">name="core"</code> driver node we saw before. The raw data already contains the memories and vectors with the right naming scheme, so it’s easy to just add them here.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">p</span><span class="p">[</span><span class="s">"memories"</span><span class="p">]:</span>
    <span class="n">memory_node</span> <span class="o">=</span> <span class="n">core_driver</span><span class="p">.</span><span class="n">addChild</span><span class="p">(</span><span class="s">"memory"</span><span class="p">)</span>
    <span class="n">memory_node</span><span class="p">.</span><span class="n">setAttributes</span><span class="p">([</span><span class="s">"name"</span><span class="p">,</span> <span class="s">"access"</span><span class="p">,</span> <span class="s">"start"</span><span class="p">,</span> <span class="s">"size"</span><span class="p">],</span> <span class="n">section</span><span class="p">)</span>
<span class="k">for</span> <span class="n">vector</span> <span class="ow">in</span> <span class="n">p</span><span class="p">[</span><span class="s">"interrupts"</span><span class="p">]:</span>
    <span class="n">vector_node</span> <span class="o">=</span> <span class="n">core_driver</span><span class="p">.</span><span class="n">addChild</span><span class="p">(</span><span class="s">"vector"</span><span class="p">)</span>
    <span class="n">vector_node</span><span class="p">.</span><span class="n">setAttributes</span><span class="p">([</span><span class="s">"position"</span><span class="p">,</span> <span class="s">"name"</span><span class="p">],</span> <span class="n">vector</span><span class="p">)</span>

<span class="c1"># sort the node children by start address and size
</span><span class="n">core_driver</span><span class="p">.</span><span class="n">addSortKey</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s">"start"</span><span class="p">],</span> <span class="mi">16</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s">"size"</span><span class="p">]))</span>
                                 <span class="k">if</span> <span class="n">e</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">"memory"</span> <span class="k">else</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="c1"># sort the node children by vector number and name
</span><span class="n">core_driver</span><span class="p">.</span><span class="n">addSortKey</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s">"position"</span><span class="p">]),</span> <span class="n">e</span><span class="p">[</span><span class="s">"name"</span><span class="p">])</span>
                                 <span class="k">if</span> <span class="n">e</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">"vector"</span> <span class="k">else</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s">""</span><span class="p">))</span>
</code></pre></div></div> <p>I’m adding two sort keys to the core driver node here, to bring the entire tree into canonical order. This an absolute requirement for the reproducibility of the results, otherwise I wouldn’t be able to tell what data changed if the line order came out differently on each invocation.</p> <p>It’s time to merge the device IRs now. The device clustering is curated manually, by <a href="https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/tools/generator/dfg/stm32/stm_groups.py">a large list of identifier trait groups</a>. I considered using some kind of heuristic to automate this, but this works really well, particularly for the AVR and STM32F1 devices. It’s difficult to come up with a metric that accurately describes how annoyed I feel when looking at wrongfully merged device files with lotsa noisy filters. 😤</p> <p>The STM32F103 devices are split into these four groups:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="s">'family'</span><span class="p">:</span> <span class="p">[</span><span class="s">'f1'</span><span class="p">],</span>
    <span class="s">'name'</span><span class="p">:</span> <span class="p">[</span><span class="s">'03'</span><span class="p">],</span>
    <span class="s">'size'</span><span class="p">:</span> <span class="p">[</span><span class="s">'4'</span><span class="p">,</span> <span class="s">'6'</span><span class="p">]</span>
<span class="p">},{</span>
    <span class="s">'family'</span><span class="p">:</span> <span class="p">[</span><span class="s">'f1'</span><span class="p">],</span>
    <span class="s">'name'</span><span class="p">:</span> <span class="p">[</span><span class="s">'03'</span><span class="p">],</span>
    <span class="s">'size'</span><span class="p">:</span> <span class="p">[</span><span class="s">'8'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">]</span>
<span class="p">},{</span>
    <span class="s">'family'</span><span class="p">:</span> <span class="p">[</span><span class="s">'f1'</span><span class="p">],</span>
    <span class="s">'name'</span><span class="p">:</span> <span class="p">[</span><span class="s">'03'</span><span class="p">],</span>
    <span class="s">'size'</span><span class="p">:</span> <span class="p">[</span><span class="s">'c'</span><span class="p">,</span> <span class="s">'d'</span><span class="p">,</span> <span class="s">'e'</span><span class="p">]</span>
<span class="p">},{</span>
    <span class="s">'family'</span><span class="p">:</span> <span class="p">[</span><span class="s">'f1'</span><span class="p">],</span>
    <span class="s">'name'</span><span class="p">:</span> <span class="p">[</span><span class="s">'03'</span><span class="p">],</span>
    <span class="s">'size'</span><span class="p">:</span> <span class="p">[</span><span class="s">'f'</span><span class="p">,</span> <span class="s">'g'</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div> <p>In case you’re curious how bad it would be with just one large F103 group, <a href="https://gist.github.com/salkinium/95e3bf6322468c56beef9dc6c7bbaa3f">here is a gist with the resulting device file</a>. It’s not as bad as it could be, but still much harder to read.</p> <p>At this point the merged IR for our F103RBT device basically already looks like the finished device file, including identifier filters:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>device &lt;&gt; stm32f103[c|r|t|v][8|b][h|i|t|u]
. driver &lt;name:core type:cortex-m3&gt;
  . memory &lt;name:flash access:rx start:0x8000000 size:65536&gt; stm32f103[c|r|t|v]8[h|t|u]
  . memory &lt;name:flash access:rx start:0x8000000 size:131072&gt; stm32f103[c|r|t|v]b[h|i|t|u]
  . memory &lt;name:sram1 access:rwx start:0x20000000 size:20480&gt;
  . vector &lt;position:0 name:WWDG&gt;
     ...
  . vector &lt;position:42 name:USBWakeUp&gt;
. driver &lt;name:i2c type:stm32&gt;
  . instance &lt;value:1&gt;
  . instance &lt;value:2&gt; stm32f103[c|r|v][8|b][h|i|t|u]
. driver &lt;name:spi type:stm32&gt;
  . instance &lt;value:1&gt;
  . instance &lt;value:2&gt; stm32f103[c|r|v][8|b][h|i|t|u]
</code></pre></div></div> <p>I’ve already described the device file format above, however, one additional testing step is done before the DFG is finished: A copy of every single device file is taken before merging, so that it can be compared with the device files that are extracted from this merged one. This is a brute-force test to make sure the filter algorithms did perform correctly.</p> <p>On a side note, the conversion from IR to device file format can be performed at any time, so that last merge step is strictly speaking optional. This is useful for debugging but also if you want to output this data in a format that does not support a merge mechanism similar to the device file’s one, like plain JSON.</p> <h2 id="using-device-files">Using Device Files</h2> <p>So now that we have all this data, let’s have some fun with it. modm-devices comes not only with the DFG but also with a device file parser, which can be used like this:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">modm.parser</span><span class="p">,</span> <span class="n">glob</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">devices</span> <span class="o">=</span> <span class="p">{}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">"path/to/modm-devices/devices/**/*.xml"</span><span class="p">):</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="k">for</span> <span class="n">device</span> <span class="ow">in</span> <span class="n">modm</span><span class="p">.</span><span class="n">parser</span><span class="p">.</span><span class="n">DeviceParser</span><span class="p">().</span><span class="n">parse</span><span class="p">(</span><span class="n">filename</span><span class="p">).</span><span class="n">get_devices</span><span class="p">():</span>
<span class="o">&gt;&gt;&gt;</span>         <span class="n">devices</span><span class="p">[</span><span class="n">device</span><span class="p">.</span><span class="n">partname</span><span class="p">]</span> <span class="o">=</span> <span class="n">device</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">devices</span><span class="p">[</span><span class="s">"stm32f103rbt"</span><span class="p">].</span><span class="n">properties</span>
<span class="p">{</span><span class="s">'driver'</span><span class="p">:</span> <span class="p">[{</span><span class="s">'memory'</span><span class="p">:</span> <span class="p">[{</span><span class="s">'access'</span><span class="p">:</span> <span class="s">'rx'</span><span class="p">,</span>
                     <span class="s">'name'</span><span class="p">:</span> <span class="s">'flash'</span><span class="p">,</span>
                     <span class="s">'size'</span><span class="p">:</span> <span class="s">'131072'</span><span class="p">,</span>
                     <span class="s">'start'</span><span class="p">:</span> <span class="s">'0x8000000'</span><span class="p">},</span>
                    <span class="p">{</span><span class="s">'access'</span><span class="p">:</span> <span class="s">'rwx'</span><span class="p">,</span>
                     <span class="s">'name'</span><span class="p">:</span> <span class="s">'sram1'</span><span class="p">,</span>
                     <span class="s">'size'</span><span class="p">:</span> <span class="s">'20480'</span><span class="p">,</span>
                     <span class="s">'start'</span><span class="p">:</span> <span class="s">'0x20000000'</span><span class="p">}],</span>
         <span class="s">'name'</span><span class="p">:</span> <span class="s">'core'</span><span class="p">,</span>
         <span class="s">'type'</span><span class="p">:</span> <span class="s">'cortex-m3'</span><span class="p">,</span>
         <span class="p">...</span> <span class="p">}]</span>
<span class="p">}</span>
</code></pre></div></div> <p>There are some built-in convenience functions for accessing some of the common data in the device files:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">device</span> <span class="o">=</span> <span class="n">devices</span><span class="p">[</span><span class="s">"stm32f103rbt"</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">device</span><span class="p">.</span><span class="n">identifier</span>
<span class="n">OrderedDict</span><span class="p">([(</span><span class="s">'platform'</span><span class="p">,</span> <span class="s">'stm32'</span><span class="p">),</span> <span class="p">(</span><span class="s">'family'</span><span class="p">,</span> <span class="s">'f1'</span><span class="p">),</span> <span class="p">(</span><span class="s">'name'</span><span class="p">,</span> <span class="s">'03'</span><span class="p">),</span> <span class="p">(</span><span class="s">'pin'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">),</span> <span class="p">(</span><span class="s">'size'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">),</span> <span class="p">(</span><span class="s">'package'</span><span class="p">,</span> <span class="s">'t'</span><span class="p">)])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">device</span><span class="p">.</span><span class="n">has_driver</span><span class="p">(</span><span class="s">"usart:avr"</span><span class="p">)</span>
<span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">device</span><span class="p">.</span><span class="n">has_driver</span><span class="p">(</span><span class="s">"usart:stm32"</span><span class="p">)</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">device</span><span class="p">.</span><span class="n">get_driver</span><span class="p">(</span><span class="s">"usart:stm32"</span><span class="p">)</span>
<span class="p">{</span><span class="s">'instance'</span><span class="p">:</span> <span class="p">[</span><span class="s">'1'</span><span class="p">,</span> <span class="s">'2'</span><span class="p">,</span> <span class="s">'3'</span><span class="p">],</span> <span class="s">'name'</span><span class="p">:</span> <span class="s">'usart'</span><span class="p">,</span> <span class="s">'type'</span><span class="p">:</span> <span class="s">'stm32'</span><span class="p">}</span>
</code></pre></div></div> <p>I’ve also written a short <code class="language-plaintext highlighter-rouge">stats</code> script that allows you to compute some very basic information about the device file collection:</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nv">$ </span>python3 tools/device/scripts/stats <span class="nt">--count</span>
1355 devices
 <span class="nv">$ </span>python3 tools/device/scripts/stats <span class="nt">--driver</span>
<span class="o">{</span>
    <span class="s2">"ac"</span>: 234,
    <span class="s2">"adc"</span>: 1339,
    <span class="s2">"aes"</span>: 133,
    <span class="s2">"awex"</span>: 26,
    <span class="s2">"bandgap"</span>: 8,
    <span class="s2">"battery_protection"</span>: 7,
    <span class="s2">"bdma"</span>: 20,
    <span class="s2">"bod"</span>: 30,
    <span class="s2">"can"</span>: 683,
    <span class="s2">"ccl"</span>: 30,
    <span class="s2">"cell_balancing"</span>: 5,
    <span class="s2">"cfd"</span>: 2,
    <span class="s2">"charger_detect"</span>: 4,
    <span class="s2">"clk"</span>: 45,
    <span class="s2">"clock"</span>: 242,
    <span class="s2">"comp"</span>: 577,
    <span class="s2">"core"</span>: 1355,
    ...
<span class="o">}</span>
</code></pre></div></div> <!-- TODO: insert bar graphs for Flash/RAM distributions? --> <p><code class="language-plaintext highlighter-rouge">stats</code> also allows you to dump expanded JSON for a prefix of devices and then query that with the tool of your choice to, for example, get all the I<sup>2</sup>C related signals on port B for the STM32F4 device family. Not sure why you’d want that, but it’s possible.</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nv">$ </span>python3 tools/device/scripts/stats <span class="nt">--json</span> stm32f4 | jq <span class="s1">'[.[] | .device.driver[] | select(.name == "gpio").gpio[] | . as $gpio | .signal[]? | select(.driver == "i2c" and $gpio.port == "b") | ($gpio.port + $gpio.pin + ":" + .name)] | unique'</span>
<span class="o">[</span>
  <span class="s2">"b10:scl"</span>,
  <span class="s2">"b11:sda"</span>,
  <span class="s2">"b12:smba"</span>,
  <span class="s2">"b3:sda"</span>,
  <span class="s2">"b4:sda"</span>,
  <span class="s2">"b5:smba"</span>,
  <span class="s2">"b6:scl"</span>,
  <span class="s2">"b7:sda"</span>,
  <span class="s2">"b8:scl"</span>,
  <span class="s2">"b8:sda"</span>,
  <span class="s2">"b9:sda"</span>
<span class="o">]</span>
</code></pre></div></div> <p>I’ll discuss in more detail how we use the device files in the next blog post about the modm library.</p> <h3 id="try-it-yourself">Try it Yourself</h3> <p>The <a href="https://github.com/modm-io/modm-devices">device file as well as the DFG are available on GitHub</a> for you to play with. It automatically downloads and extracts all the raw data into <code class="language-plaintext highlighter-rouge">modm-devices/tools/generator/raw-device-data</code> folder.</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone <span class="nt">--recursive</span> <span class="nt">--depth</span><span class="o">=</span>1 https://github.com/modm-io/modm-devices.git
<span class="nb">cd </span>modm-devices/tools/generator
<span class="c"># Extract and generate STM32 device data</span>
make extract-data-stm32
make generate-stm32
<span class="c"># Extract and generate AVR device data</span>
make extract-data-avr
make generate-avr
</code></pre></div></div> <p>Not everything I described here is fully implemented, for example, the <a href="https://github.com/salkinium/save-the-clocktrees">clock graph extractor is just a proof-of-concept</a> for now. modm-devices is also supposed to be a Python package installable via pip, but that’s not implemented yet.</p> <p>Please help me maintain this project, I only used devices from a few STM32 families, so it’s difficult to judge the correctness of some of this data. If you know of any other machine readable data, please open an issue or preferrably a pull request.</p> <p>Two more device file checks are currently not implemented: a XML schema validation, and a semantical checker, that verifies the contents consistency. For example, every GPIO signal should be associable with a driver, and no signal name should start with a number (otherwise difficult to map into most programming languages). These are ideas for the future.</p> <p>With some effort and additional data sources (CMSIS-SVD files for example), directly outputting to Device Tree format should be possible too. I leave that one to the experts though. 😇</p> <h2 id="conclusion">Conclusion</h2> <p>It was important to use not to bind this data to any preconceptions of its use by, for example, integrating it tightly into our HAL generator. Instead we’ve very carefully separated modm-devices from our use of it, so that it can stand on its own and be integrated into all sorts of projects by the community. You’re not bound to using this in code either, you can also generate Markdown documentation, or maybe build your own GPIO configurator as a web UI.</p> <p>You can go and use it as is with its Python <code class="language-plaintext highlighter-rouge">DeviceFile</code> interface, however, for larger projects, I’d recommend you write your own wrapper class, that can format the data as you need it. The Device File format may change at any time, so that I can fit in new data or once I don’t like the format anymore, change it completely. So don’t depend on the format directly.</p> <p>The next few blog posts will be about applying this data in our own modm library, how CMSIS-SVD compares to CMSIS Headers as additional data sources, and what it means to model check your HAL with this data.</p> <h3 id="on-a-personal-note">On a Personal Note</h3> <p>The last 5 years working on this have been quite a ride. It has completely changed my view on embedded software engineering and it took a while for me understand this different way of thinking. As far as I know, nobody has deployed hardware description methods on such a large and diverse device base. And we’re just getting started.</p> <p>I’ve been fortunate to have found similarly minded people in the RCA, who provided me with valuable feedback and thoughtful discussions, who mentored me and tolerated my rants about our robot’s code quality. The RCA is self organized, so we don’t have anyone telling us what to do, or <em>how</em> to do it. As a result, we do reinvent the wheel a lot, sometimes for worse, but mostly for the better, like with this project.</p> <p>During this time I’ve not had the best experience with the “professional” C/C++ embedded community. There are too many established developers convinced of their own opinions that won’t stop arguing until they’ve “won” (just ask about using <a href="https://gist.github.com/salkinium/cc7236328a532c8c0f05f74c9ceb30a4">C++ on µCs</a> and bring some 🍿). Together with the growth in amateur interest in embedded software (absolutely <em>not</em> a bad thing), this completely drowned out any worthwhile online discussions on new approaches to embedded software that are different from the “approved” norm. I’m not talking so much about the programming language itself, which is relatively exchangeable for HALs (a rather unpopular opinion), but about HAL design concepts and perhaps most importantly, support tools.</p> <p>Let me give you an example: ST has committed <a href="https://github.com/ARMmbed/mbed-os/graphs/contributors">at least 4-6 engineers</a> to porting its devices to Arm Mbed OS. Good for ST, that’s a lot of money. But: ST only supports <a href="https://gist.github.com/salkinium/f2140b4ba2bbf7cb3c9a99c215392048#file-targets-md">55 of their ~1100 STM32 targets</a> on Mbed OS, with every single one of them ported <em>by hand</em>. This means at least all <a href="https://gist.github.com/salkinium/f2140b4ba2bbf7cb3c9a99c215392048#file-startuplinker-md">startup code and linkerscripts</a> are mostly duplicated for each target and <a href="https://gist.github.com/salkinium/f2140b4ba2bbf7cb3c9a99c215392048#file-gpio_signals-md">all GPIO signal data is added manually</a> by an unfortunate soul with all the <a href="https://github.com/ARMmbed/mbed-os/blob/8f647beacb6f14ce1af7f2eff01d0a497f94f7ae/targets/TARGET_STM/TARGET_STM32F1/TARGET_NUCLEO_F103RB/PeripheralPins.c#L35-L37">side-effects of manual labor</a>. That’s insane, as you’ve seen above, ST is already maintaining and using this data already to generate code with CubeMX. How is this not automated? (I dared to utter this simple observation about two years ago while working at Arm on Mbed OS and it turned out to be <em>surprisingly unpopular</em>. Touchy folks. 🙃)</p> <p>Fortunately, in the last few years there was some significant progress in enabling (new) programming languages on embedded, like <a href="http://micropython.org">MicroPython</a>, <a href="https://www.espruino.com">Javascript runtimes</a> and perhaps the most significant of them: <a href="http://blog.japaric.io">Embedded in Rust</a>. I’ve been particularly impressed with the progress of the community surrounding <a href="https://twitter.com/japaricious">@japaricious</a>, who are currently tackling some very hard issues, <a href="http://blog.japaric.io/brave-new-io/#no-pin-overlap">like IO signal grouping</a> or <a href="http://blog.japaric.io/safe-dma/">safe DMA APIs</a>. I’ve kinda written this blog post for them, since I think they are <a href="https://internals.rust-lang.org/t/announcing-the-embedded-devices-working-group/">best organized to actually use it</a> and they don’t seem afraid to tackle these issues. (Your move, C++ people!)</p> <p><em>Formatting of all data excerpts is possibly copyrighted by their respective owners and if so used here in fair use. However, the data itself are facts which cannot be copyrighted.</em></p> </span> </div> </header> <div class="page-content" itemprop="articleBody"> <p>For the last 2 years <a href="https://github.com/dergraaf">Fabian Greif</a> and I have been working on a secret project called <a href="https://github.com/modm-io/">modm: a toolkit for data-driven code generation</a>. In a nutshell, we feed detailed hardware description data for almost all AVR and STM32 targets into a code generator to create a C++ Hardware Abstraction Layer (HAL), startup &amp; linkerscript code, documentation and support tools.</p> <p>This isn’t exactly a new idea, after all very similar ideas have been floating around before, most notably in the Linux Kernel with its <a href="https://www.devicetree.org">Device Tree (DT) effort</a>. In fact, modm itself is based entirely on <a href="http://xpcc.io">xpcc</a> which matured the idea of data-driven HAL generation in the first place.</p> <p>However, for modm we focused on what goes on behind the scenes: how to <em>acquire</em> detailed target description data and how to <em>use</em> it with reasonable effort. We now have a toolbox that transcends its use as our C++ HAL generator and instead can be applied generically to any project in any language (*awkwardly winks at the Rust community*). That’s pretty powerful stuff.</p> <p>So let me first ease you into this topic with some historic background and then walk you through the data sources we use and the design decisions of our data engine. All with plenty of examples for you to follow along, just stay well clear of those hairy yaks in the distance.</p> <h2 id="the-origin-story"> <a href="#the-origin-story" class="anchor-head"></a> The Origin Story </h2> <p>All the usual suspects in this case were members of the <a href="http://www.roboterclub.rwth-aachen.de/">Roboterclub Aachen e. V.</a> (<a href="https://twitter.com/RCA_eV">@RCA_eV</a>). Around 2006 the team surrounding Fabian had built a communication library called RCCP for doing remote procedure calls over CAN. Back then the only affordable microcontrollers were AVRs, but neither were they powerful enough to perform all the computations needed for autonomy nor did they have enough pins to interface with all the motors and sensors we stuffed in our robots. So an embedded PC programmed in various languages did all the heavy lifting and talked via CAN to the AVR actuators and sensors.</p> <p>(It has been passed on for many generations of robot builders, that the embedded PC did a disk check once during its boot process, which rendered the robot unresponsive for a few minutes. Unfortunately it did this during the a <a href="http://www.eurobot.org">Eurobot</a> finals game and we lost due to that. Since then our robots don’t have a kernel in their critical path anymore.)</p> <p>RCCP was eventually refactored into the Cross Platform Component Communication (XPCC) library and open-sourced on Sourceforge in 2009. Around 2012 when Fabian was leaving us to go work on satellites at the German space agency (DLR), I took over stewardship of the project and moved it over to <a href="https://github.com/roboterclubaachen/xpcc">GitHub where it exists to this day</a>. It’s the foundation of all the RCAs robots.</p> <h3 id="from-avr-to-stm32"> <a href="#from-avr-to-stm32" class="anchor-head"></a> From AVR to STM32 </h3> <p>By the time I joined in 2010, the team had been using C++ on AVRs for years. Around 2012 we finally outgrew the AVRs used to control our autonomous robots and switched over to Arm Cortex-M devices, specifically the STM32 series. So began the cumbersome task of porting the HAL that worked so well on the AVRs to the STM32F1 and F4 families, both of which have much more capable peripherals.</p> <p>We had inherited a C++ API that passed around static classes containing the peripheral abstraction to template classes wrapping these classes. It’s the clear anti-thesis of polymorphic interface design, almost a form of “compile time duck-typing”:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">GpioB0</span> <span class="p">{</span>
<span class="nl">public:</span> <span class="c1">// one class for every GPIO on the device</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">set</span><span class="p">(</span><span class="kt">bool</span> <span class="n">state</span><span class="p">);</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">SpiMaster0</span> <span class="p">{</span>
<span class="nl">public:</span> <span class="c1">// one class for every Spi peripheral</span>
    <span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">swap</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">data</span><span class="p">);</span>
<span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">SpiMaster</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ChipSelect</span> <span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">SensorDriver</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">uint8_t</span> <span class="n">read</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">ChipSelect</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="n">Gpio</span><span class="o">::</span><span class="n">Low</span><span class="p">);</span>
        <span class="kt">uint8_t</span> <span class="n">result</span> <span class="o">=</span> <span class="n">SpiMaster</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">foobar</span><span class="p">);</span>
        <span class="n">ChipSelect</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="n">Gpio</span><span class="o">::</span><span class="n">High</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// Hey look, a generic sensor driver</span>
<span class="n">SensorDriver</span><span class="o">&lt;</span> <span class="n">SpiMaster0</span><span class="p">,</span> <span class="n">GpioB0</span> <span class="o">&gt;</span> <span class="n">compass</span><span class="p">;</span>
<span class="kt">uint8_t</span> <span class="n">heading</span> <span class="o">=</span> <span class="n">compass</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
</code></pre></div></div> <center> <p><a href="http://www.stroustrup.com/good_concepts.pdf">C++ concepts</a> sure would be useful here for asserting <code class="language-plaintext highlighter-rouge">SpiMaster</code> traits. *cough*</p> </center> <p>This technique resulted in a rather unusual HAL, but when used <em>in moderation</em> it yields ridiculously small binary sizes! And this was absolutely a requirement on our AVRs which wanted to stuff full of control code for our autonomous robots.</p> <p>The size reduction didn’t so much come from using C++ features like templates, but from being able to very accurately dissect special cases into their own functions. This is particularly useful on AVRs where the IO memory map is very irregular and differs quite a bit between devices. Writing one function to handle all variations at runtime can be more expensive than writing a couple of specialized functions and letting the linker throw away all the unused ones.</p> <p>But it does have one significant and obvious disadvantage: Our HAL had to <em>have</em> a class for every peripheral you want to use. And adding these classes manually didn’t scale very well with us and it proved an even bigger problem for a device with the peripheral amount and features of an STM32. And so the inevitable happened: we started using preprocessor macros to “instantiate” these peripheral classes, or switched between different implementation with extensive, often nested, <code class="language-plaintext highlighter-rouge">#if/#else/#endif</code> trees. It was such an ugly solution.</p> <p>We also had a mechanism for generating code manually calling a Jinja2 template engine and committing the result, in fact, already <a href="https://github.com/roboterclubaachen/xpcc/commit/e239176#diff-41dfb98586123c4821a51af70cf93ae8">since Nov. 2009</a>. It was first used to create the AVR’s UART classes and slowly expanded to other platforms. But it didn’t really scale either because you still had to explicitly provide all the substitution data to the engine, which usually only was the number, or letter, identifying the peripheral.</p> <p>It wasn’t until 2013 that <a href="https://github.com/ekiwi">Kevin Läufer</a> generalized this idea by moving it into our <a href="http://scons.org">SCons-based</a> build system and collecting all template substitution data into one common file per target, which we just called “The Device File” (naming things is hard, ok?). This made it much easier to generate new peripheral drivers and it even did so on-the-fly during the build process due to being included into SCons’ dependency graph, which eliminated the need for manually committing these generated files and keeping them up-to-date.</p> <h3 id="first-steps"> <a href="#first-steps" class="anchor-head"></a> First Steps </h3> <p>The first draft of the <a href="https://github.com/roboterclubaachen/xpcc/commit/3fcf8cb">STM32F407’s device file</a> was assembled by hand and lacked a clear structure. In retrospect, we also had trouble deciding which data goes in the device file and which <a href="https://github.com/roboterclubaachen/xpcc/blob/826c43797d31513d128760c190b19bdc61ca2f6b/src/xpcc/architecture/platform/core/cortex/stm32/stm32.macros#L52-L168">stays embedded in the templates</a>, but, we didn’t sweat the details, since we had an entire library to refactor and a robot to build.</p> <p>The major limitation of our system of course was getting the required data and manually assembling it didn’t scale, and so we were stuck in the same bottleneck as before, albeit with a slightly better build process. And then, after researching how avr-gcc actually generate the <code class="language-plaintext highlighter-rouge">&lt;avr/io.h&gt;</code> headers, a solution presented itself: <a href="http://packs.download.atmel.com">Atmel publishes a bunch of XML files called Part Description Files</a>, or PDFs (lolwut?), containing the memory map of their AVR devices, and we just had to reformat this a little bit. Right? If only I knew what I was getting into…</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;module</span> <span class="na">name=</span><span class="s">"USART"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;instance</span> <span class="na">name=</span><span class="s">"USART0"</span> <span class="na">caption=</span><span class="s">"USART"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;register-group</span> <span class="na">name=</span><span class="s">"USART0"</span> <span class="na">name-in-module=</span><span class="s">"USART0"</span> <span class="na">offset=</span><span class="s">"0x00"</span> <span class="na">address-space=</span><span class="s">"data"</span> <span class="na">caption=</span><span class="s">"USART"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;signals&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"TXD"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PD1"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"RXD"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PD0"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"XCK"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PD4"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/signals&gt;</span>
  <span class="nt">&lt;/instance&gt;</span>
<span class="nt">&lt;/module&gt;</span>
<span class="nt">&lt;module</span> <span class="na">name=</span><span class="s">"TWI"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;instance</span> <span class="na">name=</span><span class="s">"TWI"</span> <span class="na">caption=</span><span class="s">"Two Wire Serial Interface"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;register-group</span> <span class="na">name=</span><span class="s">"TWI"</span> <span class="na">name-in-module=</span><span class="s">"TWI"</span> <span class="na">offset=</span><span class="s">"0x00"</span> <span class="na">address-space=</span><span class="s">"data"</span> <span class="na">caption=</span><span class="s">"Two Wire Serial Interface"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;signals&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"SDA"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PC4"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"SCL"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PC5"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/signals&gt;</span>
  <span class="nt">&lt;/instance&gt;</span>
<span class="nt">&lt;/module&gt;</span>
<span class="nt">&lt;module</span> <span class="na">name=</span><span class="s">"PORT"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;instance</span> <span class="na">name=</span><span class="s">"PORTB"</span> <span class="na">caption=</span><span class="s">"I/O Port"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;register-group</span> <span class="na">name=</span><span class="s">"PORTB"</span> <span class="na">name-in-module=</span><span class="s">"PORTB"</span> <span class="na">offset=</span><span class="s">"0x00"</span> <span class="na">address-space=</span><span class="s">"data"</span> <span class="na">caption=</span><span class="s">"I/O Port"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;signals&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"P"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PB0"</span> <span class="na">index=</span><span class="s">"0"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"P"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PB1"</span> <span class="na">index=</span><span class="s">"1"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"P"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PB2"</span> <span class="na">index=</span><span class="s">"2"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"P"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PB3"</span> <span class="na">index=</span><span class="s">"3"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"P"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PB4"</span> <span class="na">index=</span><span class="s">"4"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"P"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PB5"</span> <span class="na">index=</span><span class="s">"5"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"P"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PB6"</span> <span class="na">index=</span><span class="s">"6"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;signal</span> <span class="na">group=</span><span class="s">"P"</span> <span class="na">function=</span><span class="s">"default"</span> <span class="na">pad=</span><span class="s">"PB7"</span> <span class="na">index=</span><span class="s">"7"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/signals&gt;</span>
  <span class="nt">&lt;/instance&gt;</span>
</code></pre></div></div> <center> <p>Excerpt of the <code class="language-plaintext highlighter-rouge">ATmega328P.atdf</code> part description file.</p> </center> <p>It really turned out to be a great, but very much incomplete, source of information about AVRs. Even today, over 4 years later, <a href="https://github.com/modm-io/modm/blob/29f73690f43df87030a6dc2a8df56df1fa65ea6f/test/all/ignored.txt#L1-L114">110 AVR memory maps are still missing GPIO signal definitions</a>. So I did what any student with too much time on their hands would do: I began to <em>manually assemble</em> the missing information by downloading <em>all</em> existing AVR device datasheets, reading through <em>all</em> of them and collecting the pinouts in a spreadsheet. I then <em>manually reformatted</em> this data into a <a href="https://github.com/modm-io/modm-devices/blob/64ebb6cdc99e79e3cf405f10d4d00d21f095cf1b/tools/generator/dfg/avr/avr_io.py#L222-L1868">Python data structure, where it still exists today</a>. Don’t do this! I did get the job done, but I wasted two weeks of my life with this crap and even though I was being really diligent, I still made a lot of mistakes.</p> <center> <p><img src="atmega_io.png" alt="" /></p> <p>Ah, the insanities of youth 🙄</p> </center> <p>I also wrote a memory map comparison tool, which was really useful for understanding the batshit-insane AVR IO maps. Since the AVR can only address a certain amount of IO memory directly, the hardware engineers have to “compress” (more like “forcefully stuff”) the IO map and this quickly becomes very ugly. For example, the ATtiny*61 series features differential ADC inputs with selectable gains, configurable in 64 combinations, but register <code class="language-plaintext highlighter-rouge">ADMUX</code> only has space for 5 bits (<code class="language-plaintext highlighter-rouge">MUX0</code> - <code class="language-plaintext highlighter-rouge">MUX4</code>). So Atmel decided to cram <code class="language-plaintext highlighter-rouge">MUX5</code> into register <code class="language-plaintext highlighter-rouge">ADCSRB</code>:</p> <center> <p><img src="attiny_adc_mux.png" alt="" /></p> <p>Wait, did the <code class="language-plaintext highlighter-rouge">ADLAR</code> bit just move around? Nah, must be an illusion. 😒</p> </center> <p>This memory map comparison tool was vital in understanding how all the AVRs memory maps differ and coming up with strategies on how to map this functionality into our HAL. <a href="https://www.youtube.com/watch?v=KMU0tzLwhbE">It’s all about tools, tools, tools, tools</a>!</p> <h2 id="peeking-into-stm32cubemx"> <a href="#peeking-into-stm32cubemx" class="anchor-head"></a> Peeking into STM32CubeMX </h2> <p>ST maintains the <a href="http://www.st.com/en/development-tools/stm32cubemx.html">CubeMX initialization code generator</a>, which contains “a pinout-conflict solver, a clock-tree setting helper, a power-consumption calculator, and an utility performing MCU peripheral configuration”. Hm, doesn’t that sound interesting? How did they implement these features, we wondered.</p> <p>Back in 2013 CubeMX was still called MicroXplorer and wasn’t nearly as nice to use as today. It also launched as a Windows-only application, even though it was clearly written in Java (those “beautiful” GUI elements give it away). Nevertheless, CubeMX indeed is a very useful application, giving you a number of visual configuration editors:</p> <center> <p><img src="stm32f103_cube_gpio.png" alt="" /></p> <p>Configuring the USART1_TX signal on pin PB6 on the popular STM32F103RBT.</p> </center> <p>During installation, CubeMX kindly unpacks a <em>huge</em> plaintext (!) database to disk at <code class="language-plaintext highlighter-rouge">STM32CubeMX.app/Contents/Resources/db</code> (on OSX) and even updates it for you on every app launch. This database consists out of a lot of XML files, one for every STM32 device in ST’s portfolio, plus detailed descriptions of peripheral configurations. It really is an insane amount of data.</p> <p>So I invite you to join me on a stroll through the colorful fields of XML that power the core of the CubeMX’s configurators. I’ll be using the STM32F103RBT, which is a very popular controller that can be found all ST Links and on the Plue Pill board available on ebay for a few bucks.</p> <h3 id="gpio-alternate-functions"> <a href="#gpio-alternate-functions" class="anchor-head"></a> GPIO Alternate Functions </h3> <p>We start by searching for the unique device identifier <code class="language-plaintext highlighter-rouge">STM32F103RBTx</code> in <code class="language-plaintext highlighter-rouge">mcu/families.xml</code> (which is &gt;30.000 lines long, btw). The minimal information about the device here is used by the parametric search engine in CubeMX.</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Mcu</span> <span class="na">Name=</span><span class="s">"STM32F103R(8-B)Tx"</span> <span class="na">PackageName=</span><span class="s">"LQFP64"</span> <span class="na">RefName=</span><span class="s">"STM32F103RBTx"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Core&gt;</span>ARM Cortex-M3<span class="nt">&lt;/Core&gt;</span>
    <span class="nt">&lt;Frequency&gt;</span>72<span class="nt">&lt;/Frequency&gt;</span>
    <span class="nt">&lt;Ram&gt;</span>20<span class="nt">&lt;/Ram&gt;</span>
    <span class="nt">&lt;Flash&gt;</span>128<span class="nt">&lt;/Flash&gt;</span>
    <span class="nt">&lt;Voltage</span> <span class="na">Max=</span><span class="s">"3.6"</span> <span class="na">Min=</span><span class="s">"2.0"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Current</span> <span class="na">Lowest=</span><span class="s">"1.7"</span> <span class="na">Run=</span><span class="s">"373.0"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Temperature</span> <span class="na">Max=</span><span class="s">"105.0"</span> <span class="na">Min=</span><span class="s">"-40.0"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Peripheral</span> <span class="na">Type=</span><span class="s">"ADC 12-bit"</span> <span class="na">MaxOccurs=</span><span class="s">"16"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Peripheral</span> <span class="na">Type=</span><span class="s">"CAN"</span> <span class="na">MaxOccurs=</span><span class="s">"1"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Peripheral</span> <span class="na">Type=</span><span class="s">"I2C"</span> <span class="na">MaxOccurs=</span><span class="s">"2"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Peripheral</span> <span class="na">Type=</span><span class="s">"RTC"</span> <span class="na">MaxOccurs=</span><span class="s">"1"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Peripheral</span> <span class="na">Type=</span><span class="s">"SPI"</span> <span class="na">MaxOccurs=</span><span class="s">"2"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Peripheral</span> <span class="na">Type=</span><span class="s">"Timer 16-bit"</span> <span class="na">MaxOccurs=</span><span class="s">"4"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Peripheral</span> <span class="na">Type=</span><span class="s">"USART"</span> <span class="na">MaxOccurs=</span><span class="s">"3"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Peripheral</span> <span class="na">Type=</span><span class="s">"USB Device"</span> <span class="na">MaxOccurs=</span><span class="s">"1"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/Mcu&gt;</span>
</code></pre></div></div> <p>Following the <code class="language-plaintext highlighter-rouge">Mcu/@Name</code> leads us to <code class="language-plaintext highlighter-rouge">STM32F103R(8-B)Tx.xml</code> containing what peripherals and how many (<code class="language-plaintext highlighter-rouge">mcu/IP/@InstanceName</code>) as well as what pins exists on this package and where and what alternate functions they can be connected to.</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Core&gt;</span>ARM Cortex-M3<span class="nt">&lt;/Core&gt;</span>
<span class="nt">&lt;Ram&gt;</span>20<span class="nt">&lt;/Ram&gt;</span>
<span class="nt">&lt;Flash&gt;</span>64<span class="nt">&lt;/Flash&gt;</span>
<span class="nt">&lt;Flash&gt;</span>128<span class="nt">&lt;/Flash&gt;</span>
<span class="c">&lt;!-- ... --&gt;</span>
<span class="nt">&lt;IP</span> <span class="na">InstanceName=</span><span class="s">"USART3"</span> <span class="na">Name=</span><span class="s">"USART"</span> <span class="na">Version=</span><span class="s">"sci2_v1_1_Cube"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;IP</span> <span class="na">InstanceName=</span><span class="s">"RCC"</span>    <span class="na">Name=</span><span class="s">"RCC"</span>   <span class="na">Version=</span><span class="s">"STM32F102_rcc_v1_0"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;IP</span> <span class="na">InstanceName=</span><span class="s">"NVIC"</span>   <span class="na">Name=</span><span class="s">"NVIC"</span>  <span class="na">Version=</span><span class="s">"STM32F103G"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;IP</span> <span class="na">InstanceName=</span><span class="s">"GPIO"</span>   <span class="na">Name=</span><span class="s">"GPIO"</span>  <span class="na">Version=</span><span class="s">"STM32F103x8_gpio_v1_0"</span><span class="nt">/&gt;</span>
<span class="c">&lt;!-- ... --&gt;</span>
<span class="nt">&lt;Pin</span> <span class="na">Name=</span><span class="s">"PB5"</span> <span class="na">Position=</span><span class="s">"57"</span> <span class="na">Type=</span><span class="s">"I/O"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Signal</span> <span class="na">Name=</span><span class="s">"I2C1_SMBA"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Signal</span> <span class="na">Name=</span><span class="s">"SPI1_MOSI"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Signal</span> <span class="na">Name=</span><span class="s">"TIM3_CH2"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/Pin&gt;</span>
<span class="nt">&lt;Pin</span> <span class="na">Name=</span><span class="s">"PB6"</span> <span class="na">Position=</span><span class="s">"58"</span> <span class="na">Type=</span><span class="s">"I/O"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Signal</span> <span class="na">Name=</span><span class="s">"I2C1_SCL"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Signal</span> <span class="na">Name=</span><span class="s">"TIM4_CH1"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Signal</span> <span class="na">Name=</span><span class="s">"USART1_TX"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/Pin&gt;</span>
<span class="nt">&lt;Pin</span> <span class="na">Name=</span><span class="s">"PB7"</span> <span class="na">Position=</span><span class="s">"59"</span> <span class="na">Type=</span><span class="s">"I/O"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Signal</span> <span class="na">Name=</span><span class="s">"I2C1_SDA"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Signal</span> <span class="na">Name=</span><span class="s">"TIM4_CH2"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Signal</span> <span class="na">Name=</span><span class="s">"USART1_RX"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/Pin&gt;</span>
</code></pre></div></div> <p>Each peripheral has a <code class="language-plaintext highlighter-rouge">IP/@Version</code>, which leads to a configuration file containing <em>even more</em> data. Don’t cha just love the smell of freshly unpacked data in the morning? For this device’s GPIO peripheral we’ll look for any pins with the <code class="language-plaintext highlighter-rouge">USART1_TX</code> signal in the <code class="language-plaintext highlighter-rouge">mcu/IP/GPIO-STM32F103x8_gpio_v1_0_Modes.xml</code> file:</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;GPIO_Pin</span> <span class="na">PortName=</span><span class="s">"PB"</span> <span class="na">Name=</span><span class="s">"PB6"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;PinSignal</span> <span class="na">Name=</span><span class="s">"USART1_TX"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;RemapBlock</span> <span class="na">Name=</span><span class="s">"USART1_REMAP1"</span><span class="nt">&gt;</span>
           <span class="nt">&lt;SpecificParameter</span> <span class="na">Name=</span><span class="s">"GPIO_AF"</span><span class="nt">&gt;</span>
               <span class="nt">&lt;PossibleValue&gt;</span>__HAL_AFIO_REMAP_USART1_ENABLE<span class="nt">&lt;/PossibleValue&gt;</span>
           <span class="nt">&lt;/SpecificParameter&gt;</span>
        <span class="nt">&lt;/RemapBlock&gt;</span>
    <span class="nt">&lt;/PinSignal&gt;</span>
<span class="nt">&lt;/GPIO_Pin&gt;</span>
<span class="c">&lt;!-- ... --&gt;</span>
<span class="nt">&lt;GPIO_Pin</span> <span class="na">PortName=</span><span class="s">"PA"</span> <span class="na">Name=</span><span class="s">"PA9"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;PinSignal</span> <span class="na">Name=</span><span class="s">"USART1_TX"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;RemapBlock</span> <span class="na">Name=</span><span class="s">"USART1_REMAP0"</span> <span class="na">DefaultRemap=</span><span class="s">"true"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/PinSignal&gt;</span>
<span class="nt">&lt;/GPIO_Pin&gt;</span>
</code></pre></div></div> <p>So <code class="language-plaintext highlighter-rouge">USART1_TX</code> maps to pin PB6 with <code class="language-plaintext highlighter-rouge">USART1_REMAP1</code> or pin PA9 with <code class="language-plaintext highlighter-rouge">USART1_REMAP0</code>. The STM32F1 series remap signals either in (overlapping) groups or not at all. This is controlled by the <code class="language-plaintext highlighter-rouge">AFIO_MAPRx</code> registers, where we can find PB6/PA9 again:</p> <center> <p><img src="stm32f103_usart1_remap.png" alt="" /></p> </center> <p>The <code class="language-plaintext highlighter-rouge">__HAL_AFIO_REMAP_USART1_ENABLE</code> in the XML is actually just a C function name, and is placed by CubeMX in the generated init code.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">HAL_UART_MspInit</span><span class="p">(</span><span class="n">UART_HandleTypeDef</span><span class="o">*</span> <span class="n">huart</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">GPIO_InitTypeDef</span> <span class="n">GPIO_InitStruct</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">huart</span><span class="o">-&gt;</span><span class="n">Instance</span><span class="o">==</span><span class="n">USART1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* Peripheral clock enable */</span>
        <span class="n">__HAL_RCC_USART1_CLK_ENABLE</span><span class="p">();</span>

        <span class="cm">/**USART1 GPIO Configuration
        PB6     ------&gt; USART1_TX
        PB7     ------&gt; USART1_RX
        */</span>
        <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Pin</span> <span class="o">=</span> <span class="n">GPIO_PIN_6</span><span class="p">;</span>
        <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Mode</span> <span class="o">=</span> <span class="n">GPIO_MODE_AF_PP</span><span class="p">;</span>
        <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Speed</span> <span class="o">=</span> <span class="n">GPIO_SPEED_FREQ_HIGH</span><span class="p">;</span>
        <span class="n">HAL_GPIO_Init</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GPIO_InitStruct</span><span class="p">);</span>

        <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Pin</span> <span class="o">=</span> <span class="n">GPIO_PIN_7</span><span class="p">;</span>
        <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Mode</span> <span class="o">=</span> <span class="n">GPIO_MODE_INPUT</span><span class="p">;</span>
        <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Pull</span> <span class="o">=</span> <span class="n">GPIO_NOPULL</span><span class="p">;</span>
        <span class="n">HAL_GPIO_Init</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GPIO_InitStruct</span><span class="p">);</span>

        <span class="n">__HAL_AFIO_REMAP_USART1_ENABLE</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The IP files do contain a very large amount of information, however, it’s mostly directed at the code generation capabilities of the CubeMX project exporter, and as such, not very useful as stand-alone information. For example, the above GPIO signal information relies on the existence of a <code class="language-plaintext highlighter-rouge">__HAL_AFIO_REMAP_USART1_ENABLE()</code> function that performs the remapping. The mapping between the bits in the <code class="language-plaintext highlighter-rouge">AFIO_MAPRx</code> registers and the remap groups is therefore encoded in two separate places: these xml files, and the family’s CubeHAL.</p> <p>The <code class="language-plaintext highlighter-rouge">mcu/IP/NVIC-STM32F103G_Modes.xml</code> configuration file, used to configure the NVIC in the CubeMX, exemplifies this quite well: here we see the first 10 interrupt vectors paired with additional metadata (<code class="language-plaintext highlighter-rouge">PossibleValue/@Value</code> seems to contain some <code class="language-plaintext highlighter-rouge">:</code> separated conditionals for visibility inside the GUI tool).</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;RefParameter</span> <span class="na">Comment=</span><span class="s">"Interrupt Table"</span> <span class="na">Name=</span><span class="s">"IRQn"</span> <span class="na">Type=</span><span class="s">"list"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"Non maskable interrupt"</span> <span class="na">Value=</span><span class="s">"NonMaskableInt_IRQn:N,IF_HAL::HAL_RCC_NMI_IRQHandler:CSSEnabled"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"Hard fault interrupt"</span> <span class="na">Value=</span><span class="s">"HardFault_IRQn:N,W1:::"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"Memory management fault"</span> <span class="na">Value=</span><span class="s">"MemoryManagement_IRQn:Y,W1:::"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"Prefetch fault, memory access fault"</span> <span class="na">Value=</span><span class="s">"BusFault_IRQn:Y,W1:::"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"Undefined instruction or illegal state"</span> <span class="na">Value=</span><span class="s">"UsageFault_IRQn:Y,W1:::"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"System service call via SWI instruction"</span> <span class="na">Value=</span><span class="s">"SVCall_IRQn:Y,RTOS::NONE:"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"Debug monitor"</span> <span class="na">Value=</span><span class="s">"DebugMonitor_IRQn:Y::NONE:"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"Pendable request for system service"</span> <span class="na">Value=</span><span class="s">"PendSV_IRQn:Y,RTOS::NONE:"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"System tick timer"</span> <span class="na">Value=</span><span class="s">"SysTick_IRQn:Y:::"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"Window watchdog interrupt"</span> <span class="na">Value=</span><span class="s">"WWDG_IRQn:Y:WWDG:HAL_WWDG_IRQHandler:"</span><span class="nt">/&gt;</span>
</code></pre></div></div> <p>However, their actual position in the interrupt vector table is missing, and so this data cannot be used to extract a valid interrupt table. Instead an alias is used here to pair the interrupt with its actual table position, as defined in the <a href="https://github.com/modm-io/cmsis-header-stm32/blob/master/stm32f1xx/Include/stm32f103xb.h#L86-L144">STM32F103xB CMSIS header file</a>.</p> <p>For example, the <code class="language-plaintext highlighter-rouge">WWDG</code> interrupt vector is located at position 16 (=16+0), while the <code class="language-plaintext highlighter-rouge">SVCall</code> vector is located at position 11 (=16-5), or 5 positions behind the <code class="language-plaintext highlighter-rouge">UsageFault</code> vector:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cm">/*!&lt; Interrupt Number Definition */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="n">NonMaskableInt_IRQn</span>   <span class="o">=</span> <span class="o">-</span><span class="mi">14</span><span class="p">,</span> <span class="cm">/*!&lt; 2 Non Maskable Interrupt                */</span>
  <span class="n">HardFault_IRQn</span>        <span class="o">=</span> <span class="o">-</span><span class="mi">13</span><span class="p">,</span> <span class="cm">/*!&lt; 3 Cortex-M3 Hard Fault Interrupt        */</span>
  <span class="n">MemoryManagement_IRQn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="cm">/*!&lt; 4 Cortex-M3 Memory Management Interrupt */</span>
  <span class="n">BusFault_IRQn</span>         <span class="o">=</span> <span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="cm">/*!&lt; 5 Cortex-M3 Bus Fault Interrupt         */</span>
  <span class="n">UsageFault_IRQn</span>       <span class="o">=</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="cm">/*!&lt; 6 Cortex-M3 Usage Fault Interrupt       */</span>
  <span class="n">SVCall_IRQn</span>           <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span>  <span class="cm">/*!&lt; 11 Cortex-M3 SV Call Interrupt          */</span>
  <span class="n">DebugMonitor_IRQn</span>     <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span>  <span class="cm">/*!&lt; 12 Cortex-M3 Debug Monitor Interrupt    */</span>
  <span class="n">PendSV_IRQn</span>           <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="cm">/*!&lt; 14 Cortex-M3 Pend SV Interrupt          */</span>
  <span class="n">SysTick_IRQn</span>          <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="cm">/*!&lt; 15 Cortex-M3 System Tick Interrupt      */</span>
  <span class="n">WWDG_IRQn</span>             <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="cm">/*!&lt; Window WatchDog Interrupt               */</span>
  <span class="c1">// ...</span>
<span class="p">}</span> <span class="n">IRQn_Type</span><span class="p">;</span>
</code></pre></div></div> <p>So keep in mind that this data is not meant to be a sensible hardware description format and it just often lacks basic information that would make it much more useful. Then again, the only consumer of this information is supposed to be CubeMX for its fairly narrow goal of code generation.</p> <h3 id="clock-tree"> <a href="#clock-tree" class="anchor-head"></a> Clock Tree </h3> <p>Let’s look at another very interesting data source in CubeMX: the clock configuration wizard:</p> <center> <p><img src="stm32f103_cube_clock.gif" alt="" /></p> </center> <p>What’s so interesting about this configurator is that it <em>knows</em> what the maximum frequencies of the respective clock segments are, and more importantly, how to set the prescalers to resolve these issues and this for every device. You surely know where this is going by know. Yup, it’s backed by data, and here is what it looks like rendered with graphviz.</p> <center> <p><img src="stm32f100_clock.png" alt="" /></p> </center> <p>Here is a beautified excerpt from <code class="language-plaintext highlighter-rouge">plugins/clock/STM32F102.xml</code>, which only shows the connections highlighted in red. Note how the text in the nodes maps to the <code class="language-plaintext highlighter-rouge">Element/@type</code> and <code class="language-plaintext highlighter-rouge">Element/@id</code> attributes, and how the <code class="language-plaintext highlighter-rouge">Element/Output</code> and <code class="language-plaintext highlighter-rouge">Element/Input</code> children declare a (unique) <code class="language-plaintext highlighter-rouge">@signalId</code> and which node they are connecting to:</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Tree</span> <span class="na">id=</span><span class="s">"ClockTree"</span><span class="nt">&gt;</span>
  <span class="c">&lt;!-- HSE --&gt;</span>
  <span class="nt">&lt;Element</span> <span class="na">id=</span><span class="s">"HSEOSC"</span> <span class="na">type=</span><span class="s">"variedSource"</span> <span class="na">refParameter=</span><span class="s">"HSE_VALUE"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">signalId=</span><span class="s">"HSE"</span> <span class="na">to=</span><span class="s">"HSEDivPLL"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/Element&gt;</span>
  <span class="c">&lt;!-- PLL div input from HSE --&gt;</span>
  <span class="nt">&lt;Element</span> <span class="na">id=</span><span class="s">"HSEDivPLL"</span> <span class="na">type=</span><span class="s">"devisor"</span> <span class="na">refParameter=</span><span class="s">"HSEDivPLL"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Input</span> <span class="na">signalId=</span><span class="s">"HSE"</span> <span class="na">from=</span><span class="s">"HSEOSC"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">signalId=</span><span class="s">"HSE_PLL"</span> <span class="na">to=</span><span class="s">"PLLSource"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/Element&gt;</span>
  <span class="nt">&lt;Tree</span> <span class="na">id=</span><span class="s">"PLL"</span><span class="nt">&gt;</span>
    <span class="c">&lt;!-- PLLsource MUX source pour PLL mul --&gt;</span>
    <span class="nt">&lt;Element</span> <span class="na">id=</span><span class="s">"PLLSource"</span> <span class="na">type=</span><span class="s">"multiplexor"</span> <span class="na">refParameter=</span><span class="s">"PLLSourceVirtual"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;Input</span> <span class="na">signalId=</span><span class="s">"HSE_PLL"</span> <span class="na">from=</span><span class="s">"HSEDivPLL"</span> <span class="na">refValue=</span><span class="s">"RCC_PLLSOURCE_HSE"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;Output</span> <span class="na">signalId=</span><span class="s">"VCOInput"</span> <span class="na">to=</span><span class="s">"VCO2output"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/Element&gt;</span>
    <span class="nt">&lt;Element</span> <span class="na">id=</span><span class="s">"VCO2output"</span> <span class="na">type=</span><span class="s">"output"</span> <span class="na">refParameter=</span><span class="s">"VCOOutput2Freq_Value"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;Input</span> <span class="na">signalId=</span><span class="s">"VCOInput"</span> <span class="na">from=</span><span class="s">"PLLSource"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;Output</span> <span class="na">signalId=</span><span class="s">"VCO2Input"</span> <span class="na">to=</span><span class="s">"PLLMUL"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/Element&gt;</span>
    <span class="nt">&lt;Element</span> <span class="na">id=</span><span class="s">"PLLMUL"</span> <span class="na">type=</span><span class="s">"multiplicator"</span> <span class="na">refParameter=</span><span class="s">"PLLMUL"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;Input</span> <span class="na">signalId=</span><span class="s">"VCO2Input"</span> <span class="na">from=</span><span class="s">"VCO2output"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;Output</span> <span class="na">signalId=</span><span class="s">"PLLCLK"</span> <span class="na">to=</span><span class="s">"SysClkSource"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/Element&gt;</span>
  <span class="nt">&lt;/Tree&gt;</span>
  <span class="c">&lt;!--Sysclock mux --&gt;</span>
  <span class="nt">&lt;Element</span> <span class="na">id=</span><span class="s">"SysClkSource"</span> <span class="na">type=</span><span class="s">"multiplexor"</span> <span class="na">refParameter=</span><span class="s">"SYSCLKSource"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Input</span> <span class="na">signalId=</span><span class="s">"PLLCLK"</span> <span class="na">from=</span><span class="s">"PLLMUL"</span> <span class="na">refValue=</span><span class="s">"RCC_SYSCLKSOURCE_PLLCLK"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">signalId=</span><span class="s">"SYSCLK"</span> <span class="na">to=</span><span class="s">"SysCLKOutput"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/Element&gt;</span>
  <span class="nt">&lt;Element</span> <span class="na">id=</span><span class="s">"SysCLKOutput"</span> <span class="na">type=</span><span class="s">"output"</span> <span class="na">refParameter=</span><span class="s">"SYSCLKFreq_VALUE"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Input</span> <span class="na">signalId=</span><span class="s">"SYSCLK"</span> <span class="na">from=</span><span class="s">"SysClkSource"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">signalId=</span><span class="s">"SYSCLKOUT"</span> <span class="na">to=</span><span class="s">"AHBPrescaler"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/Element&gt;</span>
  <span class="c">&lt;!-- AHB input**SYSclock** --&gt;</span>
  <span class="nt">&lt;Element</span> <span class="na">id=</span><span class="s">"AHBPrescaler"</span> <span class="na">type=</span><span class="s">"devisor"</span> <span class="na">refParameter=</span><span class="s">"AHBCLKDivider"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Input</span> <span class="na">signalId=</span><span class="s">"SYSCLKOUT"</span> <span class="na">from=</span><span class="s">"SysCLKOutput"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">signalId=</span><span class="s">"HCLK"</span> <span class="na">to=</span><span class="s">"AHBOutput"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/Element&gt;</span>
  <span class="c">&lt;!-- AHB input**SYSclock** output**FHCLK,HCLK,Diviseurcortex,APB1,APB2 --&gt;</span>
  <span class="nt">&lt;Element</span> <span class="na">id=</span><span class="s">"AHBOutput"</span> <span class="na">type=</span><span class="s">"activeOutput"</span> <span class="na">refParameter=</span><span class="s">"HCLKFreq_Value"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Input</span> <span class="na">signalId=</span><span class="s">"HCLK"</span> <span class="na">from=</span><span class="s">"AHBPrescaler"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">to=</span><span class="s">"FCLKCortexOutput"</span> <span class="na">signalId=</span><span class="s">"AHBCLK"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">to=</span><span class="s">"FSMClkOutput"</span> <span class="na">signalId=</span><span class="s">"AHBCLK"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">to=</span><span class="s">"SDIOClkOutput"</span> <span class="na">signalId=</span><span class="s">"AHBCLK"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">to=</span><span class="s">"HCLKDiv2"</span> <span class="na">signalId=</span><span class="s">"AHBCLK"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">to=</span><span class="s">"HCLKOutput"</span> <span class="na">signalId=</span><span class="s">"AHBCLK"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">to=</span><span class="s">"TimSysPresc"</span> <span class="na">signalId=</span><span class="s">"AHBCLK"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">to=</span><span class="s">"APB1Prescaler"</span> <span class="na">signalId=</span><span class="s">"AHBCLK"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Output</span> <span class="na">to=</span><span class="s">"APB2Prescaler"</span> <span class="na">signalId=</span><span class="s">"AHBCLK"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/Element&gt;</span>
<span class="nt">&lt;/Tree&gt;</span>
</code></pre></div></div> <p>We still don’t know how CubeMX is able to do it actual calculations, because the clock graph above doesn’t contain any numbers at all. Some digging around later we can trace the <code class="language-plaintext highlighter-rouge">Element/@refParameter</code> attribute to the <code class="language-plaintext highlighter-rouge">IP/RCC-STM32F102_rcc_v1_0_Modes.xml</code> which contains *drumroll* numbers, and lots of ‘em:</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- Les frequences des sources --&gt;</span>
<span class="nt">&lt;RefParameter</span> <span class="na">Name=</span><span class="s">"HSE_VALUE"</span> <span class="na">Min=</span><span class="s">"4000000"</span> <span class="na">Max=</span><span class="s">"16000000"</span> <span class="na">Display=</span><span class="s">"value/1000000"</span> <span class="na">Unit=</span><span class="s">"MHz"</span><span class="nt">/&gt;</span>
<span class="c">&lt;!-- frequence PLL --&gt;</span>
<span class="nt">&lt;RefParameter</span> <span class="na">Name=</span><span class="s">"VCOOutput2Freq_Value"</span> <span class="na">Min=</span><span class="s">"1000000"</span> <span class="na">Max=</span><span class="s">"25000000"</span> <span class="na">Display=</span><span class="s">"value/1000000"</span> <span class="na">Unit=</span><span class="s">"MHz"</span><span class="nt">/&gt;</span>
<span class="c">&lt;!-- les diviseurs --&gt;</span>
<span class="nt">&lt;RefParameter</span> <span class="na">Name=</span><span class="s">"HSEDivPLL"</span> <span class="na">DefaultValue=</span><span class="s">"RCC_HSE_PREDIV_DIV1"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"1"</span> <span class="na">Value=</span><span class="s">"RCC_HSE_PREDIV_DIV1"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"2"</span> <span class="na">Value=</span><span class="s">"RCC_HSE_PREDIV_DIV2"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/RefParameter&gt;</span>
<span class="c">&lt;!-- Les multiplicateurs --&gt;</span>
<span class="nt">&lt;RefParameter</span> <span class="na">Name=</span><span class="s">"PLLMUL"</span> <span class="na">DefaultValue=</span><span class="s">"RCC_PLL_MUL2"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"2"</span> <span class="na">Value=</span><span class="s">"RCC_PLL_MUL2"</span><span class="nt">/&gt;</span>
  <span class="c">&lt;!-- ... --&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"16"</span> <span class="na">Value=</span><span class="s">"RCC_PLL_MUL16"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/RefParameter&gt;</span>
<span class="c">&lt;!-- Les frequences des signaux --&gt;</span>
<span class="c">&lt;!-- SYS clock freq de l'output --&gt;</span>
<span class="nt">&lt;RefParameter</span> <span class="na">Name=</span><span class="s">"SYSCLKFreq_VALUE"</span> <span class="na">Max=</span><span class="s">"72000000"</span> <span class="na">Display=</span><span class="s">"value/1000000"</span> <span class="na">Unit=</span><span class="s">"MHz"</span><span class="nt">/&gt;</span>
<span class="c">&lt;!-- diviseur AHB 1..512 --&gt;</span>
<span class="nt">&lt;RefParameter</span>  <span class="na">Name=</span><span class="s">"AHBCLKDivider"</span> <span class="na">DefaultValue=</span><span class="s">"RCC_SYSCLK_DIV1"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"1"</span> <span class="na">Value=</span><span class="s">"RCC_SYSCLK_DIV1"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"2"</span> <span class="na">Value=</span><span class="s">"RCC_SYSCLK_DIV2"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"4"</span> <span class="na">Value=</span><span class="s">"RCC_SYSCLK_DIV4"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"8"</span> <span class="na">Value=</span><span class="s">"RCC_SYSCLK_DIV8"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"16"</span> <span class="na">Value=</span><span class="s">"RCC_SYSCLK_DIV16"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"64"</span> <span class="na">Value=</span><span class="s">"RCC_SYSCLK_DIV64"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"128"</span> <span class="na">Value=</span><span class="s">"RCC_SYSCLK_DIV128"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"256"</span> <span class="na">Value=</span><span class="s">"RCC_SYSCLK_DIV256"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;PossibleValue</span> <span class="na">Comment=</span><span class="s">"512"</span> <span class="na">Value=</span><span class="s">"RCC_SYSCLK_DIV512"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/RefParameter&gt;</span>
<span class="c">&lt;!-- AHB out freq --&gt;</span>
<span class="nt">&lt;RefParameter</span> <span class="na">Name=</span><span class="s">"HCLKFreq_Value"</span> <span class="na">Max=</span><span class="s">"72000000"</span> <span class="na">Display=</span><span class="s">"value/1000000"</span> <span class="na">Unit=</span><span class="s">"MHz"</span><span class="nt">/&gt;</span>
</code></pre></div></div> <p>Did you know that ST is a French-Italian company? Cos those XML comments clearly aren’t in English. 🤔 Well, that and they seem keen on calling it a “devisor” when they really mean “divider”. What is this, I don’t even.</p> <center> <p><img src="not_anything_wrong.gif" alt="" /></p> <p>French comments in XML</p> </center> <p>Anyways, here you can see the <code class="language-plaintext highlighter-rouge">RefParameter/@min</code> and <code class="language-plaintext highlighter-rouge">RefParameter/@max</code> frequency values as well as prescaler values encoded as <code class="language-plaintext highlighter-rouge">PossibleValue/@Comment</code>, which are all used by CubeMX to check and fix your clock tree. That’s pretty amazing actually.</p> <p>Ok, so I’m not going into the data of their board support packages, because I don’t think any health insurance covers this much exposure to XML, especially not XML containing French comments. But feel free to take a look at your own risk, it’s just waiting there in <code class="language-plaintext highlighter-rouge">plugins/boardmanager/boards</code> for your prying eyes.</p> <p>Let’s move on to how we can extract this data programmatically and use it to bring order to chaos, one example at a time. A bit like the Avengers franchise *drags out blog post to infinity*</p> <h2 id="generating-device-files"> <a href="#generating-device-files" class="anchor-head"></a> Generating Device Files </h2> <p>The goal of finding machine-readable device description data obviously was to write a program to import, clean-up and convert it into a format that’s more agreeable to our use-case of generating a HAL. Ironically the Device File Generator (DFG) started out in mid 2013 with the innocently named commit <a href="https://github.com/roboterclubaachen/xpcc/commit/1532289">“Cheap and simple parsing of the XML files”</a>. It’s not cheap and simple anymore.</p> <p>The DFG started out as a glorified <a href="https://en.wikipedia.org/wiki/XPath">XPath</a> wrapper in xpcc, but then quickly devolved into some messy monster, that pulled in data from all over the place and arranged it without much concept. Back then we were busy building porting the HAL, writing sensor drivers and building robots, so we didn’t approach this problem structurally, and rather fixed bugs when they occurred.</p> <p>I won’t talk about xpcc’s DFG architecture issues in detail, instead I’ll be showing you the problems it caused us. This way, the lessons learned are more transferable to other format (*cough* Device Tree *cough*), since the device data is immutable whereas the DFG’s architecture is not.</p> <p>Note that I rewrote the DFG from scratch for modm, so <a href="https://github.com/modm-io/modm-devices">you can have a look at the source code</a> while reading this. I’m continuing to use the STM32F103RBT6 for illustration, but this all works very similarly for all STM32 and AVR devices.</p> <h3 id="device-identifiers"> <a href="#device-identifiers" class="anchor-head"></a> Device Identifiers </h3> <p>We needed a way to identify what device to build our HAL for, and of course we use the manufacturers identifier, since it’s (hopefully) unique. We also needed to split up the identifier string, so that the HAL can query its traits to select what code templates to use. For example, in xpcc we split <code class="language-plaintext highlighter-rouge">stm32f103rbt6</code> into:</p> <center> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   stm32     f1     103     r       b    ​
{platform}{family}{name}{pin-id}{size-id}
</code></pre></div> </div> </center> <p>Note how we forgot the <code class="language-plaintext highlighter-rouge">t6</code> suffix. If we compare this with the documentation on the ST ordering information scheme, you’ll see why this was a huge mistake:</p> <center> <p><img src="stm32f1_ordering_info_scheme.png" width="75%" /></p> </center> <p>Yup, that’s right, we forgot to encode the package type, causing the DFG to select the first device matching <code class="language-plaintext highlighter-rouge">STM32F103RB</code>! And that would be the <code class="language-plaintext highlighter-rouge">STM32F103RBHx</code> device, since it occurs first in <code class="language-plaintext highlighter-rouge">families.xml</code>.</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Mcu</span> <span class="na">Name=</span><span class="s">"STM32F103R(8-B)Hx"</span> <span class="na">PackageName=</span><span class="s">"TFBGA64"</span> <span class="na">RefName=</span><span class="s">"STM32F103RBHx"</span><span class="nt">&gt;</span>
<span class="c">&lt;!-- ... --&gt;</span>
<span class="nt">&lt;Mcu</span> <span class="na">Name=</span><span class="s">"STM32F103R(8-B)Tx"</span> <span class="na">PackageName=</span><span class="s">"LQFP64"</span>  <span class="na">RefName=</span><span class="s">"STM32F103RBTx"</span><span class="nt">&gt;</span>
</code></pre></div></div> <p>So we actually used the definitions for the TFBGA64 packaged device instead of the LQFP64 packaged device. 🤦‍ Incredibly this didn’t cause immediate problems, since we first focussed on the STM32F3 and F4 families, whose functionality is almost identical between packages.</p> <p>However, we did notice some changes when a new version of CubeMX was released which added or reordered devices in <code class="language-plaintext highlighter-rouge">families.xml</code>. And then all hell broke loose when I added support for parsing the STM32F1 device family, which couples peripheral features to memory size <em>and(!)</em> pin count:</p> <center> <p><img src="stm32f1_feature_package.png" width="80%" /><br /> “32 KB Flash<sup>(1)</sup>” aka. this table isn’t complicated enough already</p> </center> <p>If you’re a hardware engineer at $vendor, <em>PLEASE DON’T DO THIS!</em> This is pure punishment for anyone writing software for these chips. <strong>PLEASE DO NOT DO THIS!</strong> You should not have to query for <em>combinations</em> of identifier traits to get your hardware feature set. Expand your device lineup into new (orthogonal) identifier space instead.</p> <center> <p><img src="not_like_this.gif" alt="" /></p> </center> <p>To be fair, the STM32F1 family was the first ST product to feature a Cortex-M processor and they didn’t use this approach for any of their other STM32 families. I forgive you, ST.</p> <p>So for modm I looked very carefully at how to split the identifier into traits. I made the trait composition and naming transparent to the DFG, it only operates on a dictionary of items, sharing the same identifier mechanism with the AVRs. Since we currently don’t have any information that depends on the temperature range, I left it out for now. Similarly, the device revision is not considered either.</p> <center> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   stm32     f1     03    r     b      t    ​
{platform}{family}{name}{pin}{size}{package}
</code></pre></div> </div> </center> <p>Note how both the xpcc and modm identifier encodings differ from the official ST ordering scheme. Since we are sharing some code across vendors (like the Cortex-M startup code), we need to have a common naming scheme, at least for <code class="language-plaintext highlighter-rouge">{platform}</code> and <code class="language-plaintext highlighter-rouge">{family}</code> or the equivalent for other vendors.</p> <p>Also note that <code class="language-plaintext highlighter-rouge">{name}</code> now does not contain part the trailing <code class="language-plaintext highlighter-rouge">1</code> of the family. This is to prevent the problem in xpcc where the code template authors only checked for the <code class="language-plaintext highlighter-rouge">{name}</code> instead of the <code class="language-plaintext highlighter-rouge">{family}</code> <em>and</em> <code class="language-plaintext highlighter-rouge">{name}</code>, for example, <code class="language-plaintext highlighter-rouge">id["name"] == "103"</code> vs. <code class="language-plaintext highlighter-rouge">id["family"] == "f1" and id["name"] == "03"</code>. This lead to issues when we ported some peripheral drivers to the <code class="language-plaintext highlighter-rouge">L1</code> family (similar to <code class="language-plaintext highlighter-rouge">F0/L0</code>, <code class="language-plaintext highlighter-rouge">F4/L4</code> and <code class="language-plaintext highlighter-rouge">F7/H7</code>).</p> <h3 id="encoding-commonality"> <a href="#encoding-commonality" class="anchor-head"></a> Encoding Commonality </h3> <p>You’ve undoubtedly already noticed that the AVR and CubeMX data is quite verbose and noisy. We didn’t want to use this data directly, hence the DFG. However, we wanted to go a step further and cut down on duplicated data, so that we have an easier time verifying the output of the DFG by not having to look through <em>thousands</em> of files, but rather <em>dozens</em>.</p> <p>At the time of this writing, <code class="language-plaintext highlighter-rouge">families.xml</code> contains 1171 STM32 devices, but <a href="https://github.com/modm-io/modm-devices/tree/5d5285ae1b6e889676b6d04a653d26977bf127e8/devices/stm32"><code class="language-plaintext highlighter-rouge">modm-devices/devices/stm32</code></a> only contains 62 device files, that’s ~19x less files than devices.</p> <p>We observed that ST clusters their devices on their website, in their technical documentation and in their software offerings. The coarsest regular cluster pattern is the family, which denotes the type of Cortex-M code used among other features. The subfamilies are then more or less arbitrarily clustered around whatever combination of functionality ST wanted to bring to market, but the cluster patterns of pin count, memory size and package are <em>very</em> regular and often explicitly called out. We wanted to reflect this in our data structure too.</p> <center> <p><img src="stm32f4x9_clusters.jpg" alt="" /><br /> This <a href="http://www.st.com/en/microcontrollers/stm32f469-479.html">STM32F4x9 feature matrix</a> is extremely regular.</p> </center> <p>The Device Tree format deals with data duplication by allowing data specialization through an inheritance tree and tree inclusion nodes. However, you still have to create one leaf node for every device, so in the best case you’d have one DT per device, or if you moved common data up the inheritance tree, you’d have more files than devices.</p> <p>We decided instead to <em>merge</em> our data trees for devices within similar enough clusters and then filter out the data for <em>one</em> device on access. We use logical OR (<code class="language-plaintext highlighter-rouge">|</code>) to combine identifier traits to declare what devices are merged. You’ll recognize the <code class="language-plaintext highlighter-rouge">&lt;naming-schema&gt;</code> from the previous chapter:</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;device</span> <span class="na">platform=</span><span class="s">"stm32"</span> <span class="na">family=</span><span class="s">"f1"</span> <span class="na">name=</span><span class="s">"03"</span> <span class="na">pin=</span><span class="s">"c|r|t|v"</span> <span class="na">size=</span><span class="s">"8|b"</span> <span class="na">package=</span><span class="s">"h|i|t|u"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;naming-schema&gt;</span>{platform}{family}{name}{pin}{size}{package}<span class="nt">&lt;/naming-schema&gt;</span>
  <span class="nt">&lt;valid-device&gt;</span>stm32f103c8t<span class="nt">&lt;/valid-device&gt;</span>
  <span class="c">&lt;!-- ... --&gt;</span>
  <span class="nt">&lt;valid-device&gt;</span>stm32f103rbt<span class="nt">&lt;/valid-device&gt;</span>
</code></pre></div></div> <p><a href="https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/devices/stm32/stm32f1-03-8_b.xml">This device file for the F103x8/b devices</a> therefore contains all that match the identifier pattern of <code class="language-plaintext highlighter-rouge">r"stm32f103[crtv][8b][hitu]"</code>. <a href="https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/tools/device/modm/device_file.py#L33-L51">The engine extracting the data set for a single device</a> will first construct a list of all possible identifier strings via the naming schema and the <code class="language-plaintext highlighter-rouge">device</code> combinations: 4*2*4 = 32 identifiers in this example. It then filters these identifiers by the list in <code class="language-plaintext highlighter-rouge">&lt;valid-device&gt;</code>, since not every combination actually exists. Whatever device file contains the requested identifier string is then used.</p> <p>The identifier schema does not have to include all traits either, it only has to be unambiguous. For example the AVR device identifier schema does not contain <code class="language-plaintext highlighter-rouge">{platform}</code> but we can infer it anyways:</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;device</span> <span class="na">platform=</span><span class="s">"avr"</span> <span class="na">family=</span><span class="s">"mega"</span> <span class="na">name=</span><span class="s">"48|88|168|328"</span> <span class="na">type=</span><span class="s">"|a|p|pa"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;naming-schema&gt;</span>at{family}{name}{type}<span class="nt">&lt;/naming-schema&gt;</span>
</code></pre></div></div> <p>It first seems unnecessary to do this reverse lookup, but it gives us a very important property for free: The extractor does not need to <em>know</em> anything about the identifier, and still understands the mapping of string to traits. So passing <code class="language-plaintext highlighter-rouge">stm32f103rbt</code> is now <em>understood</em> as <code class="language-plaintext highlighter-rouge">stm32 f1 03 r b t</code>. The disadvantage is having to first build all identifier strings, before returning the corresponding device file. However, this mapping can be cached.</p> <p>The device file can now use the traits as filters by prefixing them with <code class="language-plaintext highlighter-rouge">device-</code>. For our example, the device file continues with declaring the core driver instance, which contains the memory map and vector table. The devices here only differ in Flash size, otherwise they are identical:</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;driver</span> <span class="na">name=</span><span class="s">"core"</span> <span class="na">type=</span><span class="s">"cortex-m3"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;memory</span> <span class="na">device-size=</span><span class="s">"8"</span> <span class="na">name=</span><span class="s">"flash"</span> <span class="na">access=</span><span class="s">"rx"</span> <span class="na">start=</span><span class="s">"0x8000000"</span> <span class="na">size=</span><span class="s">"65536"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;memory</span> <span class="na">device-size=</span><span class="s">"b"</span> <span class="na">name=</span><span class="s">"flash"</span> <span class="na">access=</span><span class="s">"rx"</span> <span class="na">start=</span><span class="s">"0x8000000"</span> <span class="na">size=</span><span class="s">"131072"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;memory</span> <span class="na">name=</span><span class="s">"sram1"</span> <span class="na">access=</span><span class="s">"rwx"</span> <span class="na">start=</span><span class="s">"0x20000000"</span> <span class="na">size=</span><span class="s">"20480"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;vector</span> <span class="na">position=</span><span class="s">"0"</span> <span class="na">name=</span><span class="s">"WWDG"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;vector</span> <span class="na">position=</span><span class="s">"1"</span> <span class="na">name=</span><span class="s">"PVD"</span><span class="nt">/&gt;</span>
  <span class="c">&lt;!-- ... --&gt;</span>
  <span class="nt">&lt;vector</span> <span class="na">position=</span><span class="s">"42"</span> <span class="na">name=</span><span class="s">"USBWakeUp"</span><span class="nt">/&gt;</span>
</code></pre></div></div> <p>By applying some simple combinatorics math we can find the minimal trait set that uniquely describes this difference and can push this filter as far up the data tree as possible while still being unambiguous and therefore losslessly reconstructible for all merged device data. This is all done for the sole purpose of optimizing for human readability, so an embedded engineer with some experience can just look at this data and say: “This filter looks too noisy to me, so something is probably is wrong here” 🤓 *sound of datasheet pages flipping*.</p> <p>Here is an example of what I so dramatically complained about before: The STM32F1 peripheral feature set is coupled to the device’s pin count: F103 devices with just <a href="https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/devices/stm32/stm32f1-03-8_b.xml#L68-L109">36 pins have fewer instances of these peripherals</a>:</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;driver</span> <span class="na">name=</span><span class="s">"i2c"</span> <span class="na">type=</span><span class="s">"stm32"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;instance</span> <span class="na">value=</span><span class="s">"1"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;instance</span> <span class="na">device-pin=</span><span class="s">"c|r|v"</span> <span class="na">value=</span><span class="s">"2"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/driver&gt;</span>
<span class="nt">&lt;driver</span> <span class="na">name=</span><span class="s">"spi"</span> <span class="na">type=</span><span class="s">"stm32"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;instance</span> <span class="na">value=</span><span class="s">"1"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;instance</span> <span class="na">device-pin=</span><span class="s">"c|r|v"</span> <span class="na">value=</span><span class="s">"2"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/driver&gt;</span>
<span class="nt">&lt;driver</span> <span class="na">name=</span><span class="s">"usart"</span> <span class="na">type=</span><span class="s">"stm32"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;instance</span> <span class="na">value=</span><span class="s">"1"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;instance</span> <span class="na">value=</span><span class="s">"2"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;instance</span> <span class="na">device-pin=</span><span class="s">"c|r|v"</span> <span class="na">value=</span><span class="s">"3"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/driver&gt;</span>
</code></pre></div></div> <p>Of course both the pin count and the package influence the number of available GPIOs and signals. The algorithm here detected that using the pin count as a filter is enough to safely reconstruct the tree, so the <code class="language-plaintext highlighter-rouge">device-package</code> is missing (it prioritizes traits further “left” in the identifier):</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;driver</span> <span class="na">name=</span><span class="s">"gpio"</span> <span class="na">type=</span><span class="s">"stm32-f1"</span><span class="nt">&gt;</span>
  <span class="c">&lt;!-- ... --&gt;</span>
  <span class="nt">&lt;gpio</span> <span class="na">device-pin=</span><span class="s">"r|v"</span> <span class="na">port=</span><span class="s">"c"</span> <span class="na">pin=</span><span class="s">"10"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;gpio</span> <span class="na">device-pin=</span><span class="s">"r|v"</span> <span class="na">port=</span><span class="s">"c"</span> <span class="na">pin=</span><span class="s">"11"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;signal</span> <span class="na">driver=</span><span class="s">"adc"</span> <span class="na">instance=</span><span class="s">"1"</span> <span class="na">name=</span><span class="s">"exti11"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;signal</span> <span class="na">driver=</span><span class="s">"adc"</span> <span class="na">instance=</span><span class="s">"2"</span> <span class="na">name=</span><span class="s">"exti11"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/gpio&gt;</span>
  <span class="nt">&lt;gpio</span> <span class="na">device-pin=</span><span class="s">"r|v"</span> <span class="na">port=</span><span class="s">"c"</span> <span class="na">pin=</span><span class="s">"12"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;gpio</span> <span class="na">device-pin=</span><span class="s">"c|r|v"</span> <span class="na">port=</span><span class="s">"c"</span> <span class="na">pin=</span><span class="s">"13"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;signal</span> <span class="na">driver=</span><span class="s">"rtc"</span> <span class="na">name=</span><span class="s">"out"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;signal</span> <span class="na">driver=</span><span class="s">"rtc"</span> <span class="na">name=</span><span class="s">"tamper"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/gpio&gt;</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">device-</code> filter traits are ORed, multiple filters on the same node ANDed, and the nodes themselves ORed together again. Keen observers will point out that this can create overly broad filters which would make for incorrect reconstruction. For these cases we have to create two nodes with the same data, but different filters to avoid ambiguity. Here is an example from <a href="https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/devices/stm32/stm32f4-27_29_37_39.xml#L586-L587">the STM32F4{27,29,37,39} device file</a>:</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nt">&lt;gpio</span> <span class="na">port=</span><span class="s">"c"</span> <span class="na">pin=</span><span class="s">"3"</span><span class="nt">&gt;</span>
    <span class="c">&lt;!-- ... --&gt;</span>
    <span class="nt">&lt;signal</span> <span class="na">device-name=</span><span class="s">"27|37"</span> <span class="na">device-pin=</span><span class="s">"a|i|v|z"</span>   <span class="na">af=</span><span class="s">"12"</span> <span class="na">driver=</span><span class="s">"fmc"</span> <span class="na">name=</span><span class="s">"sdcke0"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;signal</span> <span class="na">device-name=</span><span class="s">"29|39"</span> <span class="na">device-pin=</span><span class="s">"a|b|i|n|z"</span> <span class="na">af=</span><span class="s">"12"</span> <span class="na">driver=</span><span class="s">"fmc"</span> <span class="na">name=</span><span class="s">"sdcke0"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/gpio&gt;</span>
</code></pre></div></div> <p>Hm, but that filter does look suspiciously noisy, doesn’t it? This filter pattern is repeated for the <a href="https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/devices/stm32/stm32f4-27_29_37_39.xml#L457-L458"><code class="language-plaintext highlighter-rouge">sdne[1:0]</code></a> and <a href="https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/devices/stm32/stm32f4-27_29_37_39.xml#L558-L559"><code class="language-plaintext highlighter-rouge">sdnwe</code></a> signals, which all belong to the SDRAM controller in the FMC. And according to this data set they seem to be unavailable for the LQFP100 package? Hm, better <del>call Saul</del> check the datasheets:</p> <center> <p><img src="stm32f4xx_fmc_sdcke0.png" width="65%" /></p> <p><img src="stm32f4xx_fmc_sdcke0_af.png" alt="" /> Huh, but the signals <em>do</em> exist for the LQFP100 package!?</p> <p><img src="stm32f4xx_fmc_100.png" alt="" /> “FMC: Yes<sup>(1)</sup>”. Oh, FFS!</p> </center> <p>I checked with CubeMX and the GPIO configurator doesn’t allow you to set SDRAM signals in the LQFP100 package, and there are no <code class="language-plaintext highlighter-rouge">STM32F4[23]7[BN]</code> devices, so everything is fine, I guess? Nothing to see here folks, move along, the filter algorithm encoded this shit correctly. 🙃</p> <center> <p><img src="do_not_want.gif" width="30%" /></p> </center> <p>Anyways, I like our device file format a lot, since it describes the device’s hardware in such a compact and concise form. However, it doesn’t scale graciously at all for data that shares less commonalities between devices in the current clusters.</p> <h3 id="data-pipeline"> <a href="#data-pipeline" class="anchor-head"></a> Data Pipeline </h3> <p>For my rewrite of the DFG for modm I wanted to improve the correctness of device merges, remove device specific knowledge as much as possible, support multiple output formats and rename less data. I’ve already hinted at solutions to some of these in the previous chapters, so let’s have a proper look at them now.</p> <center> <p><img src="dfg_architecture.png" alt="" /></p> </center> <p>The DFG has three parts: frontend, optimizer and backend. Here yellow stands for <span style="background-color:rgb(255,255,202);">input data</span>, blue for <span style="background-color:rgb(192,217,254);">data conversion</span>, red for <span style="background-color:rgb(250,202,199);">intermediate representation (IR)</span> and green for <span style="background-color:rgb(211,234,205);">output data</span>. I’ve already covered the vendor input data and the device merging in much detail.</p> <p><a href="https://github.com/modm-io/modm-devices/blob/8d38650186764c879309fd946b29e94821e6579d/tools/generator/dfg/stm32/stm_device_tree.py#L42-L345">All the ugly is in the parser</a>, it reads the CubeMX data in the same manner I’ve described previously, performs plausibility and format checks on it, and finally normalizes it into a simple Python dictionary. This is just mostly mind-numbingly stupid code to write, since you have to XPath query the CubeMX sources, deal with all the edge cases in the results and normalize all data relative to all devices. Ugly to write, ugly to read, but it gets the job done.</p> <p>Additional curated data gets injected in this step too. The CubeMX data contains a hardware IP version, which seems to correlate loosely to the peripherals feature set, however, I didn’t find it very useful to distinguish between them. So instead I looked up how all peripherals work in the documentation and <a href="https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/tools/generator/dfg/stm32/stm_peripherals.py#L298-L325">grouped them again manually</a>. The device file <code class="language-plaintext highlighter-rouge">driver/@type</code> name comes from this data.</p> <p>For example, here we can see that the entire STM32 platform only has three different I<sup>2</sup>C hardware implementations, one of which only differs with the addition of a digital noise filter.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">'i2c'</span><span class="p">:</span> <span class="p">[{</span>
    <span class="s">'instances'</span><span class="p">:</span> <span class="s">'*'</span><span class="p">,</span>
    <span class="s">'groups'</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="c1"># This hardware can go up to 1MHz (Fast Mode Plus)
</span>            <span class="s">'hardware'</span><span class="p">:</span> <span class="s">'stm32-extended'</span><span class="p">,</span>
            <span class="s">'features'</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s">'devices'</span><span class="p">:</span> <span class="p">[{</span><span class="s">'family'</span><span class="p">:</span> <span class="p">[</span><span class="s">'f0'</span><span class="p">,</span> <span class="s">'f3'</span><span class="p">,</span> <span class="s">'f7'</span><span class="p">]}]</span>
        <span class="p">},{</span>
            <span class="s">'hardware'</span><span class="p">:</span> <span class="s">'stm32l4'</span><span class="p">,</span>
            <span class="s">'features'</span><span class="p">:</span> <span class="p">[</span><span class="s">'dnf'</span><span class="p">],</span>
            <span class="s">'devices'</span><span class="p">:</span> <span class="p">[{</span><span class="s">'family'</span><span class="p">:</span> <span class="p">[</span><span class="s">'l4'</span><span class="p">]}]</span>
        <span class="p">},{</span>
            <span class="c1"># Some F4 have a digital noise filter
</span>            <span class="s">'hardware'</span><span class="p">:</span> <span class="s">'stm32'</span><span class="p">,</span>
            <span class="s">'features'</span><span class="p">:</span> <span class="p">[</span><span class="s">'dnf'</span><span class="p">],</span>
            <span class="s">'devices'</span><span class="p">:</span> <span class="p">[{</span><span class="s">'family'</span><span class="p">:</span> <span class="p">[</span><span class="s">'f4'</span><span class="p">],</span> <span class="s">'name'</span><span class="p">:</span> <span class="p">[</span><span class="s">'27'</span><span class="p">,</span> <span class="s">'29'</span><span class="p">,</span> <span class="s">'37'</span><span class="p">,</span> <span class="s">'39'</span><span class="p">,</span> <span class="s">'46'</span><span class="p">,</span> <span class="s">'69'</span><span class="p">,</span> <span class="s">'79'</span><span class="p">]}]</span>
        <span class="p">},{</span>
            <span class="s">'hardware'</span><span class="p">:</span> <span class="s">'stm32'</span><span class="p">,</span>
            <span class="s">'features'</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s">'devices'</span><span class="p">:</span> <span class="s">'*'</span>
        <span class="p">}</span>
    <span class="p">]</span>
<span class="p">}]</span>
</code></pre></div></div> <p>All names of peripherals, instances, signals are preserved as they are, so that the name matches the documentation. The only exception are names that wouldn’t be valid identifiers in most programming languages. For our STM32F103RBT example, we split up and duplicate these system signals:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SYS_JTCK-SWCLK    =&gt; sys.jtck + sys.swclk
SYS_JTDO-TRACESWO =&gt; sys.jtdo + sys.traceswo
SYS_JTMS-SWDIO    =&gt; sys.jtms + sys.swdio
</code></pre></div></div> <p>The dictionary returned by the parser is then passed onto <a href="https://github.com/modm-io/modm-devices/blob/8d38650186764c879309fd946b29e94821e6579d/tools/generator/dfg/stm32/stm_device_tree.py#L360-L487">a platform specific converter</a> that transforms it into the DFGs intermediate representation. Here the raw data is formatted into a glorified tree structure, which has similar semantics to a very restricted form of XML (ie. attributes are stored separately from its children) and annotates each node with the device’s identifier.</p> <p>Here the memory maps and the interrupt vector table is added to the <code class="language-plaintext highlighter-rouge">name="core"</code> driver node we saw before. The raw data already contains the memories and vectors with the right naming scheme, so it’s easy to just add them here.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">p</span><span class="p">[</span><span class="s">"memories"</span><span class="p">]:</span>
    <span class="n">memory_node</span> <span class="o">=</span> <span class="n">core_driver</span><span class="p">.</span><span class="n">addChild</span><span class="p">(</span><span class="s">"memory"</span><span class="p">)</span>
    <span class="n">memory_node</span><span class="p">.</span><span class="n">setAttributes</span><span class="p">([</span><span class="s">"name"</span><span class="p">,</span> <span class="s">"access"</span><span class="p">,</span> <span class="s">"start"</span><span class="p">,</span> <span class="s">"size"</span><span class="p">],</span> <span class="n">section</span><span class="p">)</span>
<span class="k">for</span> <span class="n">vector</span> <span class="ow">in</span> <span class="n">p</span><span class="p">[</span><span class="s">"interrupts"</span><span class="p">]:</span>
    <span class="n">vector_node</span> <span class="o">=</span> <span class="n">core_driver</span><span class="p">.</span><span class="n">addChild</span><span class="p">(</span><span class="s">"vector"</span><span class="p">)</span>
    <span class="n">vector_node</span><span class="p">.</span><span class="n">setAttributes</span><span class="p">([</span><span class="s">"position"</span><span class="p">,</span> <span class="s">"name"</span><span class="p">],</span> <span class="n">vector</span><span class="p">)</span>

<span class="c1"># sort the node children by start address and size
</span><span class="n">core_driver</span><span class="p">.</span><span class="n">addSortKey</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s">"start"</span><span class="p">],</span> <span class="mi">16</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s">"size"</span><span class="p">]))</span>
                                 <span class="k">if</span> <span class="n">e</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">"memory"</span> <span class="k">else</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="c1"># sort the node children by vector number and name
</span><span class="n">core_driver</span><span class="p">.</span><span class="n">addSortKey</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s">"position"</span><span class="p">]),</span> <span class="n">e</span><span class="p">[</span><span class="s">"name"</span><span class="p">])</span>
                                 <span class="k">if</span> <span class="n">e</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">"vector"</span> <span class="k">else</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s">""</span><span class="p">))</span>
</code></pre></div></div> <p>I’m adding two sort keys to the core driver node here, to bring the entire tree into canonical order. This an absolute requirement for the reproducibility of the results, otherwise I wouldn’t be able to tell what data changed if the line order came out differently on each invocation.</p> <p>It’s time to merge the device IRs now. The device clustering is curated manually, by <a href="https://github.com/modm-io/modm-devices/blob/5d5285ae1b6e889676b6d04a653d26977bf127e8/tools/generator/dfg/stm32/stm_groups.py">a large list of identifier trait groups</a>. I considered using some kind of heuristic to automate this, but this works really well, particularly for the AVR and STM32F1 devices. It’s difficult to come up with a metric that accurately describes how annoyed I feel when looking at wrongfully merged device files with lotsa noisy filters. 😤</p> <p>The STM32F103 devices are split into these four groups:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="s">'family'</span><span class="p">:</span> <span class="p">[</span><span class="s">'f1'</span><span class="p">],</span>
    <span class="s">'name'</span><span class="p">:</span> <span class="p">[</span><span class="s">'03'</span><span class="p">],</span>
    <span class="s">'size'</span><span class="p">:</span> <span class="p">[</span><span class="s">'4'</span><span class="p">,</span> <span class="s">'6'</span><span class="p">]</span>
<span class="p">},{</span>
    <span class="s">'family'</span><span class="p">:</span> <span class="p">[</span><span class="s">'f1'</span><span class="p">],</span>
    <span class="s">'name'</span><span class="p">:</span> <span class="p">[</span><span class="s">'03'</span><span class="p">],</span>
    <span class="s">'size'</span><span class="p">:</span> <span class="p">[</span><span class="s">'8'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">]</span>
<span class="p">},{</span>
    <span class="s">'family'</span><span class="p">:</span> <span class="p">[</span><span class="s">'f1'</span><span class="p">],</span>
    <span class="s">'name'</span><span class="p">:</span> <span class="p">[</span><span class="s">'03'</span><span class="p">],</span>
    <span class="s">'size'</span><span class="p">:</span> <span class="p">[</span><span class="s">'c'</span><span class="p">,</span> <span class="s">'d'</span><span class="p">,</span> <span class="s">'e'</span><span class="p">]</span>
<span class="p">},{</span>
    <span class="s">'family'</span><span class="p">:</span> <span class="p">[</span><span class="s">'f1'</span><span class="p">],</span>
    <span class="s">'name'</span><span class="p">:</span> <span class="p">[</span><span class="s">'03'</span><span class="p">],</span>
    <span class="s">'size'</span><span class="p">:</span> <span class="p">[</span><span class="s">'f'</span><span class="p">,</span> <span class="s">'g'</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div> <p>In case you’re curious how bad it would be with just one large F103 group, <a href="https://gist.github.com/salkinium/95e3bf6322468c56beef9dc6c7bbaa3f">here is a gist with the resulting device file</a>. It’s not as bad as it could be, but still much harder to read.</p> <p>At this point the merged IR for our F103RBT device basically already looks like the finished device file, including identifier filters:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>device &lt;&gt; stm32f103[c|r|t|v][8|b][h|i|t|u]
. driver &lt;name:core type:cortex-m3&gt;
  . memory &lt;name:flash access:rx start:0x8000000 size:65536&gt; stm32f103[c|r|t|v]8[h|t|u]
  . memory &lt;name:flash access:rx start:0x8000000 size:131072&gt; stm32f103[c|r|t|v]b[h|i|t|u]
  . memory &lt;name:sram1 access:rwx start:0x20000000 size:20480&gt;
  . vector &lt;position:0 name:WWDG&gt;
     ...
  . vector &lt;position:42 name:USBWakeUp&gt;
. driver &lt;name:i2c type:stm32&gt;
  . instance &lt;value:1&gt;
  . instance &lt;value:2&gt; stm32f103[c|r|v][8|b][h|i|t|u]
. driver &lt;name:spi type:stm32&gt;
  . instance &lt;value:1&gt;
  . instance &lt;value:2&gt; stm32f103[c|r|v][8|b][h|i|t|u]
</code></pre></div></div> <p>I’ve already described the device file format above, however, one additional testing step is done before the DFG is finished: A copy of every single device file is taken before merging, so that it can be compared with the device files that are extracted from this merged one. This is a brute-force test to make sure the filter algorithms did perform correctly.</p> <p>On a side note, the conversion from IR to device file format can be performed at any time, so that last merge step is strictly speaking optional. This is useful for debugging but also if you want to output this data in a format that does not support a merge mechanism similar to the device file’s one, like plain JSON.</p> <h2 id="using-device-files"> <a href="#using-device-files" class="anchor-head"></a> Using Device Files </h2> <p>So now that we have all this data, let’s have some fun with it. modm-devices comes not only with the DFG but also with a device file parser, which can be used like this:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">modm.parser</span><span class="p">,</span> <span class="n">glob</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">devices</span> <span class="o">=</span> <span class="p">{}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">"path/to/modm-devices/devices/**/*.xml"</span><span class="p">):</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="k">for</span> <span class="n">device</span> <span class="ow">in</span> <span class="n">modm</span><span class="p">.</span><span class="n">parser</span><span class="p">.</span><span class="n">DeviceParser</span><span class="p">().</span><span class="n">parse</span><span class="p">(</span><span class="n">filename</span><span class="p">).</span><span class="n">get_devices</span><span class="p">():</span>
<span class="o">&gt;&gt;&gt;</span>         <span class="n">devices</span><span class="p">[</span><span class="n">device</span><span class="p">.</span><span class="n">partname</span><span class="p">]</span> <span class="o">=</span> <span class="n">device</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">devices</span><span class="p">[</span><span class="s">"stm32f103rbt"</span><span class="p">].</span><span class="n">properties</span>
<span class="p">{</span><span class="s">'driver'</span><span class="p">:</span> <span class="p">[{</span><span class="s">'memory'</span><span class="p">:</span> <span class="p">[{</span><span class="s">'access'</span><span class="p">:</span> <span class="s">'rx'</span><span class="p">,</span>
                     <span class="s">'name'</span><span class="p">:</span> <span class="s">'flash'</span><span class="p">,</span>
                     <span class="s">'size'</span><span class="p">:</span> <span class="s">'131072'</span><span class="p">,</span>
                     <span class="s">'start'</span><span class="p">:</span> <span class="s">'0x8000000'</span><span class="p">},</span>
                    <span class="p">{</span><span class="s">'access'</span><span class="p">:</span> <span class="s">'rwx'</span><span class="p">,</span>
                     <span class="s">'name'</span><span class="p">:</span> <span class="s">'sram1'</span><span class="p">,</span>
                     <span class="s">'size'</span><span class="p">:</span> <span class="s">'20480'</span><span class="p">,</span>
                     <span class="s">'start'</span><span class="p">:</span> <span class="s">'0x20000000'</span><span class="p">}],</span>
         <span class="s">'name'</span><span class="p">:</span> <span class="s">'core'</span><span class="p">,</span>
         <span class="s">'type'</span><span class="p">:</span> <span class="s">'cortex-m3'</span><span class="p">,</span>
         <span class="p">...</span> <span class="p">}]</span>
<span class="p">}</span>
</code></pre></div></div> <p>There are some built-in convenience functions for accessing some of the common data in the device files:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">device</span> <span class="o">=</span> <span class="n">devices</span><span class="p">[</span><span class="s">"stm32f103rbt"</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">device</span><span class="p">.</span><span class="n">identifier</span>
<span class="n">OrderedDict</span><span class="p">([(</span><span class="s">'platform'</span><span class="p">,</span> <span class="s">'stm32'</span><span class="p">),</span> <span class="p">(</span><span class="s">'family'</span><span class="p">,</span> <span class="s">'f1'</span><span class="p">),</span> <span class="p">(</span><span class="s">'name'</span><span class="p">,</span> <span class="s">'03'</span><span class="p">),</span> <span class="p">(</span><span class="s">'pin'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">),</span> <span class="p">(</span><span class="s">'size'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">),</span> <span class="p">(</span><span class="s">'package'</span><span class="p">,</span> <span class="s">'t'</span><span class="p">)])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">device</span><span class="p">.</span><span class="n">has_driver</span><span class="p">(</span><span class="s">"usart:avr"</span><span class="p">)</span>
<span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">device</span><span class="p">.</span><span class="n">has_driver</span><span class="p">(</span><span class="s">"usart:stm32"</span><span class="p">)</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">device</span><span class="p">.</span><span class="n">get_driver</span><span class="p">(</span><span class="s">"usart:stm32"</span><span class="p">)</span>
<span class="p">{</span><span class="s">'instance'</span><span class="p">:</span> <span class="p">[</span><span class="s">'1'</span><span class="p">,</span> <span class="s">'2'</span><span class="p">,</span> <span class="s">'3'</span><span class="p">],</span> <span class="s">'name'</span><span class="p">:</span> <span class="s">'usart'</span><span class="p">,</span> <span class="s">'type'</span><span class="p">:</span> <span class="s">'stm32'</span><span class="p">}</span>
</code></pre></div></div> <p>I’ve also written a short <code class="language-plaintext highlighter-rouge">stats</code> script that allows you to compute some very basic information about the device file collection:</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nv">$ </span>python3 tools/device/scripts/stats <span class="nt">--count</span>
1355 devices
 <span class="nv">$ </span>python3 tools/device/scripts/stats <span class="nt">--driver</span>
<span class="o">{</span>
    <span class="s2">"ac"</span>: 234,
    <span class="s2">"adc"</span>: 1339,
    <span class="s2">"aes"</span>: 133,
    <span class="s2">"awex"</span>: 26,
    <span class="s2">"bandgap"</span>: 8,
    <span class="s2">"battery_protection"</span>: 7,
    <span class="s2">"bdma"</span>: 20,
    <span class="s2">"bod"</span>: 30,
    <span class="s2">"can"</span>: 683,
    <span class="s2">"ccl"</span>: 30,
    <span class="s2">"cell_balancing"</span>: 5,
    <span class="s2">"cfd"</span>: 2,
    <span class="s2">"charger_detect"</span>: 4,
    <span class="s2">"clk"</span>: 45,
    <span class="s2">"clock"</span>: 242,
    <span class="s2">"comp"</span>: 577,
    <span class="s2">"core"</span>: 1355,
    ...
<span class="o">}</span>
</code></pre></div></div> <!-- TODO: insert bar graphs for Flash/RAM distributions? --> <p><code class="language-plaintext highlighter-rouge">stats</code> also allows you to dump expanded JSON for a prefix of devices and then query that with the tool of your choice to, for example, get all the I<sup>2</sup>C related signals on port B for the STM32F4 device family. Not sure why you’d want that, but it’s possible.</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nv">$ </span>python3 tools/device/scripts/stats <span class="nt">--json</span> stm32f4 | jq <span class="s1">'[.[] | .device.driver[] | select(.name == "gpio").gpio[] | . as $gpio | .signal[]? | select(.driver == "i2c" and $gpio.port == "b") | ($gpio.port + $gpio.pin + ":" + .name)] | unique'</span>
<span class="o">[</span>
  <span class="s2">"b10:scl"</span>,
  <span class="s2">"b11:sda"</span>,
  <span class="s2">"b12:smba"</span>,
  <span class="s2">"b3:sda"</span>,
  <span class="s2">"b4:sda"</span>,
  <span class="s2">"b5:smba"</span>,
  <span class="s2">"b6:scl"</span>,
  <span class="s2">"b7:sda"</span>,
  <span class="s2">"b8:scl"</span>,
  <span class="s2">"b8:sda"</span>,
  <span class="s2">"b9:sda"</span>
<span class="o">]</span>
</code></pre></div></div> <p>I’ll discuss in more detail how we use the device files in the next blog post about the modm library.</p> <h3 id="try-it-yourself"> <a href="#try-it-yourself" class="anchor-head"></a> Try it Yourself </h3> <p>The <a href="https://github.com/modm-io/modm-devices">device file as well as the DFG are available on GitHub</a> for you to play with. It automatically downloads and extracts all the raw data into <code class="language-plaintext highlighter-rouge">modm-devices/tools/generator/raw-device-data</code> folder.</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone <span class="nt">--recursive</span> <span class="nt">--depth</span><span class="o">=</span>1 https://github.com/modm-io/modm-devices.git
<span class="nb">cd </span>modm-devices/tools/generator
<span class="c"># Extract and generate STM32 device data</span>
make extract-data-stm32
make generate-stm32
<span class="c"># Extract and generate AVR device data</span>
make extract-data-avr
make generate-avr
</code></pre></div></div> <p>Not everything I described here is fully implemented, for example, the <a href="https://github.com/salkinium/save-the-clocktrees">clock graph extractor is just a proof-of-concept</a> for now. modm-devices is also supposed to be a Python package installable via pip, but that’s not implemented yet.</p> <p>Please help me maintain this project, I only used devices from a few STM32 families, so it’s difficult to judge the correctness of some of this data. If you know of any other machine readable data, please open an issue or preferrably a pull request.</p> <p>Two more device file checks are currently not implemented: a XML schema validation, and a semantical checker, that verifies the contents consistency. For example, every GPIO signal should be associable with a driver, and no signal name should start with a number (otherwise difficult to map into most programming languages). These are ideas for the future.</p> <p>With some effort and additional data sources (CMSIS-SVD files for example), directly outputting to Device Tree format should be possible too. I leave that one to the experts though. 😇</p> <h2 id="conclusion"> <a href="#conclusion" class="anchor-head"></a> Conclusion </h2> <p>It was important to use not to bind this data to any preconceptions of its use by, for example, integrating it tightly into our HAL generator. Instead we’ve very carefully separated modm-devices from our use of it, so that it can stand on its own and be integrated into all sorts of projects by the community. You’re not bound to using this in code either, you can also generate Markdown documentation, or maybe build your own GPIO configurator as a web UI.</p> <p>You can go and use it as is with its Python <code class="language-plaintext highlighter-rouge">DeviceFile</code> interface, however, for larger projects, I’d recommend you write your own wrapper class, that can format the data as you need it. The Device File format may change at any time, so that I can fit in new data or once I don’t like the format anymore, change it completely. So don’t depend on the format directly.</p> <p>The next few blog posts will be about applying this data in our own modm library, how CMSIS-SVD compares to CMSIS Headers as additional data sources, and what it means to model check your HAL with this data.</p> <h3 id="on-a-personal-note"> <a href="#on-a-personal-note" class="anchor-head"></a> On a Personal Note </h3> <p>The last 5 years working on this have been quite a ride. It has completely changed my view on embedded software engineering and it took a while for me understand this different way of thinking. As far as I know, nobody has deployed hardware description methods on such a large and diverse device base. And we’re just getting started.</p> <p>I’ve been fortunate to have found similarly minded people in the RCA, who provided me with valuable feedback and thoughtful discussions, who mentored me and tolerated my rants about our robot’s code quality. The RCA is self organized, so we don’t have anyone telling us what to do, or <em>how</em> to do it. As a result, we do reinvent the wheel a lot, sometimes for worse, but mostly for the better, like with this project.</p> <p>During this time I’ve not had the best experience with the “professional” C/C++ embedded community. There are too many established developers convinced of their own opinions that won’t stop arguing until they’ve “won” (just ask about using <a href="https://gist.github.com/salkinium/cc7236328a532c8c0f05f74c9ceb30a4">C++ on µCs</a> and bring some 🍿). Together with the growth in amateur interest in embedded software (absolutely <em>not</em> a bad thing), this completely drowned out any worthwhile online discussions on new approaches to embedded software that are different from the “approved” norm. I’m not talking so much about the programming language itself, which is relatively exchangeable for HALs (a rather unpopular opinion), but about HAL design concepts and perhaps most importantly, support tools.</p> <p>Let me give you an example: ST has committed <a href="https://github.com/ARMmbed/mbed-os/graphs/contributors">at least 4-6 engineers</a> to porting its devices to Arm Mbed OS. Good for ST, that’s a lot of money. But: ST only supports <a href="https://gist.github.com/salkinium/f2140b4ba2bbf7cb3c9a99c215392048#file-targets-md">55 of their ~1100 STM32 targets</a> on Mbed OS, with every single one of them ported <em>by hand</em>. This means at least all <a href="https://gist.github.com/salkinium/f2140b4ba2bbf7cb3c9a99c215392048#file-startuplinker-md">startup code and linkerscripts</a> are mostly duplicated for each target and <a href="https://gist.github.com/salkinium/f2140b4ba2bbf7cb3c9a99c215392048#file-gpio_signals-md">all GPIO signal data is added manually</a> by an unfortunate soul with all the <a href="https://github.com/ARMmbed/mbed-os/blob/8f647beacb6f14ce1af7f2eff01d0a497f94f7ae/targets/TARGET_STM/TARGET_STM32F1/TARGET_NUCLEO_F103RB/PeripheralPins.c#L35-L37">side-effects of manual labor</a>. That’s insane, as you’ve seen above, ST is already maintaining and using this data already to generate code with CubeMX. How is this not automated? (I dared to utter this simple observation about two years ago while working at Arm on Mbed OS and it turned out to be <em>surprisingly unpopular</em>. Touchy folks. 🙃)</p> <p>Fortunately, in the last few years there was some significant progress in enabling (new) programming languages on embedded, like <a href="http://micropython.org">MicroPython</a>, <a href="https://www.espruino.com">Javascript runtimes</a> and perhaps the most significant of them: <a href="http://blog.japaric.io">Embedded in Rust</a>. I’ve been particularly impressed with the progress of the community surrounding <a href="https://twitter.com/japaricious">@japaricious</a>, who are currently tackling some very hard issues, <a href="http://blog.japaric.io/brave-new-io/#no-pin-overlap">like IO signal grouping</a> or <a href="http://blog.japaric.io/safe-dma/">safe DMA APIs</a>. I’ve kinda written this blog post for them, since I think they are <a href="https://internals.rust-lang.org/t/announcing-the-embedded-devices-working-group/">best organized to actually use it</a> and they don’t seem afraid to tackle these issues. (Your move, C++ people!)</p> <p><em>Formatting of all data excerpts is possibly copyrighted by their respective owners and if so used here in fair use. However, the data itself are facts which cannot be copyrighted.</em></p> </div> </article> </main> <nav class="post-nav"> <a class="post-nav-item post-nav-prev" href="/xpccs-error-model/" > <div class="nav-arrow">Previous</div> <span class="post-title">The Curious Case of xpcc's Error Model</span> </a> </nav> <footer class="footer"> <a class="footer_item" href="/feed.xml">rss</a> <span class="footer_item">&copy; 2021</span> <small class="footer_copyright"> <!-- Klisé Theme: https://github.com/piharpi/jekyll-klise --> <a href="https://github.com/piharpi/jekyll-klise" target="_blank" rel="noreferrer noopener" >klisé</a > theme on <a href="https://jekyllrb.com" target="_blank" rel="noreferrer noopener" >jekyll</a > </small> </footer> <script src="/assets/js/main.js" defer="defer"></script> </div> </body> </html>
