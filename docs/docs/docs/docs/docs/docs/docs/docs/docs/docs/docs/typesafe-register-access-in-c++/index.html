<!DOCTYPE html> <html lang="en-US"> <head prefix="og: http://ogp.me/ns#"> <meta charset="UTF-8" /> <meta http-equiv="X-UA-Compatible" content="ie=edge" /> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <meta name="mobile-web-app-capable" content="yes" /> <meta name="apple-mobile-web-app-capable" content="yes" /> <meta name="application-name" content="embedded entanglement" /> <meta name="apple-mobile-web-app-status-bar-style" content="#fff" /> <meta name="apple-mobile-web-app-title" content="embedded entanglement" /> <title> Typesafe Register Access in C++ - embedded entanglement </title> <link rel="alternate" href="http://blog.salkinium.com/typesafe-register-access-in-c++/" hreflang="en-US" /> <link rel="canonical" href="http://blog.salkinium.com/typesafe-register-access-in-c++/" /> <meta name="description" content="reflecting on embedded software development" /> <meta name="referrer" content="no-referrer-when-downgrade" /> <meta property="fb:app_id" content="" /> <meta property="og:site_name" content="Typesafe Register Access in C++ | Niklas Hauser" /> <meta property="og:title" content="Typesafe Register Access in C++ | Niklas Hauser" /> <meta property="og:type" content="website" /> <meta property="og:url" content="http://blog.salkinium.com/typesafe-register-access-in-c++/" /> <meta property="og:description" content="reflecting on embedded software development" /> <meta property="og:image" content="" /> <meta property="og:image:width" content="640" /> <meta property="og:image:height" content="640" /> <meta name="twitter:card" content="summary" /> <meta name="twitter:title" content="Typesafe Register Access in C++ | salkinium" /> <meta name="twitter:url" content="http://blog.salkinium.com/typesafe-register-access-in-c++/" /> <meta name="twitter:site" content="@salkinium" /> <meta name="twitter:creator" content="@salkinium" /> <meta name="twitter:description" content="reflecting on embedded software development" /> <meta name="twitter:image" content="" /> <link type="application/atom+xml" rel="alternate" href="http://blog.salkinium.com/feed.xml" title="embedded entanglement" /> <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicons/apple-touch-icon.png" /> <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png" /> <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png" /> <link rel="manifest" href="/assets/favicons/site.webmanifest" /> <link rel="mask-icon" href="/assets/favicons/safari-pinned-tab.svg" color="#5bbad5" /> <meta name="apple-mobile-web-app-title" content="Jekyll Klise" /> <meta name="application-name" content="Jekyll Klise" /> <meta name="msapplication-TileColor" content="#da532c" /> <meta name="theme-color" content="#2c2c2c" /> <link rel="stylesheet" href="/assets/css/style.css" /> </head> <body data-theme="dark" class="notransition"> <script> const body = document.body; const data = body.getAttribute("data-theme"); const initTheme = (state) => { if (state === "dark") { body.setAttribute("data-theme", "dark"); } else if (state === "light") { body.removeAttribute("data-theme"); } else { localStorage.setItem("theme", data); } }; initTheme(localStorage.getItem("theme")); setTimeout(() => body.classList.remove("notransition"), 75); </script> <div class="navbar" role="navigation"> <nav class="menu"> <input type="checkbox" id="menu-trigger" class="menu-trigger" /> <label for="menu-trigger"> <span class="menu-icon"> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <path d="M64,384H448V341.33H64Zm0-106.67H448V234.67H64ZM64,128v42.67H448V128Z" /> </svg> </span> </label> <a id="mode"> <svg class="mode-sunny" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <title>LIGHT</title> <line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> </svg> <svg class="mode-moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <title>DARK</title> <line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> </svg> </a> <div class="trigger"> <div class="trigger-container"><a class="menu-link" href="/">home</a><a class="menu-link" href="/archive/">archive</a><a class="menu-link" href="https://salkinium.com" target="_blank" rel="noopener" >about</a ><a class="menu-link rss" href="/feed.xml"> <svg xmlns="http://www.w3.org/2000/svg" width="17" height="17" viewBox="0 0 512 512" fill="#ED812E" > <title>RSS</title> <path d="M108.56,342.78a60.34,60.34,0,1,0,60.56,60.44A60.63,60.63,0,0,0,108.56,342.78Z" /> <path d="M48,186.67v86.55c52,0,101.94,15.39,138.67,52.11s52,86.56,52,138.67h86.66C325.33,312.44,199.67,186.67,48,186.67Z" /> <path d="M48,48v86.56c185.25,0,329.22,144.08,329.22,329.44H464C464,234.66,277.67,48,48,48Z" /> </svg> </a> </div> </div> </nav> </div> <div class="wrapper post"> <main class="page-content" aria-label="Content"> <article itemscope itemtype="https://schema.org/BlogPosting"> <header class="header"> <h1 class="header-title" itemprop="headline">Typesafe Register Access in C++</h1> <div class="post-meta"> <time datetime="2015-02-25T00:00:00+01:00" itemprop="datePublished"> Feb 25, 2015 </time> <span itemprop="author" itemscope itemtype="https://schema.org/Person"> <span itemprop="name">Niklas Hauser</span> </span> <time hidden datetime="" itemprop="dateModified"> Feb 25, 2015 </time> <span hidden itemprop="publisher" itemtype="Person">Niklas Hauser</span> <span hidden itemprop="image"></span> <span hidden itemprop="mainEntityOfPage"><p>When you are writing software for microcontrollers, reading and writing hardware registers becomes second nature. Registers and bit mappings are typically “modeled” using C preprocessor defines, and usually provided to you by your cross compiler toolchain in device specific header files.</p> <p>Setting up and toggling PG13 on the STM32F4 this way looks rather… unreadable:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// set push-pull, output</span>
<span class="n">GPIOG</span><span class="o">-&gt;</span><span class="n">OSPEEDR</span> <span class="o">=</span> <span class="p">(</span><span class="n">GPIOG</span><span class="o">-&gt;</span><span class="n">OSPEEDR</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">26</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">26</span><span class="p">);</span>
<span class="n">GPIOG</span><span class="o">-&gt;</span><span class="n">MODER</span>   <span class="o">=</span> <span class="p">(</span><span class="n">GPIOG</span><span class="o">-&gt;</span><span class="n">MODER</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">26</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">26</span><span class="p">);</span>
<span class="n">GPIOG</span><span class="o">-&gt;</span><span class="n">OTYPER</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">);</span>
<span class="n">GPIOG</span><span class="o">-&gt;</span><span class="n">PUPDR</span>  <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">);</span>

<span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">GPIOG</span><span class="o">-&gt;</span><span class="n">ODR</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">);</span>  <span class="c1">// toggle</span>
    <span class="c1">// delay</span>
<span class="p">}</span>
</code></pre></div></div> <p>It did not really dawn on me how primitive this concept was until I was forced to model a memory map myself for one of our many <a href="http://xpcc.io/api/group__driver.html">device drivers</a>. Since I have never been a friend of using the C preprocessor in C++ unless absolutely necessary, it seemed like a good opportunity to research how best to implement this in pure C++.</p> </span> </div> </header> <div class="page-content" itemprop="articleBody"> <p>When you are writing software for microcontrollers, reading and writing hardware registers becomes second nature. Registers and bit mappings are typically “modeled” using C preprocessor defines, and usually provided to you by your cross compiler toolchain in device specific header files.</p> <p>Setting up and toggling PG13 on the STM32F4 this way looks rather… unreadable:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// set push-pull, output</span>
<span class="n">GPIOG</span><span class="o">-&gt;</span><span class="n">OSPEEDR</span> <span class="o">=</span> <span class="p">(</span><span class="n">GPIOG</span><span class="o">-&gt;</span><span class="n">OSPEEDR</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">26</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">26</span><span class="p">);</span>
<span class="n">GPIOG</span><span class="o">-&gt;</span><span class="n">MODER</span>   <span class="o">=</span> <span class="p">(</span><span class="n">GPIOG</span><span class="o">-&gt;</span><span class="n">MODER</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">26</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">26</span><span class="p">);</span>
<span class="n">GPIOG</span><span class="o">-&gt;</span><span class="n">OTYPER</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">);</span>
<span class="n">GPIOG</span><span class="o">-&gt;</span><span class="n">PUPDR</span>  <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">);</span>

<span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">GPIOG</span><span class="o">-&gt;</span><span class="n">ODR</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">);</span>  <span class="c1">// toggle</span>
    <span class="c1">// delay</span>
<span class="p">}</span>
</code></pre></div></div> <p>It did not really dawn on me how primitive this concept was until I was forced to model a memory map myself for one of our many <a href="http://xpcc.io/api/group__driver.html">device drivers</a>. Since I have never been a friend of using the C preprocessor in C++ unless absolutely necessary, it seemed like a good opportunity to research how best to implement this in pure C++.</p> <!--more--> <h2 id="existing-concepts"> <a href="#existing-concepts" class="anchor-head"></a> Existing Concepts </h2> <p>Martin Moene has compiled <a href="http://www.eld.leidenuniv.nl/~moene/Home/papers/accu/overload95-register/">an excellent overview</a> of the relevant publications regarding C++ hardware register access. Perhaps the most relevant of those is a paper written by Ken Smith titled <a href="http://yogiken.files.wordpress.com/2010/02/c-register-access.pdf">“C++ Hardware Register Access Redux”</a> written in 2010.</p> <p>Smith’s policy based design is quite complete and there even exists a <a href="https://github.com/JinShil/memory_mapped_io">functioning implementation</a> by Jin Shil keyed to embedded systems — albeit in the D programming language.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> The author has implemented part of the STM32F4 memory map with these classes and uses them in a simple <a href="https://github.com/JinShil/stm32f42_discovery_demo/blob/0f355d63bd7823f593ef770db1703bc2cf3454a6/source/start.d#L253">D program for toggling a pin</a> (a C++ version would look similar):</p> <div class="language-d highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// set push-pull, output</span>
<span class="n">GPIOG</span><span class="p">.</span><span class="n">OSPEEDR</span><span class="p">.</span><span class="n">OSPEEDR13</span><span class="p">.</span><span class="n">value</span> <span class="p">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">GPIOG</span><span class="p">.</span><span class="n">MODER</span><span class="p">.</span><span class="n">MODER13</span><span class="p">.</span><span class="n">value</span>     <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">GPIOG</span><span class="p">.</span><span class="n">OTYPER</span><span class="p">.</span><span class="n">OT13</span><span class="p">.</span><span class="n">value</span>       <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">GPIOG</span><span class="p">.</span><span class="n">PUPDR</span><span class="p">.</span><span class="n">PUPDR13</span><span class="p">.</span><span class="n">value</span>     <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">while</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">GPIOG</span><span class="p">.</span><span class="n">ODR</span><span class="p">.</span><span class="n">ODR13</span><span class="p">.</span><span class="n">value</span> <span class="p">=</span> <span class="p">!</span><span class="n">GPIOG</span><span class="p">.</span><span class="n">ODR</span><span class="p">.</span><span class="n">ODR13</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>    <span class="c1">// toggle</span>
    <span class="c1">// delay</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4 Mar 2015 – Update:</strong> I seem to have completely missed <a href="https://github.com/kensmith/cppmmio">Ken Smith’s own implementation</a>. He also has a <a href="https://github.com/kensmith/cortex-from-scratch">Cortex-M example</a>.<br /> <strong>5 Mar 2015 – Update:</strong> For an excellent example of a similar implementation for the AVR using C++11, see <a href="https://github.com/chrism333/yalla">the yalla library</a>.<br /> <strong>8 Sep 2015 – Update:</strong> There also exists the <a href="https://github.com/kvasir-io/Kvasir/tree/master/Lib/Register">Kvasir register implementation</a> which has a few more tricks up its sleeve regarding atomicity and efficiency. Impressive.</p> <p>Here are a few of my observations:</p> <ol> <li>How does one generate the C++ memory map? By hand for every device? How do you keep it up-to-date for new devices?</li> <li>The above code is syntactically already a huge improvement. However, its semantics are just as cryptic. What does writing value <code class="language-plaintext highlighter-rouge">3</code> into register <code class="language-plaintext highlighter-rouge">GPIOG.OSPEEDR.OSPEEDR13</code> actually mean?</li> <li>The papers compiled by Moene are assuming we want to access the devices internal memory. For devices connected via an external bus, accessing a memory location can be an expensive operation, which can take a long time and even fail.</li> </ol> <h4 id="high-effort-solution"> <a href="#high-effort-solution" class="anchor-head"></a> High Effort Solution </h4> <p>Even though Smith’s policy based design does not carry a runtime penalty, implementing and maintaining it clearly comes with some overhead. Every device family requires its own memory map implementation, which would be crazy to code by hand. Not only for the sheer effort required, but also since this would be incredibly prone to errors. (<a href="https://github.com/JinShil/stm32_datasheet_to_d">Jin Shin seems to have realized this too</a>.) If the manufacturer adds a new device to the family, you would have to update and perhaps extend this memory map implementation.</p> <p>A generator is required, which converts a computer readable memory map into the C++ counterpart and this with as little additional effort as possible. Notice that the existing memory files in your compiler toolchain (the ones with the defines) only provide you with names for memory addresses, bits and configuration, but lacks the information required for generating the correct policies.</p> <p>Therefore you would need to find an “annotated” memory map, which is probably only available directly from the manufacturer. Atmel has so-called “Part Description Files” hidden somewhere deep in AVR Studio, which are used by the avr-gcc developers to generate the <code class="language-plaintext highlighter-rouge">io.h</code> memory files for the AVRs. ST Microelectronics has similar files hidden in their STM32Cube initialization code generator.</p> <p>I know this, because xpcc uses exactly these memory maps to generate its <a href="https://github.com/roboterclubaachen/xpcc/tree/develop/src/xpcc/architecture/platform/devices">own device files</a>. I can tell you that writing and maintaining a parser for these files is painful, since they are littered with inconsistencies. I cannot imagine maintaining this for the entire memory map. The errors in Atmel’s memory maps drive me crazy enough.</p> <p>So unless the manufacturer goes the extra mile and publishes their device memory maps preferably open-source on GitHub (unlikely) or directly provide the C++ implementations themselves (even less likely), the burden to generate these implementations and keep them up-to-date is placed on the library maintainers. That’s not really an option.</p> <p><strong>17 Mar 2015 – Update:</strong> As part of <a href="http://cmsis.arm.com">CMSIS</a>, ARM has standardized <a href="http://www.keil.com/pack/doc/CMSIS/SVD/html/index.html">System View Description (SVD)</a> files which describe the memory map of vendor devices. These files could be the foundation for generation, however, a vendor-specific EULA needs to be agreed to before download.<br /> <strong>12 Sep 2015 – Update:</strong> Paul has created a <a href="https://github.com/posborne/cmsis-svd">GitHub repository containing most SVD files and a python parser</a>. This could be a gamechanger!</p> <h4 id="semantics-matter"> <a href="#semantics-matter" class="anchor-head"></a> Semantics Matter </h4> <p>Let me put forward this blunt theory: Regardless of how elegantly register access is realized in a language, there is hardly a semantical advantage of this, since you are still writing magic numbers into a lot of magic registers (in a more beautiful and type-safe way though).</p> <p>In xpcc the above code is reduced to these three equivalent <em>and</em> self-explanatory lines:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GpioG13</span><span class="o">::</span><span class="n">configure</span><span class="p">(</span><span class="n">Gpio</span><span class="o">::</span><span class="n">OutputType</span><span class="o">::</span><span class="n">PushPull</span><span class="p">);</span>
<span class="n">GpioG13</span><span class="o">::</span><span class="n">setOutput</span><span class="p">();</span>

<span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">GpioG13</span><span class="o">::</span><span class="n">toggle</span><span class="p">();</span>
    <span class="c1">// delay</span>
<span class="p">}</span>
</code></pre></div></div> <p>Notice how there are no registers in this code whatsoever and how clear the meaning of the code becomes. It seems to be much more useful to implement a clean hardware abstraction layer, than a form of register access.</p> <p>This does not mean that elegant register access is pointless, however, its level of abstraction might be too low for your library to benefit from. It might be an enrichment for the library developers (Smith proposes unit testing register access), but usually a higher level of abstraction is required.</p> <h4 id="missed-the-bus"> <a href="#missed-the-bus" class="anchor-head"></a> Missed The Bus </h4> <p>An external device is typically connected through a serial bus like UART, SPI or I<sup>2</sup>C, which is very slow compared to any internal bus. Even the few devices using a parallel bus interface (like external RAM) most often multiplex their address and data lines to minimize the amount of required pins. It’s probably fair to say “Internal &gt; Parallel &gt; SPI &gt; UART &gt; I<sup>2</sup>C” in terms of transfer speed.</p> <p>Since a typical read-modify-write means accessing the bus twice, a naive implementation of our example code would yield 8 bus accesses for setting up the port and another 2 for every pin toggle. That only takes a few cycles using the internal bus<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>, but would easily stretch to micro- and milliseconds on an external serial bus, which makes it impractical to busy-wait during this time.</p> <p>There is another problem. Consider the following memory layout of an external accelerometer:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rw: | Config1 | Config2 | Config3 | Config4 |
       0x20      0x21      0x22      0x23

ro: | Status | XL | XH | YL | YH | ZL | ZH |
       0x30   0x31 0x32 0x33 0x34 0x35 0x36
</code></pre></div></div> <p>Both the configuration registers as well as the read-only registers are all placed in one continuos memory block. The most usual serial interfaces of external devices auto-increment their start address, so that we can efficiently write or read a continuos block of memory. This would allow us one bus access to write the four configuration bytes, and not have to access the bus four times to write only one byte each time. Similarly, we also do not want to access each of the read-only registers separately.</p> <p>However, such a register block access is not considered in Smith’s design nor in Jin Shin’s implementation. It is also “merely” an optimization when using a different bus type, but it still breaks with the existing interface.</p> <p>Considering this and the ideas on semantics, I would argue that devices connected through an external bus require a different level of abstraction.</p> <h2 id="what-now"> <a href="#what-now" class="anchor-head"></a> What Now? </h2> <p>If you have read to here the situation seems a bit hopeless. The existing solutions are difficult to implement and maintain, provide little semantical advantages and do not work well over external busses. And I still have no idea how to model the memory map of my external devices.</p> <p><em>So let us ignore the internal memory.</em> We already have a way of using it with the defines and with a good hardware abstraction layer there should be no need to access them directly.</p> <h4 id="modelling-registers"> <a href="#modelling-registers" class="anchor-head"></a> Modelling Registers </h4> <p>Instead, let’s focus on how to model register content of external devices and ignore the bus for the moment.</p> <p>Registers can be made up of three things:</p> <ul> <li>Bits: a single bit (position <em>N</em>),</li> <li>Configurations: a combination of bits where the meaning does not correspond to its numeric value (position <em>[N, M]</em>)</li> <li>Values: a numeric value (position <em>[N, M]</em>)</li> </ul> <p>Example of an 8bit register: Control</p> <p><img src="control_register.svg" alt="Control Register" /></p> <ul> <li>Bit <em>7</em>: Enable</li> <li>Bit <em>6</em>: Full Scale</li> <li>Configuration <em>[5, 4]</em>: Prescaler <ul> <li>00: Divide by 1</li> <li>01: Divide by 2</li> <li>10: Divide by 4</li> <li>11: Divide by 8</li> </ul> </li> <li>Value <em>[3, 1]</em>: Start-Up Delay in ms</li> </ul> <p>There should be an easy way to access all of this information in the register.</p> <h4 id="static-constexpr"> <a href="#static-constexpr" class="anchor-head"></a> static constexpr </h4> <p>The first idea and implementation was a bit messy. I wanted to make every bit a static constant expression of class <code class="language-plaintext highlighter-rouge">Bit</code>. Similar constructs are possible for configurations and values. Using operator and constructor overloading these constant expressions could be converted and assigned and OR’ed in a type-safe way.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Control</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Register8</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">constexpr</span> <span class="n">Bit</span> <span class="n">EN</span>  <span class="o">=</span> <span class="n">Bit7</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">constexpr</span> <span class="n">Bit</span> <span class="n">FS</span>  <span class="o">=</span> <span class="n">Bit6</span><span class="p">;</span>

	<span class="k">struct</span> <span class="nc">Prescaler</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Group</span>
	<span class="p">{</span>
		<span class="k">static</span> <span class="k">constexpr</span> <span class="n">Type</span> <span class="n">BitPosition</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">static</span> <span class="k">constexpr</span> <span class="n">Config</span> <span class="n">Mask</span> <span class="o">=</span> <span class="mb">0b11</span> <span class="o">&lt;&lt;</span> <span class="n">BitPosition</span><span class="p">;</span>

		<span class="k">static</span> <span class="k">constexpr</span> <span class="n">Config</span> <span class="n">DivideBy1</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="n">BitPosition</span><span class="p">;</span>
		<span class="k">static</span> <span class="k">constexpr</span> <span class="n">Config</span> <span class="n">DivideBy2</span> <span class="o">=</span> <span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="n">BitPosition</span><span class="p">;</span>
		<span class="k">static</span> <span class="k">constexpr</span> <span class="n">Config</span> <span class="n">DivideBy4</span> <span class="o">=</span> <span class="mh">0x02</span> <span class="o">&lt;&lt;</span> <span class="n">BitPosition</span><span class="p">;</span>
		<span class="k">static</span> <span class="k">constexpr</span> <span class="n">Config</span> <span class="n">DivideBy8</span> <span class="o">=</span> <span class="mh">0x03</span> <span class="o">&lt;&lt;</span> <span class="n">BitPosition</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>I actually <a href="https://github.com/roboterclubaachen/xpcc/commit/ef55cb32a57b129af8a068f5b6c043eac2512312#diff-ba8846bac2db804c7b7c4a5d477002a0R159">implemented most of this</a> (with a bunch of ugly macros to reduce the verbosity of it). Then I realized that <code class="language-plaintext highlighter-rouge">static constexpr</code> members require an external instantiation for the linker, which would place them somewhere in memory. This is because the C++11 standard permits taking the address of a static constexpr member, and only instantiated members actually have an address.</p> <p>What a dealbreaker.</p> <p><strong>30 Aug 2015 – Update:</strong> Using a better approach, C. Biffle has implemented <code class="language-plaintext highlighter-rouge">Bitfields</code>, which models <a href="https://github.com/cbiffle/etl/blob/master/biffield/README.mkdn">memory-mapped register banks for his ETL library</a>.</p> <h2 id="strongly-typed-enumerations"> <a href="#strongly-typed-enumerations" class="anchor-head"></a> Strongly-Typed Enumerations </h2> <p>Which C++ type does not need to be instantiated to be used? Yes, enums. However, C++03 enums convert to integers pretty quickly, but thankfully, in C++11 we have strongly-typed enums which don’t do that.</p> <h4 id="register-bits"> <a href="#register-bits" class="anchor-head"></a> Register Bits </h4> <p>Using strongly-typed enums we can describe the bits of the example register as such:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">Control</span> <span class="o">:</span> <span class="kt">uint8_t</span>
<span class="p">{</span>
	<span class="n">EN</span> <span class="o">=</span> <span class="n">Bit7</span><span class="p">,</span>	<span class="c1">///&lt; bit documentation</span>
	<span class="n">FS</span> <span class="o">=</span> <span class="n">Bit6</span><span class="p">,</span>

	<span class="n">PRE1</span> <span class="o">=</span> <span class="n">Bit5</span><span class="p">,</span>
	<span class="n">PRE0</span> <span class="o">=</span> <span class="n">Bit4</span><span class="p">,</span>

	<span class="n">DEL2</span> <span class="o">=</span> <span class="n">Bit3</span><span class="p">,</span>
	<span class="n">DEL1</span> <span class="o">=</span> <span class="n">Bit2</span><span class="p">,</span>
	<span class="n">DEL0</span> <span class="o">=</span> <span class="n">Bit1</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="n">Flags8</span><span class="o">&lt;</span> <span class="n">Control</span> <span class="o">&gt;</span>  <span class="n">Control_t</span><span class="p">;</span>
</code></pre></div></div> <p>Since strongly-typed enums do not have any predefined operators, they are wrapped into the <code class="language-plaintext highlighter-rouge">Flags8</code> <a href="http://xpcc.io/api/structxpcc_1_1_flags.html">template class</a><sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>, which adds the necessary constructors and bitwise operator overloading to them and returns them as a <code class="language-plaintext highlighter-rouge">Flags8</code> type.<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup></p> <p>This means, you can handle all its register bits as you would expect:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Control_t</span> <span class="n">control</span> <span class="o">=</span> <span class="n">Control</span><span class="o">::</span><span class="n">EN</span><span class="p">;</span>
<span class="n">control</span> <span class="o">=</span> <span class="n">Control</span><span class="o">::</span><span class="n">EN</span> <span class="o">|</span> <span class="n">Control</span><span class="o">::</span><span class="n">FS</span><span class="p">;</span>
<span class="n">control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">Control</span><span class="o">::</span><span class="n">FS</span><span class="p">;</span>
<span class="n">control</span> <span class="o">|=</span> <span class="n">Control</span><span class="o">::</span><span class="n">FS</span><span class="p">;</span>
<span class="n">control</span> <span class="o">^=</span> <span class="n">Control</span><span class="o">::</span><span class="n">PRE1</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">isSet</span> <span class="o">=</span> <span class="n">control</span> <span class="o">&amp;</span> <span class="n">Control</span><span class="o">::</span><span class="n">FS</span><span class="p">;</span>

<span class="n">control</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">Control</span><span class="o">::</span><span class="n">PRE1</span> <span class="o">|</span> <span class="n">Control</span><span class="o">::</span><span class="n">PRE0</span><span class="p">);</span>
<span class="n">control</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">Control</span><span class="o">::</span><span class="n">DEL0</span><span class="p">);</span>

<span class="kt">bool</span> <span class="n">noneSet</span> <span class="o">=</span> <span class="n">control</span><span class="p">.</span><span class="n">none</span><span class="p">(</span><span class="n">Control</span><span class="o">::</span><span class="n">PRE1</span> <span class="o">|</span> <span class="n">Control</span><span class="o">::</span><span class="n">PRE0</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">allSet</span> <span class="o">=</span> <span class="n">control</span><span class="p">.</span><span class="n">all</span><span class="p">(</span><span class="n">Control</span><span class="o">::</span><span class="n">EN</span> <span class="o">|</span> <span class="n">Control</span><span class="o">::</span><span class="n">FS</span><span class="p">);</span>
</code></pre></div></div> <p>You still get raw access if you really need it:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint8_t</span> <span class="n">raw</span> <span class="o">=</span> <span class="n">control</span><span class="p">.</span><span class="n">value</span><span class="p">;</span> <span class="c1">// the underlying type</span>
<span class="n">control</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mh">0x24</span><span class="p">;</span>
</code></pre></div></div> <p>And the access is type-safe, you cannot use bits from two different registers:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">Control2</span> <span class="o">:</span> <span class="kt">uint8_t</span>
<span class="p">{</span>
	<span class="n">DIS</span> <span class="o">=</span> <span class="n">Bit4</span><span class="p">,</span>
	<span class="n">HS</span> <span class="o">=</span> <span class="n">Bit3</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="n">Flags8</span><span class="o">&lt;</span> <span class="n">Control2</span> <span class="o">&gt;</span>  <span class="n">Control2_t</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">control</span> <span class="o">=</span> <span class="n">Control</span><span class="o">::</span><span class="n">EN</span> <span class="o">|</span> <span class="n">Control2</span><span class="o">::</span><span class="n">HS</span><span class="p">;</span> <span class="c1">// compile error</span>
</code></pre></div></div> <p>You can even overload functions on argument type now:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">write</span><span class="p">(</span><span class="n">Control_t</span> <span class="n">control</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">write</span><span class="p">(</span><span class="n">Control2_t</span> <span class="n">control</span><span class="p">);</span>

<span class="n">write</span><span class="p">(</span><span class="n">Control</span><span class="o">::</span><span class="n">EN</span> <span class="o">|</span> <span class="n">Control</span><span class="o">::</span><span class="n">FS</span><span class="p">);</span>  <span class="c1">// calls #1</span>
<span class="n">write</span><span class="p">(</span><span class="n">Control2</span><span class="o">::</span><span class="n">DIS</span><span class="p">);</span>              <span class="c1">// calls #2</span>
</code></pre></div></div> <h4 id="register-configurations"> <a href="#register-configurations" class="anchor-head"></a> Register Configurations </h4> <p>Configurations are also described as a strongly-typed enum and then wrapped into the <code class="language-plaintext highlighter-rouge">Configuration</code> <a href="http://xpcc.io/api/structxpcc_1_1_configuration.html">template class</a>.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">Prescaler</span> <span class="o">:</span> <span class="kt">uint8_t</span>
<span class="p">{</span>
	<span class="n">Div1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>				<span class="c1">///&lt; configuration documentation</span>
	<span class="n">Div2</span> <span class="o">=</span> <span class="n">Control</span><span class="o">::</span><span class="n">PRE0</span><span class="p">,</span>
	<span class="n">Div4</span> <span class="o">=</span> <span class="n">Control</span><span class="o">::</span><span class="n">PRE1</span><span class="p">,</span>
	<span class="n">Div8</span> <span class="o">=</span> <span class="n">Control</span><span class="o">::</span><span class="n">PRE1</span> <span class="o">|</span> <span class="n">Control</span><span class="o">::</span><span class="n">PRE0</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="n">Configuration</span><span class="o">&lt;</span> <span class="n">Control_t</span><span class="p">,</span> <span class="n">Prescaler</span><span class="p">,</span> <span class="p">(</span><span class="n">Bit5</span> <span class="o">|</span> <span class="n">Bit4</span><span class="p">)</span> <span class="o">&gt;</span>  <span class="n">Prescaler_t</span><span class="p">;</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">Prescaler</code> enum values are already shifted in this example (hence the <code class="language-plaintext highlighter-rouge">(Bit5 | Bit4)</code> mask), however you can also declare the prescaler values non-shifted and let the wrapper shift it:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">Prescaler</span> <span class="o">:</span> <span class="kt">uint8_t</span>
<span class="p">{</span>
	<span class="n">Div1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">Div2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">Div4</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">Div8</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="n">Configuration</span><span class="o">&lt;</span><span class="n">Control_t</span><span class="p">,</span> <span class="n">Prescaler</span><span class="p">,</span> <span class="mb">0b11</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Prescaler_t</span><span class="p">;</span>
</code></pre></div></div> <p>Why? If you have two or more configurations with the same selections in the same register, you can simply add another one:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="n">Configuration</span><span class="o">&lt;</span> <span class="n">Control_t</span><span class="p">,</span> <span class="n">Prescaler</span><span class="p">,</span> <span class="mb">0b11</span><span class="p">,</span> <span class="mi">6</span> <span class="o">&gt;</span>  <span class="n">Prescaler2_t</span><span class="p">;</span>
</code></pre></div></div> <p>Configurations can be used inline:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Control_t</span> <span class="n">control</span> <span class="o">=</span> <span class="n">Control</span><span class="o">::</span><span class="n">EN</span> <span class="o">|</span> <span class="n">Prescaler_t</span><span class="p">(</span><span class="n">Prescaler</span><span class="o">::</span><span class="n">Div2</span><span class="p">);</span>
<span class="n">Control_t</span> <span class="n">control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">Prescaler_t</span><span class="o">::</span><span class="n">mask</span><span class="p">();</span>
</code></pre></div></div> <p>But do not have to:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Prescaler_t</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="n">Prescaler</span><span class="o">::</span><span class="n">Div2</span><span class="p">);</span>
<span class="n">Prescaler_t</span><span class="o">::</span><span class="n">reset</span><span class="p">(</span><span class="n">control</span><span class="p">);</span>
<span class="n">Prescaler</span> <span class="n">prescaler</span> <span class="o">=</span> <span class="n">Prescaler_t</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">control</span><span class="p">);</span>
</code></pre></div></div> <h4 id="register-values"> <a href="#register-values" class="anchor-head"></a> Register Values </h4> <p>Values are described using the <code class="language-plaintext highlighter-rouge">Value</code> <a href="http://xpcc.io/api/structxpcc_1_1_value.html">template class</a> which masks and shifts the value as required. In our example the value has a width of 3 bits and needs to be shifted 1 bit:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="n">Value</span><span class="o">&lt;</span> <span class="n">Control_t</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&gt;</span>  <span class="n">Delay_t</span><span class="p">;</span>
</code></pre></div></div> <p>This can be used the same way as the Configuration:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Control_t</span> <span class="n">control</span> <span class="o">=</span> <span class="n">Control</span><span class="o">::</span><span class="n">EN</span> <span class="o">|</span> <span class="n">Prescaler_t</span><span class="p">(</span><span class="n">Prescaler</span><span class="o">::</span><span class="n">Div2</span><span class="p">)</span> <span class="o">|</span> <span class="n">Delay_t</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="n">Control_t</span> <span class="n">control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">Delay_t</span><span class="o">::</span><span class="n">mask</span><span class="p">();</span>

<span class="n">Delay_t</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="n">Delay_t</span><span class="o">::</span><span class="n">reset</span><span class="p">(</span><span class="n">control</span><span class="p">);</span>
<span class="kt">uint8_t</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">Delay_t</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">control</span><span class="p">);</span>
</code></pre></div></div> <h4 id="efficiency"> <a href="#efficiency" class="anchor-head"></a> Efficiency </h4> <p>These classes are using as much <code class="language-plaintext highlighter-rouge">constexpr</code> as possible, so constexpr constructors, constexpr operator overloading and constexpr methods. This means whatever can be computed at compile time, will be computed at compile time.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Control_t</span> <span class="n">control</span> <span class="o">=</span> <span class="n">Control</span><span class="o">::</span><span class="n">EN</span> <span class="o">|</span> <span class="n">Prescaler_t</span><span class="p">(</span><span class="n">Prescaler</span><span class="o">::</span><span class="n">Div2</span><span class="p">)</span> <span class="o">|</span> <span class="n">Delay_t</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="c1">// is just fancy syntax sugar coating for</span>
<span class="kt">uint8_t</span> <span class="n">control</span> <span class="o">=</span> <span class="mh">0xA4</span><span class="p">;</span>
</code></pre></div></div> <p>Of course if your Configuration or Value class has to extract a value at runtime, the masking and shifting will happen at runtime. Not all that surprising.</p> <h2 id="what-about-the-bus"> <a href="#what-about-the-bus" class="anchor-head"></a> What About The Bus? </h2> <p>The above code works on a copy of the register content in the hosts RAM. To understand why this makes a lot of sense for external devices, consider the accelerometer memory map from previously:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rw: | Config1 | Config2 | Config3 | Config4 |
       0x20      0x21      0x22      0x23

ro: | Status | XL | XH | YL | YH | ZL | ZH |
       0x30   0x31 0x32 0x33 0x34 0x35 0x36
</code></pre></div></div> <p>In our device driver we would reserve 4 bytes for buffering the configuration registers, 1 byte for the status register and 6 bytes for the data.</p> <p>Usually, configuration registers are not changed by the external hardware itself, so you can modify the local copy of the configuration register and then only need to write the result once to the external hardware. During device driver initialization you can also prepare all configuration registers and then write all 4 at once.</p> <p>Similarly the status and data bytes can be read in one bus access and buffered locally for further computations.</p> <p>At the very basic level, the driver needs to provide functions to update the registers content:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span>        <span class="c1">// bool because bus access can fail</span>
<span class="n">updateControl</span><span class="p">(</span><span class="n">Control_t</span> <span class="n">setMask</span><span class="p">,</span> <span class="n">Control_t</span> <span class="n">clearMask</span> <span class="o">=</span> <span class="n">Control_t</span><span class="p">(</span><span class="mh">0xff</span><span class="p">));</span>

<span class="n">Control_t</span>
<span class="nf">getControl</span><span class="p">();</span>
<span class="p">{</span>  <span class="k">return</span> <span class="n">Control_t</span><span class="p">(</span><span class="n">rawBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>  <span class="p">}</span>

<span class="n">updateControl</span><span class="p">(</span><span class="n">Control</span><span class="o">::</span><span class="n">FS</span><span class="p">,</span> <span class="n">Control</span><span class="o">::</span><span class="n">EN</span><span class="p">);</span>
<span class="c1">// is equivalent to</span>
<span class="n">Control_t</span> <span class="n">control</span> <span class="o">=</span> <span class="n">getControl</span><span class="p">();</span>
<span class="n">control</span> <span class="o">&amp;=</span> <span class="n">Control</span><span class="o">::</span><span class="n">EN</span><span class="p">;</span>
<span class="n">control</span> <span class="o">|=</span> <span class="n">Control</span><span class="o">::</span><span class="n">FS</span><span class="p">;</span>
<span class="n">updateControl</span><span class="p">(</span><span class="n">control</span><span class="p">);</span>
</code></pre></div></div> <p>However providing meaningful setters and getters makes your code much more usable:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span>
<span class="nf">enable</span><span class="p">()</span>
<span class="p">{</span>  <span class="k">return</span> <span class="n">updateControl</span><span class="p">(</span><span class="n">Control</span><span class="o">::</span><span class="n">EN</span><span class="p">,</span> <span class="n">Control_t</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>  <span class="p">}</span>

<span class="kt">bool</span>
<span class="nf">disable</span><span class="p">()</span>
<span class="p">{</span>  <span class="k">return</span> <span class="n">updateControl</span><span class="p">(</span><span class="n">Control_t</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Control</span><span class="o">::</span><span class="n">EN</span><span class="p">);</span>  <span class="p">}</span>

<span class="kt">bool</span>
<span class="nf">setPrescaler</span><span class="p">(</span><span class="n">Prescaler</span> <span class="n">prescaler</span><span class="p">)</span>
<span class="p">{</span>  <span class="k">return</span> <span class="n">updateControl</span><span class="p">(</span><span class="n">prescaler</span><span class="p">,</span> <span class="n">Prescaler_t</span><span class="o">::</span><span class="n">mask</span><span class="p">());</span>  <span class="p">}</span>

<span class="n">Prescaler</span> <span class="nf">getPrescaler</span><span class="p">()</span>
<span class="p">{</span>  <span class="k">return</span> <span class="n">Prescaler_t</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">getControl</span><span class="p">());</span>  <span class="p">}</span>
</code></pre></div></div> <p>For working examples of this concept have a look at the <a href="http://xpcc.io/api/classxpcc_1_1_itg3200.html">ITG3200</a>, <a href="http://xpcc.io/api/classxpcc_1_1_lis302dl.html">LIS302</a> and <a href="http://xpcc.io/api/classxpcc_1_1_lis3dsh.html">LIS3DSH</a> device drivers. These drivers use <a href="http://xpcc.io/api/group__resumable.html">resumable functions</a> to make bus access non-blocking.</p> <h2 id="conclusions"> <a href="#conclusions" class="anchor-head"></a> Conclusions </h2> <ol> <li>Don’t bother with a pure C++ model of your internal memory.</li> <li>Better invest the time in a useful hardware abstraction layer.</li> <li>Buffer often accessed registers of external devices locally.</li> <li>Use the typesafe C++ access classes for these registers as presented.</li> <li>Be aware of the overhead of using an external bus.</li> </ol> <p><em>This post was first published at blog.xpcc.io.</em></p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p>D seems to be a lot better suited for compile time evaluations than C++. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:2" role="doc-endnote"> <p>This is different from dektop-class CPUs, where even the internal bus is magnitudes slower than the CPU. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:3" role="doc-endnote"> <p>You actually need to use <code class="language-plaintext highlighter-rouge">XPCC_FLAGS8(Control)</code>, which expands to <code class="language-plaintext highlighter-rouge">typedef Flags8&lt;Control&gt; Control_t;</code> and some magic enum operator overloading. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:4" role="doc-endnote"> <p>While researching for this post I discovered an almost identical <a href="https://github.com/grisumbras/enum-flags"><code class="language-plaintext highlighter-rouge">flags</code> class on Github</a>. However, it is not written for embedded targets and has a slightly different field of application. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </article> </main> <nav class="post-nav"> <a class="post-nav-item post-nav-next" href="/computing-baudrates-at-compile-time/"> <div class="nav-arrow">Next</div> <span class="post-title">Computing and Asserting Baudrate Settings at Compile Time</span> </a> </nav> <footer class="footer"> <a class="footer_item" href="/feed.xml">rss</a> <span class="footer_item">&copy; 2021</span> <small class="footer_copyright"> <!-- Klisé Theme: https://github.com/piharpi/jekyll-klise --> <a href="https://github.com/piharpi/jekyll-klise" target="_blank" rel="noreferrer noopener" >klisé</a > theme on <a href="https://jekyllrb.com" target="_blank" rel="noreferrer noopener" >jekyll</a > </small> </footer> <script src="/assets/js/main.js" defer="defer"></script> </div> </body> </html>
