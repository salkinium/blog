<!DOCTYPE html> <html lang="en-US"> <head prefix="og: http://ogp.me/ns#"> <meta charset="UTF-8" /> <meta http-equiv="X-UA-Compatible" content="ie=edge" /> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <meta name="mobile-web-app-capable" content="yes" /> <meta name="apple-mobile-web-app-capable" content="yes" /> <meta name="application-name" content="embedded entanglement" /> <meta name="apple-mobile-web-app-status-bar-style" content="#fff" /> <meta name="apple-mobile-web-app-title" content="embedded entanglement" /> <title> Computing and Asserting Baudrate Settings at Compile Time - embedded entanglement </title> <link rel="alternate" href="http://blog.salkinium.com/computing-baudrates-at-compile-time/" hreflang="en-US" /> <link rel="canonical" href="http://blog.salkinium.com/computing-baudrates-at-compile-time/" /> <meta name="description" content="reflecting on embedded software development" /> <meta name="referrer" content="no-referrer-when-downgrade" /> <meta property="fb:app_id" content="" /> <meta property="og:site_name" content="Computing and Asserting Baudrate Settings at Compile Time | Niklas Hauser" /> <meta property="og:title" content="Computing and Asserting Baudrate Settings at Compile Time | Niklas Hauser" /> <meta property="og:type" content="website" /> <meta property="og:url" content="http://blog.salkinium.com/computing-baudrates-at-compile-time/" /> <meta property="og:description" content="reflecting on embedded software development" /> <meta property="og:image" content="" /> <meta property="og:image:width" content="640" /> <meta property="og:image:height" content="640" /> <meta name="twitter:card" content="summary" /> <meta name="twitter:title" content="Computing and Asserting Baudrate Settings at Compile Time | salkinium" /> <meta name="twitter:url" content="http://blog.salkinium.com/computing-baudrates-at-compile-time/" /> <meta name="twitter:site" content="@salkinium" /> <meta name="twitter:creator" content="@salkinium" /> <meta name="twitter:description" content="reflecting on embedded software development" /> <meta name="twitter:image" content="" /> <link type="application/atom+xml" rel="alternate" href="http://blog.salkinium.com/feed.xml" title="embedded entanglement" /> <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicons/apple-touch-icon.png" /> <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png" /> <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png" /> <link rel="manifest" href="/assets/favicons/site.webmanifest" /> <link rel="mask-icon" href="/assets/favicons/safari-pinned-tab.svg" color="#5bbad5" /> <meta name="apple-mobile-web-app-title" content="Jekyll Klise" /> <meta name="application-name" content="Jekyll Klise" /> <meta name="msapplication-TileColor" content="#da532c" /> <meta name="theme-color" content="#2c2c2c" /> <link rel="stylesheet" href="/assets/css/style.css" /> </head> <body data-theme="dark" class="notransition"> <script> const body = document.body; const data = body.getAttribute("data-theme"); const initTheme = (state) => { if (state === "dark") { body.setAttribute("data-theme", "dark"); } else if (state === "light") { body.removeAttribute("data-theme"); } else { localStorage.setItem("theme", data); } }; initTheme(localStorage.getItem("theme")); setTimeout(() => body.classList.remove("notransition"), 75); </script> <div class="navbar" role="navigation"> <nav class="menu"> <input type="checkbox" id="menu-trigger" class="menu-trigger" /> <label for="menu-trigger"> <span class="menu-icon"> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <path d="M64,384H448V341.33H64Zm0-106.67H448V234.67H64ZM64,128v42.67H448V128Z" /> </svg> </span> </label> <a id="mode"> <svg class="mode-sunny" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <title>LIGHT</title> <line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> </svg> <svg class="mode-moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <title>DARK</title> <line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> </svg> </a> <div class="trigger"> <div class="trigger-container"><a class="menu-link" href="/">home</a><a class="menu-link" href="/archive/">archive</a><a class="menu-link" href="https://salkinium.com" target="_blank" rel="noopener" >about</a ><a class="menu-link rss" href="/feed.xml"> <svg xmlns="http://www.w3.org/2000/svg" width="17" height="17" viewBox="0 0 512 512" fill="#ED812E" > <title>RSS</title> <path d="M108.56,342.78a60.34,60.34,0,1,0,60.56,60.44A60.63,60.63,0,0,0,108.56,342.78Z" /> <path d="M48,186.67v86.55c52,0,101.94,15.39,138.67,52.11s52,86.56,52,138.67h86.66C325.33,312.44,199.67,186.67,48,186.67Z" /> <path d="M48,48v86.56c185.25,0,329.22,144.08,329.22,329.44H464C464,234.66,277.67,48,48,48Z" /> </svg> </a> </div> </div> </nav> </div> <div class="wrapper post"> <main class="page-content" aria-label="Content"> <article itemscope itemtype="https://schema.org/BlogPosting"> <header class="header"> <h1 class="header-title" itemprop="headline">Computing and Asserting Baudrate Settings at Compile Time</h1> <div class="post-meta"> <time datetime="2015-06-08T00:00:00+02:00" itemprop="datePublished"> Jun 08, 2015 </time> <span itemprop="author" itemscope itemtype="https://schema.org/Person"> <span itemprop="name">Niklas Hauser</span> </span> <time hidden datetime="" itemprop="dateModified"> Jun 08, 2015 </time> <span hidden itemprop="publisher" itemtype="Person">Niklas Hauser</span> <span hidden itemprop="image"></span> <span hidden itemprop="mainEntityOfPage"><p>Prescaler and baudrate calculations are a tricky topic. I have had many situations where the baudrate turned out to be off by a couple of percent, which was enough to render my serial output streams unreadable. Sure, calculating the baudrate error beforehand would have saved me some hours of useless debugging, however, that would require understanding the often complicated mathematical formula hidden somewhere in the depths of the datasheet describing the prescaler vs. baudrate relationship.</p> <p>And <em>that</em> seemed to be more work than just using a logic analyzer to measure the resulting error. Of course, this felt like using a sledgehammer to crack a nut and it was neither a fast nor practical solution.</p> <p>I think there exists a better solution and I think it can be done using pure C++. This solution needs to be able to:</p> <ol> <li>compute the best possible prescaler settings for the desired baudrate, and</li> <li>notify me when the desired baudrate cannot be achieved without unresonable error.</li> </ol> </span> </div> </header> <div class="page-content" itemprop="articleBody"> <p>Prescaler and baudrate calculations are a tricky topic. I have had many situations where the baudrate turned out to be off by a couple of percent, which was enough to render my serial output streams unreadable. Sure, calculating the baudrate error beforehand would have saved me some hours of useless debugging, however, that would require understanding the often complicated mathematical formula hidden somewhere in the depths of the datasheet describing the prescaler vs. baudrate relationship.</p> <p>And <em>that</em> seemed to be more work than just using a logic analyzer to measure the resulting error. Of course, this felt like using a sledgehammer to crack a nut and it was neither a fast nor practical solution.</p> <p>I think there exists a better solution and I think it can be done using pure C++. This solution needs to be able to:</p> <ol> <li>compute the best possible prescaler settings for the desired baudrate, and</li> <li>notify me when the desired baudrate cannot be achieved without unresonable error.</li> </ol> <!--more--> <h2 id="qualifying-baudrates"> <a href="#qualifying-baudrates" class="anchor-head"></a> Qualifying Baudrates </h2> <p>An important characteristic of clock prescalers is their finite range and resolution, which has an obvious impact on baudrate generation.</p> <p>Let’s look at the characteristics of the three most commonly used prescalers:</p> <ol> <li>the power-of-two prescaler,</li> <li>the linear prescaler, and</li> <li>the fractional prescaler.</li> </ol> <h4 id="power-of-two"> <a href="#power-of-two" class="anchor-head"></a> Power of Two </h4> <p>This type of prescaler is often used to clock peripherals which do not require a high resolution and can operate in a wide range of frequencies such as ADCs and even SPI. It’s behaviour is described by this formula:</p> <center> <p><img invertible="" src="prescaler_power_of_two.svg" /></p> </center> <h4 id="linear"> <a href="#linear" class="anchor-head"></a> Linear </h4> <p>Linear prescalers are the most common type of prescaler found in microcontrollers. They typically generate clocks for timers and synchonous communication peripherals such as I<sup>2</sup>C and SPI. Since the divisor must not be zero for obvious reasons, the input values are either mapped so that writing a zero turns the peripheral off, or the hardware adds a one to the input (mapping 0⟶1, 1⟶2, etc…).</p> <center> <p><img invertible="" src="prescaler_linear.svg" /></p> </center> <h4 id="fractional"> <a href="#fractional" class="anchor-head"></a> Fractional </h4> <p>This prescaler is used whenever a clock is required, which cannot be generated purely by integer division. The most typical application is baudrate generation for asynchronous communication such as UART. The divisor is usually formatted as a fixed point binary fractional. It must be understood that these prescalers cannot generate a <em>true</em> fractional output frequency, but use a <a href="http://en.wikipedia.org/wiki/Dual-modulus_prescaler">dual-modulus hardware logic</a>, so that the desired output frequency is met <strong>on average</strong>!</p> <center> <p><img invertible="" src="prescaler_fractional.svg" /></p> </center> <h4 id="analysis"> <a href="#analysis" class="anchor-head"></a> Analysis </h4> <p>Here is the graphical comparison of these three prescaler functions, plotting 10 input values onto the normalized output value for all three functions. The power-of-two prescaler is light gray, the linear prescaler dark gray and is overlaid on the fractional prescaler:</p> <center> <p><img invertible="" src="prescaler_graphs.svg" /></p> </center> <p>There are three very interesting observations to be made:</p> <ol> <li>the power-of-two prescaler falls a lot faster than the others: In 10 steps it reaches <sup>1</sup>/<sub>1024</sub> instead of <sup>1</sup>/<sub>10</sub> for the linear prescaler.</li> <li>neither the power-of-two nor the linear prescaler can generate anything between 1.0 and 0.5.</li> <li>the distribution of generatable output frequencies is (obviously) not evenly spaced.</li> </ol> <p>All prescalers are not particularly suited to generate high arbitrary output frequencies. This also goes for the fractional prescaler, which can only switch between two fixed frequencies.</p> <p>Assume you have a SPI slave that can be clocked up to 30 MHz, however your primary clock input is 40 MHz. A fractional prescaler will clock the slave half the time with 40 MHz and the other half with 20 MHz to achieve the desired 30 MHz on average. However, the slave might start to glitch on the 40 MHz part of the clocking, due to its electrical and timing characteristics, therefore this is not a practical solution.</p> <h2 id="choosing-divisors"> <a href="#choosing-divisors" class="anchor-head"></a> Choosing Divisors </h2> <p>So now that we know the formulas and properties of the most common prescalers, let’s find out how we can choose the best divisor for a desired baudrate.</p> <p>Between two generatable baudrates <em>B<sub>n</sub></em> and <em>B<sub>n+1</sub></em> lies a half-point for which there is an equal amount of baudrate error when choosing either <em>n</em> or <em>n+1</em> as a divisor. The formula for calculating this half-point is trivial:</p> <center> <p><img invertible="" src="prescaler_half_point.svg" /></p> </center> <p>So the general approach here is to find an divisor pair (<em>n, n+1</em>) so that the desired baudrate <em>B<sub>d</sub></em> lies between <em>B<sub>n</sub></em> and <em>B<sub>n+1</sub></em> and then choose the divisor whose baudrate is closer to the desired one. So if <em>B<sub>d</sub></em> is above the half-point, we choose <em>n</em>, otherwise <em>n+1</em>.</p> <p>It is important to understand that we <strong>cannot</strong> use this approach on the divisors directly, since there is no linear correlation between the input and output frequency. This becomes clear in the prescaler plot above, where the half-point between 1.0 and 0.5 for the linear prescaler clearly does not lie on divisor 1.5, but somewhere around 1.3!</p> <h4 id="power-of-two-1"> <a href="#power-of-two-1" class="anchor-head"></a> Power of Two </h4> <p>However, with some more math we can calculate the exact divisor <em>ratio</em> of this half-point. We start with the power-of-two prescaler, where <em>B<sub>n+1</sub></em> is always half of <em>B<sub>n</sub></em>:</p> <center> <p><img invertible="" src="prescaler_p2_1.svg" /></p> </center> <p>By entering these into our half-point formula we get:</p> <center> <p><img invertible="" src="prescaler_p2_2.svg" /></p> </center> <p>However, since we wanted a divisor and not a baudrate, we divide the input frequency with the half-point baudrate:</p> <center> <p><img invertible="" src="prescaler_p2_3.svg" /></p> </center> <p>Choosing the divisor with the least error for any desired baudrate becomes easy now. Here is a code example (taken from the <a href="https://github.com/roboterclubaachen/xpcc/blob/develop/src/xpcc/architecture/platform/driver/spi/at90_tiny_mega/spi_master.hpp.in?ts=4#L69">AVR’s SPI module</a>):</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">desired_div</span> <span class="o">=</span> <span class="n">input_frequency</span> <span class="o">/</span> <span class="n">desired_baudrate</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">nearest_div</span> <span class="o">=</span> <span class="p">(</span>
	<span class="p">(</span><span class="n">desired_div</span> <span class="o">&gt;=</span> <span class="p">(</span> <span class="mi">64</span> <span class="o">*</span> <span class="mf">4.</span><span class="n">f</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span> <span class="o">?</span> <span class="mi">128</span> <span class="o">:</span> <span class="p">(</span>
	<span class="p">(</span><span class="n">desired_div</span> <span class="o">&gt;=</span> <span class="p">(</span> <span class="mi">32</span> <span class="o">*</span> <span class="mf">4.</span><span class="n">f</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span> <span class="o">?</span>  <span class="mi">64</span> <span class="o">:</span> <span class="p">(</span>
	<span class="p">(</span><span class="n">desired_div</span> <span class="o">&gt;=</span> <span class="p">(</span> <span class="mi">16</span> <span class="o">*</span> <span class="mf">4.</span><span class="n">f</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span> <span class="o">?</span>  <span class="mi">32</span> <span class="o">:</span> <span class="p">(</span>
	<span class="p">(</span><span class="n">desired_div</span> <span class="o">&gt;=</span> <span class="p">(</span>  <span class="mi">8</span> <span class="o">*</span> <span class="mf">4.</span><span class="n">f</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span> <span class="o">?</span>  <span class="mi">16</span> <span class="o">:</span> <span class="p">(</span>
	<span class="p">(</span><span class="n">desired_div</span> <span class="o">&gt;=</span> <span class="p">(</span>  <span class="mi">4</span> <span class="o">*</span> <span class="mf">4.</span><span class="n">f</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span> <span class="o">?</span>   <span class="mi">8</span> <span class="o">:</span> <span class="p">(</span>
	<span class="p">(</span><span class="n">desired_div</span> <span class="o">&gt;=</span> <span class="p">(</span>  <span class="mi">2</span> <span class="o">*</span> <span class="mf">4.</span><span class="n">f</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span> <span class="o">?</span>   <span class="mi">4</span> <span class="o">:</span>
									   <span class="mi">2</span>
	<span class="p">))))));</span>
</code></pre></div></div> <p>First the divisor of the input frequency and the desired baudrate is computed. This divisor is then compared with all half-point divisors of our prescaler and the best value is chosen.</p> <p>Notice how this algorithm will choose a divisor of 128 when the desired baudrate is too slow, and a divisor of 2 when it is too fast. This mirrors the range limitation of the AVR’s SPI prescaler!</p> <h4 id="linear-1"> <a href="#linear-1" class="anchor-head"></a> Linear </h4> <p>Unfortunately this elegant solution is not available for the properties of the linear prescaler. Here <em>B<sub>n</sub></em> and <em>B<sub>n+1</sub></em> are defined as follows:</p> <center> <p><img invertible="" src="prescaler_lin_1.svg" /></p> </center> <p>Using these definition in our half-point formula gets us nowhere really:</p> <center> <p><img invertible="" src="prescaler_lin_2.svg" /></p> </center> <p>And the half-point divisor is just insulting:</p> <center> <p><img invertible="" src="prescaler_lin_3.svg" /></p> </center> <p>However, a quick look at the value table of this formula does reinforce a suspicion:</p> <table> <thead> <tr> <th style="text-align: center"><em>n</em></th> <th style="text-align: center"><em>d<sub>half(n)</sub></em></th> <th style="text-align: center">approx.</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">1</td> <td style="text-align: center">4/3</td> <td style="text-align: center">1.33333</td> </tr> <tr> <td style="text-align: center">2</td> <td style="text-align: center">12/5</td> <td style="text-align: center">2.40000</td> </tr> <tr> <td style="text-align: center">3</td> <td style="text-align: center">24/7</td> <td style="text-align: center">3.42857</td> </tr> <tr> <td style="text-align: center">4</td> <td style="text-align: center">40/9</td> <td style="text-align: center">4.44444</td> </tr> <tr> <td style="text-align: center">5</td> <td style="text-align: center">60/11</td> <td style="text-align: center">5.45455</td> </tr> <tr> <td style="text-align: center">6</td> <td style="text-align: center">84/13</td> <td style="text-align: center">6.46154</td> </tr> <tr> <td style="text-align: center">7</td> <td style="text-align: center">112/15</td> <td style="text-align: center">7.46667</td> </tr> <tr> <td style="text-align: center">8</td> <td style="text-align: center">144/17</td> <td style="text-align: center">8.47059</td> </tr> <tr> <td style="text-align: center">9</td> <td style="text-align: center">180/19</td> <td style="text-align: center">9.47368</td> </tr> </tbody> </table> <p>The divisors seem to approach <em>(n + 1/2)</em> for larger values, which is indeed the case and becomes clear when looking at the series expansion for <em>n</em> to infinity:</p> <center> <p><img invertible="" src="prescaler_lin_4.svg" /></p> </center> <p>Not that this is of any help to us, it’s just nice to know ☺</p> <h4 id="fractional-1"> <a href="#fractional-1" class="anchor-head"></a> Fractional </h4> <p>Just… no. It doesn’t get better.</p> <h4 id="generic"> <a href="#generic" class="anchor-head"></a> Generic </h4> <p>Okay, so even after this small binge into the underlying mathematics we still do not know how to choose a divisor for linear and fractional prescalers.</p> <p>There is of course a generic solution where we just brute force this:</p> <ol> <li>compute the desired divisor for the desired baudrate,</li> <li>get <em>n</em> and <em>n+1</em> using <em>floor(desired_div)</em> and <em>ceil(desired_div)</em>,</li> <li>compute the according baudrates <em>B<sub>n</sub></em> and <em>B<sub>n+1</sub></em>,</li> <li>compare with the half-point baudrate and choose accordingly.</li> </ol> <p>Here is a code example of this algorithm (taken from the <a href="https://github.com/roboterclubaachen/xpcc/blob/develop/src/xpcc/architecture/platform/driver/uart/at90_tiny_mega/uart.hpp.in?ts=4#L66">AVR’s UART module</a>):</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// calculate the fractional prescaler value</span>
<span class="kt">float</span> <span class="n">desired</span> <span class="o">=</span> <span class="n">input_frequency</span> <span class="o">/</span> <span class="n">desired_baudrate</span><span class="p">;</span>
<span class="c1">// respect the prescaler range of 1 to 4096</span>
<span class="kt">int</span> <span class="n">div_floor</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">floor</span><span class="p">(</span><span class="n">desired</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">floor</span><span class="p">(</span><span class="n">desired</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">div_ceil</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">ceil</span><span class="p">(</span><span class="n">desired</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4096</span> <span class="o">?</span> <span class="mi">4096</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">ceil</span><span class="p">(</span><span class="n">desired</span><span class="p">);</span>

<span class="c1">// calculate the baudrates above and below the requested baudrate</span>
<span class="kt">int</span> <span class="n">baud_lower</span> <span class="o">=</span> <span class="n">input_frequency</span> <span class="o">/</span> <span class="n">div_ceil</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">baud_upper</span> <span class="o">=</span> <span class="n">input_frequency</span> <span class="o">/</span> <span class="n">div_floor</span><span class="p">;</span>

<span class="c1">// calculate the half-point between the upper and lower baudrate</span>
<span class="kt">int</span> <span class="n">baud_middle</span> <span class="o">=</span> <span class="p">(</span><span class="n">baud_upper</span> <span class="o">+</span> <span class="n">baud_lower</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="c1">// decide which divisor is closer to a possible baudrate</span>
<span class="c1">// lower baudrate means higher divisor!</span>
<span class="kt">int</span> <span class="n">nearest</span> <span class="o">=</span> <span class="p">(</span><span class="n">baudrate</span> <span class="o">&lt;</span> <span class="n">baud_middle</span><span class="p">)</span> <span class="o">?</span> <span class="n">div_ceil</span> <span class="o">:</span> <span class="n">div_floor</span><span class="p">;</span>
<span class="c1">// map to correct range (0 is 1, 1 is 2, etc…)</span>
<span class="kt">int</span> <span class="n">prescaler</span> <span class="o">=</span> <span class="n">nearest</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div> <p>This algorithm can be adapted to work with non-continuous ranges (as in <em>2<sup>n</sup></em> for the power-of-two prescaler) and also with fractional prescaler using binary scaling.</p> <h2 id="choosing-tolerances"> <a href="#choosing-tolerances" class="anchor-head"></a> Choosing Tolerances </h2> <p>Although these algorithms will choose the divisor with the least baudrate error, we want to have some form of control over <em>how much</em> error is still acceptable.</p> <p>We are only looking at relative error which is defined as:</p> <center> <p><img invertible="" src="prescaler_relative_error.svg" /></p> </center> <p>A set of default tolerances should be chosen so that without any effort required from the programmer, they act as a useful guard against unreasonable baudrate errors. So, how much error is still acceptable?</p> <p>For internal peripherals like ADCs, which usually have a power-of-two prescaler and can operate in a wide range of frequencies, we chose a ±10% default tolerance.</p> <p>For synchronous protocols such as SPI and I<sup>2</sup>C, the master clocks the bus and the exact baudrate does not really matter. Of course, when operating the aforementioned SPI slave at 30 MHz you want to be reasonably certain that you aren’t clocking it at 35 MHz, which causes it to glitch. So for xpcc we chose a ±5% default tolerance.</p> <p>However, asynchronous protocols simply do not allow for much tolerance. The relative baudrate error tolerance for UART with 8N1 configuration (8 databits, 1 startbit and 1 stopbit) as shown below is only ±5%. The sample point of the stop bit may only shift by at most ±<em>t<sub>Symbol</sub> /2</em> and with 10 bits to read, one <em>t<sub>Symbol</sub></em> equals one tenth of the symbol transmission time, hence a relative tolerance of ±5%. For example, the tolerance for 7-bit transfers (9 baudtimes) increases to ±5.56%.</p> <center> <p><img invertible="" src="prescaler_uart.svg" width="500" /></p> </center> <p>However, since both transmitter and receiver may not generate the exact baudrate, the error must not exceed <strong>±5% in total</strong>, which in the worst case (one too fast, one too slow) imposes a tight allowed deviation of +2.5% and -2.5% on the modules respectively. In xpcc we therefore chose ±2% default tolerance for linear prescalers and ±1% for fractional prescalers.</p> <p>If a generated baudrate is found to be outside of the default tolerance, this information must be conveyed to the programmer! Of course, (s)he must able to overwrite the default tolerances to make them more or less restrictive, depending on the application.</p> <h2 id="at-compile-time"> <a href="#at-compile-time" class="anchor-head"></a> At Compile Time </h2> <p>Now, we could slack off and just implement all this at runtime. There are a couple of issues with this on a microcontroller:</p> <ol> <li>It’s simply inefficient: How often do you set your baudrates? Once?</li> <li>How do you communicate to the programmer that your generated baudrate is above your declared tolerance? Serial output?</li> <li>What is the runtime supposed to do with a test failure? Automatically switch to another baudrate?</li> </ol> <p>Especially on AVRs the computational toll of using floating point and 32bit values to compute a one-time value is quite immense. Even if you have multiple baudrates that you need to switch to at runtime, it is cheaper in both storage and execution time to use a lookup table!</p> <p>However, the second and third points are the real culprit. It would be plain stupid to even attempt to output an error string over UART that the generated (UART) baudrate is outside of the declared tolerance. Automatically switching to another baudrate is even more stupid, as this defies the purpose of having chosen a particular baudrate.</p> <p>No, this is a problem that can and must be solved at compile time. Fortunately with C++11 is has become possible to use constexpr functions and static assertions, which make compile-time computation and communication a lot easier.</p> <h4 id="implementation"> <a href="#implementation" class="anchor-head"></a> Implementation </h4> <p>Here is the full compile-time implementation of the AVR’s SPI initialize method:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Initializes the hardware and sets the baudrate.
 *
 * @tparam	SystemClock
 * 		the currently active system clock
 * @tparam	baudrate
 * 		the desired baudrate in Hz
 * @tparam	tolerance
 * 		the allowed relative tolerance for the resulting baudrate
 */</span>
<span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">SystemClock</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">baudrate</span><span class="p">,</span>
		<span class="kt">uint16_t</span> <span class="n">tolerance</span> <span class="o">=</span> <span class="n">Tolerance</span><span class="o">::</span><span class="n">FivePercent</span> <span class="p">&gt;</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">initialize</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// calculate the nearest prescaler from the baudrate</span>
	<span class="k">constexpr</span> <span class="kt">float</span> <span class="n">desired</span> <span class="o">=</span> <span class="kt">float</span><span class="p">(</span><span class="n">SystemClock</span><span class="o">::</span><span class="n">Spi</span><span class="p">)</span> <span class="o">/</span> <span class="n">baudrate</span><span class="p">;</span>
	<span class="k">constexpr</span> <span class="kt">uint8_t</span> <span class="n">nearest</span> <span class="o">=</span> <span class="p">(</span>
			<span class="p">(</span><span class="n">nearest</span> <span class="o">&gt;=</span> <span class="p">(</span> <span class="mi">64</span> <span class="o">*</span> <span class="mf">4.</span><span class="n">f</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span> <span class="o">?</span> <span class="mi">128</span> <span class="o">:</span> <span class="p">(</span>
			<span class="p">(</span><span class="n">nearest</span> <span class="o">&gt;=</span> <span class="p">(</span> <span class="mi">32</span> <span class="o">*</span> <span class="mf">4.</span><span class="n">f</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span> <span class="o">?</span>  <span class="mi">64</span> <span class="o">:</span> <span class="p">(</span>
			<span class="p">(</span><span class="n">nearest</span> <span class="o">&gt;=</span> <span class="p">(</span> <span class="mi">16</span> <span class="o">*</span> <span class="mf">4.</span><span class="n">f</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span> <span class="o">?</span>  <span class="mi">32</span> <span class="o">:</span> <span class="p">(</span>
			<span class="p">(</span><span class="n">nearest</span> <span class="o">&gt;=</span> <span class="p">(</span>  <span class="mi">8</span> <span class="o">*</span> <span class="mf">4.</span><span class="n">f</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span> <span class="o">?</span>  <span class="mi">16</span> <span class="o">:</span> <span class="p">(</span>
			<span class="p">(</span><span class="n">nearest</span> <span class="o">&gt;=</span> <span class="p">(</span>  <span class="mi">4</span> <span class="o">*</span> <span class="mf">4.</span><span class="n">f</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span> <span class="o">?</span>   <span class="mi">8</span> <span class="o">:</span> <span class="p">(</span>
			<span class="p">(</span><span class="n">nearest</span> <span class="o">&gt;=</span> <span class="p">(</span>  <span class="mi">2</span> <span class="o">*</span> <span class="mf">4.</span><span class="n">f</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span> <span class="o">?</span>   <span class="mi">4</span> <span class="o">:</span>
										   <span class="mi">2</span>
			<span class="p">))))));</span>

	<span class="c1">// check if we found a prescaler which generates</span>
	<span class="c1">// a baudrate within the declared tolerance</span>
	<span class="n">assertBaudrateInTolerance</span><span class="o">&lt;</span>
			<span class="n">SystemClock</span><span class="o">::</span><span class="n">Spi</span> <span class="o">/</span> <span class="n">nearest</span><span class="p">,</span>	<span class="c1">// available baudrate</span>
			<span class="n">baudrate</span><span class="p">,</span>					<span class="c1">// desired baudrate</span>
			<span class="n">tolerance</span> <span class="o">&gt;</span><span class="p">();</span>				<span class="c1">// allowed tolerance</span>

	<span class="c1">// translate the prescaler into the bitmapping</span>
	<span class="k">constexpr</span> <span class="n">Prescaler</span> <span class="n">prescaler</span> <span class="o">=</span> <span class="p">(</span>
			<span class="p">(</span><span class="n">nearest</span> <span class="o">&gt;=</span> <span class="mi">128</span><span class="p">)</span> <span class="o">?</span> <span class="n">Prescaler</span><span class="o">::</span><span class="n">Div128</span> <span class="o">:</span> <span class="p">(</span>
			<span class="p">(</span><span class="n">nearest</span> <span class="o">&gt;=</span>  <span class="mi">64</span><span class="p">)</span> <span class="o">?</span> <span class="n">Prescaler</span><span class="o">::</span><span class="n">Div64</span>  <span class="o">:</span> <span class="p">(</span>
			<span class="p">(</span><span class="n">nearest</span> <span class="o">&gt;=</span>  <span class="mi">32</span><span class="p">)</span> <span class="o">?</span> <span class="n">Prescaler</span><span class="o">::</span><span class="n">Div32</span>  <span class="o">:</span> <span class="p">(</span>
			<span class="p">(</span><span class="n">nearest</span> <span class="o">&gt;=</span>  <span class="mi">16</span><span class="p">)</span> <span class="o">?</span> <span class="n">Prescaler</span><span class="o">::</span><span class="n">Div16</span>  <span class="o">:</span> <span class="p">(</span>
			<span class="p">(</span><span class="n">nearest</span> <span class="o">&gt;=</span>   <span class="mi">8</span><span class="p">)</span> <span class="o">?</span> <span class="n">Prescaler</span><span class="o">::</span><span class="n">Div8</span>   <span class="o">:</span> <span class="p">(</span>
			<span class="p">(</span><span class="n">nearest</span> <span class="o">&gt;=</span>   <span class="mi">4</span><span class="p">)</span> <span class="o">?</span> <span class="n">Prescaler</span><span class="o">::</span><span class="n">Div4</span>   <span class="o">:</span>
							   <span class="n">Prescaler</span><span class="o">::</span><span class="n">Div2</span>
			<span class="p">))))));</span>

	<span class="c1">// do the actual initialization at runtime</span>
	<span class="n">initialize</span><span class="p">(</span><span class="n">prescaler</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>The primary algorithm has already been described before. What’s new is <code class="language-plaintext highlighter-rouge">SystemClock</code> which is a static class that contains the current clock tree configuration (also computed at compile time using similar methods). On the AVR this contains the compile-time constant <code class="language-plaintext highlighter-rouge">SystemClock::Spi</code> with the input clock frequency of the SPI peripheral. This unburdens the programmer to know from which clock domain the peripheral is clocked.</p> <p>The <code class="language-plaintext highlighter-rouge">assertBaudrateInTolerance</code> is given <em>B<sub>available</sub></em>, <em>B<sub>desired</sub></em> and the allowed tolerance and raises a <code class="language-plaintext highlighter-rouge">static_assert</code> if the test fails. The <code class="language-plaintext highlighter-rouge">nearest</code> divisor is then mapped onto the register bit representation and this is then used to initialize the prescaler and peripheral.</p> <p>And all of this happens at compile-time, the runtime only knows one 8bit program-space constant and simply copies it into the prescaler register.</p> <h4 id="usage"> <a href="#usage" class="anchor-head"></a> Usage </h4> <p>All the programmer has to write is this:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Spi</span><span class="o">::</span><span class="n">initialize</span><span class="o">&lt;</span><span class="n">systemClock</span><span class="p">,</span> <span class="n">MHz8</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// with ±5% tolerance</span>
</code></pre></div></div> <p>Should you want to change the SPI baudrate at runtime, you can do that simply by re-initializing with a different baudrate:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 4.4 MHz with explicit ±10% tolerance</span>
<span class="n">Spi</span><span class="o">::</span><span class="n">initialize</span><span class="o">&lt;</span><span class="n">systemClock</span><span class="p">,</span> <span class="mi">4400000</span><span class="p">,</span> <span class="n">xpcc</span><span class="o">::</span><span class="n">Tolerance</span><span class="o">::</span><span class="n">TenPercent</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div></div> <p>Changing prescaler values often requires the peripheral to be switched off and then restarted. Calling the <code class="language-plaintext highlighter-rouge">initialize</code> method again guarantees correct operation. The overhead of this is only the loading of the compile-time constant which contains the prescaler value for 4 MHz and a call to the real initialize method of the peripheral.</p> <p>If you have several baudrates that you need to choose at runtime, a switch-case “lookup table” is still more efficient than a computation at runtime (while guaranteeing tolerance compliance):</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span><span class="p">(</span><span class="n">baudrate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">case</span> <span class="mi">8000000</span><span class="p">:</span>
		<span class="n">Spi</span><span class="o">::</span><span class="n">initialize</span><span class="o">&lt;</span><span class="n">systemClock</span><span class="p">,</span> <span class="n">MHz8</span><span class="o">&gt;</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4000000</span><span class="p">:</span>
		<span class="n">Spi</span><span class="o">::</span><span class="n">initialize</span><span class="o">&lt;</span><span class="n">systemClock</span><span class="p">,</span> <span class="n">MHz4</span><span class="o">&gt;</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2000000</span><span class="p">:</span>
		<span class="n">Spi</span><span class="o">::</span><span class="n">initialize</span><span class="o">&lt;</span><span class="n">systemClock</span><span class="p">,</span> <span class="n">MHz2</span><span class="o">&gt;</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1000000</span><span class="p">:</span>
		<span class="n">Spi</span><span class="o">::</span><span class="n">initialize</span><span class="o">&lt;</span><span class="n">systemClock</span><span class="p">,</span> <span class="n">MHz1</span><span class="o">&gt;</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>It is apparent that the usage is incredibly simple.</p> <h4 id="on-failures"> <a href="#on-failures" class="anchor-head"></a> On Failures </h4> <p>Should the tolerance check fail, then the compiler will show you the baudrate it computed. Unfortunately the output is relatively unreadable, since there are templates involved. However, it’s still better than nothing, so stop complaining.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Here I want *exactly* 115.2kBaud! No problem.</span>
<span class="n">Uart</span><span class="o">::</span><span class="n">initialize</span><span class="o">&lt;</span><span class="n">systemClock</span><span class="p">,</span> <span class="mi">115200</span><span class="p">,</span> <span class="n">xpcc</span><span class="o">::</span><span class="n">Tolerance</span><span class="o">::</span><span class="n">Exact</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div></div> <p>Compiling the above example on an AVR clocked with 16MHz will lead to a static assertion failure, since the desired baudrate of 115.2kBaud cannot be generated:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interface.hpp: In instantiation of 'static void xpcc::Peripheral::assertBaudrateInTolerance() [with long unsigned int available = 111111ul; long unsigned int requested = 115200ul; unsigned int tolerance = 0u]':
...
interface.hpp:94:3: error: static assertion failed: The closest available baudrate exceeds the tolerance of the requested baudrate!
   static_assert(xpcc::Tolerance::isValueInTolerance(requested, available, tolerance),
</code></pre></div></div> <p>We can see that the closest available baudrate seems to be 111.1kBaud which has a full 3.5% relative error, which would not even have been allowed with the default tolerance.</p> <p>Now you can just start trying different baudrates, for example 38.4kBaud, which has almost no error with the actual baudrate being 38.461kBaud. Piece a cake, am I right?</p> <h2 id="conclusions"> <a href="#conclusions" class="anchor-head"></a> Conclusions </h2> <p>Apart from the technical elegance of computing these values at compile-time, there is a real improvement in the programmer’s experience of using prescalers:</p> <ol> <li>You are declaring <strong>what</strong> you want, not <strong>how</strong> to get it.</li> <li>You can now specify and enforce baudrate <em>quality</em> directly in your code.</li> <li>There is no need to read the datasheet anymore, trial and error suffices.</li> <li>The compiler can give you an alternative baudrate with <em>zero</em> error!</li> <li>Your code is your documentation, since tolerance compliance is enforced.</li> </ol> <p>Of course, the framework developers now have to do the grunt work of understanding how the prescaler works and implement the algorithms accordingly. However, the reward outweighs the effort many times over, and might save you a lot of time not having to debug your prescaler calculations.</p> <p><em>This post was first published at blog.xpcc.io.</em></p> </div> </article> </main> <nav class="post-nav"> <a class="post-nav-item post-nav-prev" href="/typesafe-register-access-in-c++/" > <div class="nav-arrow">Previous</div> <span class="post-title">Typesafe Register Access in C++</span> </a> <a class="post-nav-item post-nav-next" href="/xpccs-error-model/"> <div class="nav-arrow">Next</div> <span class="post-title">The Curious Case of xpcc's Error Model</span> </a> </nav> <footer class="footer"> <a class="footer_item" href="/feed.xml">rss</a> <span class="footer_item">&copy; 2021</span> <small class="footer_copyright"> <!-- Klisé Theme: https://github.com/piharpi/jekyll-klise --> <a href="https://github.com/piharpi/jekyll-klise" target="_blank" rel="noreferrer noopener" >klisé</a > theme on <a href="https://jekyllrb.com" target="_blank" rel="noreferrer noopener" >jekyll</a > </small> </footer> <script src="/assets/js/main.js" defer="defer"></script> </div> </body> </html>
