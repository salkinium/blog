<!DOCTYPE html> <html lang="en-US"> <head prefix="og: http://ogp.me/ns#"> <meta charset="UTF-8" /> <meta http-equiv="X-UA-Compatible" content="ie=edge" /> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <meta name="mobile-web-app-capable" content="yes" /> <meta name="apple-mobile-web-app-capable" content="yes" /> <meta name="application-name" content="embedded entanglement" /> <meta name="apple-mobile-web-app-status-bar-style" content="#fff" /> <meta name="apple-mobile-web-app-title" content="embedded entanglement" /> <title> The Curious Case of xpcc&#39;s Error Model - embedded entanglement </title> <link rel="alternate" href="http://blog.salkinium.com/xpccs-error-model/" hreflang="en-US" /> <link rel="canonical" href="http://blog.salkinium.com/xpccs-error-model/" /> <meta name="description" content="reflecting on embedded software development" /> <meta name="referrer" content="no-referrer-when-downgrade" /> <meta property="fb:app_id" content="" /> <meta property="og:site_name" content="The Curious Case of xpcc&#39;s Error Model | Niklas Hauser" /> <meta property="og:title" content="The Curious Case of xpcc&#39;s Error Model | Niklas Hauser" /> <meta property="og:type" content="website" /> <meta property="og:url" content="http://blog.salkinium.com/xpccs-error-model/" /> <meta property="og:description" content="reflecting on embedded software development" /> <meta property="og:image" content="" /> <meta property="og:image:width" content="640" /> <meta property="og:image:height" content="640" /> <meta name="twitter:card" content="summary" /> <meta name="twitter:title" content="The Curious Case of xpcc&#39;s Error Model | salkinium" /> <meta name="twitter:url" content="http://blog.salkinium.com/xpccs-error-model/" /> <meta name="twitter:site" content="@salkinium" /> <meta name="twitter:creator" content="@salkinium" /> <meta name="twitter:description" content="reflecting on embedded software development" /> <meta name="twitter:image" content="" /> <link type="application/atom+xml" rel="alternate" href="http://blog.salkinium.com/feed.xml" title="embedded entanglement" /> <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicons/apple-touch-icon.png" /> <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png" /> <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png" /> <link rel="manifest" href="/assets/favicons/site.webmanifest" /> <link rel="mask-icon" href="/assets/favicons/safari-pinned-tab.svg" color="#5bbad5" /> <meta name="apple-mobile-web-app-title" content="Jekyll Klise" /> <meta name="application-name" content="Jekyll Klise" /> <meta name="msapplication-TileColor" content="#da532c" /> <meta name="theme-color" content="#2c2c2c" /> <link rel="stylesheet" href="/assets/css/style.css" /> </head> <body data-theme="dark" class="notransition"> <script> const body = document.body; const data = body.getAttribute("data-theme"); const initTheme = (state) => { if (state === "dark") { body.setAttribute("data-theme", "dark"); } else if (state === "light") { body.removeAttribute("data-theme"); } else { localStorage.setItem("theme", data); } }; initTheme(localStorage.getItem("theme")); setTimeout(() => body.classList.remove("notransition"), 75); </script> <div class="navbar" role="navigation"> <nav class="menu"> <input type="checkbox" id="menu-trigger" class="menu-trigger" /> <label for="menu-trigger"> <span class="menu-icon"> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <path d="M64,384H448V341.33H64Zm0-106.67H448V234.67H64ZM64,128v42.67H448V128Z" /> </svg> </span> </label> <a id="mode"> <svg class="mode-sunny" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <title>LIGHT</title> <line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> </svg> <svg class="mode-moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <title>DARK</title> <line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> </svg> </a> <div class="trigger"> <div class="trigger-container"><a class="menu-link" href="/">home</a><a class="menu-link" href="/archive/">archive</a><a class="menu-link" href="https://salkinium.com" target="_blank" rel="noopener" >about</a ><a class="menu-link rss" href="/feed.xml"> <svg xmlns="http://www.w3.org/2000/svg" width="17" height="17" viewBox="0 0 512 512" fill="#ED812E" > <title>RSS</title> <path d="M108.56,342.78a60.34,60.34,0,1,0,60.56,60.44A60.63,60.63,0,0,0,108.56,342.78Z" /> <path d="M48,186.67v86.55c52,0,101.94,15.39,138.67,52.11s52,86.56,52,138.67h86.66C325.33,312.44,199.67,186.67,48,186.67Z" /> <path d="M48,48v86.56c185.25,0,329.22,144.08,329.22,329.44H464C464,234.66,277.67,48,48,48Z" /> </svg> </a> </div> </div> </nav> </div> <div class="wrapper post"> <main class="page-content" aria-label="Content"> <article itemscope itemtype="https://schema.org/BlogPosting"> <header class="header"> <h1 class="header-title" itemprop="headline">The Curious Case of xpcc&#39;s Error Model</h1> <div class="post-meta"> <time datetime="2017-03-04T00:00:00+01:00" itemprop="datePublished"> Mar 04, 2017 </time> <span itemprop="author" itemscope itemtype="https://schema.org/Person"> <span itemprop="name">Niklas Hauser</span> </span> <time hidden datetime="" itemprop="dateModified"> Mar 04, 2017 </time> <span hidden itemprop="publisher" itemtype="Person">Niklas Hauser</span> <span hidden itemprop="image"></span> <span hidden itemprop="mainEntityOfPage"><p>In hindsight it is quite apparent that <a href="https://github.com/roboterclubaachen/xpcc">xpcc</a> and therefore also the <a href="https://twitter.com/RCA_eV">@RCA_eV robot code</a> was missing a good error model. Until now xpcc’s way of dealing with failures included using <code class="language-plaintext highlighter-rouge">static_assert</code> at compile time and returning error codes at runtime whenever it was deemed necessary. We never considered runtime assertions, nor catching hardware errors like the ARM Cortex-M Fault exceptions. We crashed and burned, a few times literally.</p> <p>So what can we do that is simple to use and efficient on AVR and Cortex-M devices, but still powerful enough to be useful? It’s time we thought about our error model.</p> <p><strong>Update 2019: For <a href="https://modm.io">xpcc’s successor modm</a> this error model got improved for efficiency and flexibility, however, the main principle is still the same. <a href="https://modm.io/reference/module/modm-architecture-assert">See the <code class="language-plaintext highlighter-rouge">modm:architecture:assert</code> docs</a>.</strong></p> </span> </div> </header> <div class="page-content" itemprop="articleBody"> <p>In hindsight it is quite apparent that <a href="https://github.com/roboterclubaachen/xpcc">xpcc</a> and therefore also the <a href="https://twitter.com/RCA_eV">@RCA_eV robot code</a> was missing a good error model. Until now xpcc’s way of dealing with failures included using <code class="language-plaintext highlighter-rouge">static_assert</code> at compile time and returning error codes at runtime whenever it was deemed necessary. We never considered runtime assertions, nor catching hardware errors like the ARM Cortex-M Fault exceptions. We crashed and burned, a few times literally.</p> <p>So what can we do that is simple to use and efficient on AVR and Cortex-M devices, but still powerful enough to be useful? It’s time we thought about our error model.</p> <p><strong>Update 2019: For <a href="https://modm.io">xpcc’s successor modm</a> this error model got improved for efficiency and flexibility, however, the main principle is still the same. <a href="https://modm.io/reference/module/modm-architecture-assert">See the <code class="language-plaintext highlighter-rouge">modm:architecture:assert</code> docs</a>.</strong></p> <!--more--> <h2 id="the-problem"> <a href="#the-problem" class="anchor-head"></a> The Problem </h2> <p><a href="http://www.roboterclub.rwth-aachen.de/">The RCA robots</a> are controlled by a number of software components that communicate by Remote Procedure Calls (PRCs) via an event loop locally or over CAN. We call this Cross Platform Component Communication (XPCC) and it’s an under-appreciated (and under-documented) part of the xpcc framework It allows us to distribute components over many microcontrollers if needed and helps us understand what is happening in the robot at runtime by listening in on the CAN bus.</p> <p>However, we are constantly fine tuning our robots before and after a match and if we accidentally leave the CAN bus disconnected the robot turns into a (very expensive) paper weight and we loose the game. It is therefore paramount that we detect this situation on CAN initialization and let the robot emit loud and annoying sounds so that the <del>slaves</del> students can fix it. There are several other places in the initialization that must not fail for the same reason.</p> <p>It wasn’t clear to us how and where to handle this type of failure though. Should the initialization code return an error code? What if we forgot to check it? Isn’t this a recurring problem? It seemed like a good opportunity to heartily consult The Internet™ on the topic of error models, since surely other, smarter people have solved this problem already. Oh boy.</p> <h2 id="the-research"> <a href="#the-research" class="anchor-head"></a> The Research </h2> <p><a href="http://joeduffyblog.com/2016/02/07/the-error-model/">Joe Duffy wrote a fantastically detailed article on the many considerations that went into the error model used in the Midori research project</a>. (You should read his <a href="http://joeduffyblog.com/2015/11/03/blogging-about-midori/">entire series on Midori</a>, there is a lot of gold there.)</p> <p>There are couple of points in there that resonated very strongly with me:</p> <ol> <li><a href="http://joeduffyblog.com/2016/02/07/the-error-model/#unchecked-exceptions">“Unchecked Exceptions”</a>: We can’t use C++ exceptions since the AVR toolchain does not support it. But even if we could, we wouldn’t, for the many reasons pointed out in this section. It’s actually quite horrifying to me how bad a match C++ exception are for a reliable system.</li> <li><a href="http://joeduffyblog.com/2016/02/07/the-error-model/#to-build-a-reliable-system">“To Build a Reliable System”</a>: XPCC deals with failures prominently: RPC delivery can fail, components can decline RPCs (“I’m busy”) or simply fail during their execution (“I couldn’t grab this object”). We have to deal with these failures in order to get a reliable system that doesn’t get stuck on the first failure. You’d be surprised how many failures there can be during a Eurobot game under real world conditions. The fact that we can relatively simply retry actions or ultimately give up and move on is actually quite amazing.</li> <li><a href="http://joeduffyblog.com/2016/02/07/the-error-model/#bugs-arent-recoverable-errors">“Bugs Aren’t Recoverable Errors!”</a>: This was the most important realization for me. When we are talking about the system clock or the CAN bus not initializing correctly, these are bugs. You cannot recover from them and the robot is stuck. However, XPCC failures as described above are recoverable errors and it’s fine for them to happen happen in normal operation.</li> <li><a href="http://joeduffyblog.com/2016/02/07/the-error-model/#abandonment">“Abandonment”</a>: xpcc didn’t have a concept of abandonment and it doesn’t call any libc <code class="language-plaintext highlighter-rouge">exit()</code> functions. There are a couple of <code class="language-plaintext highlighter-rouge">while(1)</code> loops in the vector table (and hard fault handler), but there is no controlled teardown (with reporting) of failures. It’s crash’n’burn all the way down.</li> </ol> <p>Of course Midori’s goal of writing an entire operating system from scratch is a little higher on the scale of epicness than us coding our robots. And considering that they rolled their own language and compiler to implement this error model, it’s pretty clear that our solution can’t really compete with their very thorough approach.</p> <h2 id="the-proposal"> <a href="#the-proposal" class="anchor-head"></a> The Proposal </h2> <p>We propose to continue returning error codes for recoverable errors but use assertions for bugs which can lead to abandonment. There is something appealing about the simplicity of using an <code class="language-plaintext highlighter-rouge">assert(condition)</code> in the code, so we decided to expand the function signature:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xpcc_assert</span><span class="p">(</span><span class="n">bool</span> <span class="n">condition</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">module</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">failure</span><span class="p">,</span> <span class="kt">uintptr_t</span> <span class="n">context</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div> <p>Yes, we’re using C-style <code class="language-plaintext highlighter-rouge">"strings"</code> to declare the assertion location and failure type instead of using enumerations or similar. We came to the conclusion that it is a lot simpler to encode structured information using strings rather than keeping all error enumerations in sync to prevent duplicates. Strings also consume significantly less memory than using a stringified test condition or a “pretty” function string, or even just <code class="language-plaintext highlighter-rouge">__LINE__</code> and <code class="language-plaintext highlighter-rouge">__FILE__</code> strings. It also makes it trivial to print the failure. It made sense to us that the developer writing code with assertions categorizes the failure for the developer calling the code. It’s often difficult to assess the exact reason <em>why</em> an assertion failed from the stringified test condition alone.</p> <p>When an assertion fails, it calls all registered assertion handlers one by one. Assertion handlers have this signature:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Abondonment</span> <span class="nf">handler</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">module</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">failure</span><span class="p">,</span> <span class="kt">uintptr_t</span> <span class="n">context</span><span class="p">);</span>
</code></pre></div></div> <p>The identifiers allows these failure handlers to assess the scope and type of failure programmatically and return <code class="language-plaintext highlighter-rouge">Fail</code>, <code class="language-plaintext highlighter-rouge">DontCare</code> or <code class="language-plaintext highlighter-rouge">Ignore</code>. If any of them returns <code class="language-plaintext highlighter-rouge">Fail</code> or all of them return <code class="language-plaintext highlighter-rouge">DontCare</code>, then execution is abandoned. Otherwise if at least one of them <code class="language-plaintext highlighter-rouge">Ignore</code> the assertion, execution continues. This allows us to ignore some select failures that we don’t care about.</p> <p>The abandonment handler is called last and has the same signature as the assertion handler. It is required that all assertion handlers are not blocking, so that they can all get called, and whatever blocking code is required can then run in the abandonment handler, where execution is trapped until the next reset anyway.</p> <h2 id="the-example"> <a href="#the-example" class="anchor-head"></a> The Example </h2> <p>For our problem with CAN bus timout, an assertion is called and the <code class="language-plaintext highlighter-rouge">context</code> contains the instance of the CAN (<code class="language-plaintext highlighter-rouge">1</code> or <code class="language-plaintext highlighter-rouge">2</code>) that failed initialization.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Can1</span><span class="o">::</span><span class="n">initialize</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// [...] initialize CAN peripheral</span>
    <span class="c1">// wait for CAN bus to be ready</span>
    <span class="kt">int</span> <span class="n">deadlockPreventer</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span> <span class="c1">// max ~1ms</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">not</span> <span class="n">busIsReady</span><span class="p">()</span> <span class="n">and</span> <span class="p">(</span><span class="n">deadlockPreventer</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">xpcc</span><span class="o">::</span><span class="n">delayMicroseconds</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="n">xpcc_assert</span><span class="p">(</span><span class="n">deadlockPreventer</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"can"</span><span class="p">,</span> <span class="s">"init"</span><span class="p">,</span> <span class="s">"timeout"</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>An assertion handler then compares the first three characters to <code class="language-plaintext highlighter-rouge">"can"</code> and return <code class="language-plaintext highlighter-rouge">Fail</code> and execution is abandoned:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xpcc</span><span class="o">::</span><span class="n">Abandonment</span> <span class="nf">can_assertion_handler</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">module</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uintptr_t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s">"can"</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">xpcc</span><span class="o">::</span><span class="n">Abandonment</span><span class="o">::</span><span class="n">Fail</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">xpcc</span><span class="o">::</span><span class="n">Abandonment</span><span class="o">::</span><span class="n">DontCare</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Register assertion handler with system</span>
<span class="n">XPCC_ASSERTION_HANDLER</span><span class="p">(</span><span class="n">can_assertion_handler</span><span class="p">);</span>
</code></pre></div></div> <p>The abandon handler finally prints the failed assertion to the log and makes some loud bleepy noises:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">xpcc_abandon</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">module</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">failure</span><span class="p">,</span> <span class="kt">uintptr_t</span> <span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">XPCC_LOG_ERROR</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">"Assertion '%s.%s.%s' (0x%p) failed! Abandoning!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                          <span class="n">module</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">failure</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
    <span class="c1">// Make some noise!</span>
    <span class="n">PiezoBuzzer</span><span class="o">::</span><span class="n">setOutput</span><span class="p">();</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PiezoBuzzer</span><span class="o">::</span><span class="n">set</span><span class="p">();</span>
        <span class="n">xpcc</span><span class="o">::</span><span class="n">delayMilliseconds</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
        <span class="n">PiezoBuzzer</span><span class="o">::</span><span class="n">reset</span><span class="p">();</span>
        <span class="n">xpcc</span><span class="o">::</span><span class="n">delayMilliseconds</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>On an STM32 this prints:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Assertion 'can.init.timeout' (0x00000001) failed! Abandoning!
</code></pre></div></div> <p>We also log internal robot state via UART backed by a ring buffer of fixed size. If too much is logged at once, the buffer runs out of space, and we loose log output, which is undesirable. However, we cannot wait synchronously for space to become available in the buffer either, as this would impair the timing loops in our robot code. Since continuing the game is obviously more important than preserving the log, we therefore ignore this failure in game mode:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Abandonment</span> <span class="nf">logger_buffer_overflow</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">module</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">failure</span><span class="p">,</span> <span class="kt">uintptr_t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s">"uart"</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="n">and</span>
        <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="s">"tx"</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="n">and</span>
        <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">failure</span><span class="p">,</span> <span class="s">"overflow"</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">xpcc</span><span class="o">::</span><span class="n">Abandonment</span><span class="o">::</span><span class="n">Ignore</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">xpcc</span><span class="o">::</span><span class="n">Abandonment</span><span class="o">::</span><span class="n">DontCare</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Register assertion handler with system</span>
<span class="n">XPCC_ASSERTION_HANDLER</span><span class="p">(</span><span class="n">logger_buffer_overflow</span><span class="p">);</span>
</code></pre></div></div> <p>Note how the assertion handlers only react to the failures they care about and otherwise leaving the decision to other, potentially more specialized handlers.</p> <h2 id="the-implementation"> <a href="#the-implementation" class="anchor-head"></a> The Implementation </h2> <p>Since we want to use assertions a lot in our code, but still keep the code size overhead as low as possible, we use two optimizations: <code class="language-plaintext highlighter-rouge">xpcc_assert</code> is actually a macro which:</p> <ol> <li>moves the condition test out of the function into the calling context, and</li> <li>concatenates the module, location and failure strings into one big string.</li> </ol> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define xpcc_assert(condition, module, location, failure, context) \
    if (condition) {} else { \
        xpcc_assert_fail(FLASH_STORAGE(module "\0" location "\0" failure), (uintptr_t) context); }
</code></pre></div></div> <p>We cannot change that the test condition has to always be evaluated, but we don’t have to pass it as an argument into the assert function. That would require the compiler to cast the test result into a numeric value and move it into a register to comply with the ABI. If we branch outside of the assertion, the compiler can test the CPU flags directly.</p> <p>Similarly, by concatenating the assertion identifier strings into one long string, the compiler only has to populate one register so it can save the code that fetches the other two pointers. (ARMv7-M use literal pools for constants, while AVRs generate them ad-hoc using several load instructions, both actually quite expensive for code size.) The <code class="language-plaintext highlighter-rouge">xpcc_assert_fail</code> function then breaks the long string apart and passes them to the failure handlers as individual arguments.</p> <p>Also note the <code class="language-plaintext highlighter-rouge">FLASH_STORAGE</code> macro, which keeps the strings in Flash on AVRs and thus does not use any SRAM as it would normally do. This means that assertion handlers on AVRs need to use the <code class="language-plaintext highlighter-rouge">*_P</code> variants of the string compare functions. This is an acceptable caveat for us, since assertion and abandon handlers are part of the application and not the library and there don’t need to be shared across platforms.</p> <h3 id="registering-assertion-handlers"> <a href="#registering-assertion-handlers" class="anchor-head"></a> Registering assertion handlers </h3> <p>The tricky part is how to register the assertion handlers to the <code class="language-plaintext highlighter-rouge">xpcc_assert_fail</code> function. We use the linker to collect all assertion handlers across the entire executable and place pointers to them into the same linker section using the <code class="language-plaintext highlighter-rouge">XPCC_ASSERTION_HANDLER</code> macro. Note how it forces the assertion handler to have the right signature by using the <code class="language-plaintext highlighter-rouge">xpcc::AssertionHandler</code> type:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define XPCC_ASSERTION_HANDLER(handler) \
    __attribute__((section(XPCC_ASSERTION_LINKER_SECTION), used)) \
    const xpcc::AssertionHandler \
    handler ## _assertion_handler_ptr = handler
</code></pre></div></div> <p>Adding custom linker sections to ARM Cortex-M devices is trivial, especially since xpcc generates the linkerscript from a central template. It’s literally just adding these lines:</p><pre><code class="language-ld">.assertion : ALIGN(4)
{
    __assertion_table_start = .;
    KEEP(*(.assertion))
    __assertion_table_end = .;
} &gt;FLASH
</code></pre><p>The code for <code class="language-plaintext highlighter-rouge">xpcc_assert_fail</code> which calls all assertion handlers is pretty simple. <code class="language-plaintext highlighter-rouge">xpcc_abandon</code> here is a weak function that can be overwritten by the application:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="n">AssertionHandler</span> <span class="n">__assertion_table_start</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">AssertionHandler</span> <span class="n">__assertion_table_end</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">xpcc_assert_fail</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">identifier</span><span class="p">,</span> <span class="kt">uintptr_t</span> <span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// split up the identifier back into three pointers</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">module</span> <span class="o">=</span> <span class="n">identifier</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">location</span> <span class="o">=</span> <span class="n">module</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">module</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">failure</span> <span class="o">=</span> <span class="n">location</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// initialize with DontCare in case no assertion handlers were registered</span>
    <span class="n">Abandonment</span> <span class="n">state</span> <span class="o">=</span> <span class="n">Abandonment</span><span class="o">::</span><span class="n">DontCare</span><span class="p">;</span>
    <span class="c1">// call all assertion handlers</span>
    <span class="n">AssertionHandler</span> <span class="o">*</span> <span class="n">handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__assertion_table_start</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">handler</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">__assertion_table_end</span><span class="p">;</span> <span class="n">handler</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">state</span> <span class="o">|=</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="n">module</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">failure</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// abandon if all returned DontCare, or any returned</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">Abandonment</span><span class="o">::</span><span class="n">DontCare</span> <span class="n">or</span>
        <span class="n">state</span> <span class="o">&amp;</span> <span class="n">Abandonment</span><span class="o">::</span><span class="n">Fail</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">xpcc_abandon</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">failure</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This code is the same for Linux and OS X, except we need to adapt the section names, so that the dynamic linker can generate symbols for these custom sections at load time. The section names must not have a period in their name and the symbols follow a certain naming convention, all of which are different for these platforms:</p> <table> <thead> <tr> <th style="text-align: center">platform</th> <th style="text-align: center">section name</th> <th style="text-align: center">symbol names</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">AVR <br /> Cortex-M</td> <td style="text-align: center"><code class="language-plaintext highlighter-rouge">".assertion"</code></td> <td style="text-align: center"><code class="language-plaintext highlighter-rouge">__assertion_table_start</code> <br /> <code class="language-plaintext highlighter-rouge">__assertion_table_end</code></td> </tr> <tr> <td style="text-align: center">OS X</td> <td style="text-align: center"><code class="language-plaintext highlighter-rouge">"__DATA,xpcc_assertion"</code></td> <td style="text-align: center"><code class="language-plaintext highlighter-rouge">"section$start$__DATA$xpcc_assertion"</code><br /><code class="language-plaintext highlighter-rouge">"section$end$__DATA$xpcc_assertion"</code></td> </tr> <tr> <td style="text-align: center">Linux</td> <td style="text-align: center"><code class="language-plaintext highlighter-rouge">"xpcc_assertion"</code></td> <td style="text-align: center"><code class="language-plaintext highlighter-rouge">__start_xpcc_assertion</code> <br /> <code class="language-plaintext highlighter-rouge">__stop_xpcc_assertion</code></td> </tr> </tbody> </table> <p>To access the symbols on OS X you need to bind them to their assembly name:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="n">AssertionHandler</span> <span class="n">__assertion_table_start</span> <span class="nf">__asm</span><span class="p">(</span><span class="s">"section$start$__DATA$xpcc_assertion"</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">AssertionHandler</span> <span class="n">__assertion_table_end</span> <span class="nf">__asm</span><span class="p">(</span><span class="s">"section$end$__DATA$xpcc_assertion"</span><span class="p">);</span>
</code></pre></div></div> <p><strong>3 Feb 2018 – Update:</strong> We define some default assertion handlers inside the xpcc library source, which is first compiled into the <code class="language-plaintext highlighter-rouge">libxpcc.a</code> archive, then linked against by the application. However, the linker by default only searches archives for <em>referenced</em> symbols, which our handlers are obviously not, and therefore these handlers are omitted from the final executable. This can cause some very subtle and annoying bugs!</p> <p>The solution is to wrap the archive in <code class="language-plaintext highlighter-rouge">-Wl,--whole-archive -lxpcc -Wl,--no-whole-archive</code>. The <a href="https://sourceware.org/binutils/docs/ld/Options.html#Options">GNU ld documentation</a> describes this quite well: “For each archive mentioned on the command line after the <code class="language-plaintext highlighter-rouge">--whole-archive</code> option, include every object file in the archive in the link, rather than searching the archive for the required object files.”</p> <p>Note that this just makes all symbols <em>visible</em> to the linker, it does not force inclusion of all symbols, especially not if you pass the <code class="language-plaintext highlighter-rouge">--gc-sections</code> option as well.</p> <h4 id="avrs-are-annoying"> <a href="#avrs-are-annoying" class="anchor-head"></a> AVRs are annoying </h4> <p>The most pain was getting this to work on AVRs though. The issue is that their address space is limited to 16-bit and instructions and data are placed into physically separate memories each with their own 16-bit address space. Or in other words, <a href="https://en.wikipedia.org/wiki/Harvard_architecture">AVRs implement a Harvard architecture</a> and one does not simply read data from the instruction memory on a Harvard architecture. AVRs load their read-only data from Flash to SRAM at boot time, <em>including all strings</em>, since there is no way of telling from a 16-bit address whether it points to the instruction or the data memory. Hey, don’t look at me, it’s a 8-bit CPU, you get what you pay for!</p> <p>This does, however, mean that there now need to be two versions of the same section in memory. GNU ld deals with this by allowing to specify two addresses per section: <a href="https://sourceware.org/binutils/docs/ld/Output-Section-LMA.html">the virtual address (VMA) and the load address (LMA)</a>. For read-only data the LMA is in Flash somewhere, while the VMA is in SRAM and they are both <em>different</em> memories even when the section addresses overlap numerically!</p> <p>Let me illustrate the problem with a simplified excerpt of the linkerscript itself. You can see the <code class="language-plaintext highlighter-rouge">.data</code> section is appended onto the <code class="language-plaintext highlighter-rouge">text</code> memory after the <code class="language-plaintext highlighter-rouge">.text</code> section (LMA), but placed into the <code class="language-plaintext highlighter-rouge">data</code> memory too (VMA):</p><pre><code class="language-ld">MEMORY
{
    text   (rx)   : ORIGIN = 0, LENGTH = 8k
    data   (rw!x) : ORIGIN = 0x800060, LENGTH = 0xffa0
}
/* everything in Flash */
.text :
{
    *(.progmem*) /* things tagged with `PROGMEM` go here! */
    *(.text*)    /* the actual code */
} &gt; text
/* everything in SRAM */
.data :
{
    *(.data*)    /* modifiable data */
    *(.rodata*)  /* read-only data */
} &gt; data AT&gt; text
</code></pre><p>This is shown more obviously in the listing of the linked executable:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Sections:
Idx Name            Size      VMA       LMA       File off  Algn
  0 .text           00000850  00000000  00000000  000000b4  2**1
  1 .data           00000014  00800100  00000850  00000904  2**0
</code></pre></div></div> <p>So what we need to do is simply™ append our section to the <code class="language-plaintext highlighter-rouge">text</code> memory after the <code class="language-plaintext highlighter-rouge">.data</code> section, right? Well… <code class="language-plaintext highlighter-rouge">avr-gcc</code> uses its own linkerscripts (which can be found in <code class="language-plaintext highlighter-rouge">avr-binutils/avr/lib/ldscripts</code>), so we cannot just add our custom section as we did for the ARM platform. Fortunately, GNU ld allows to extend default linkerscript using the <a href="https://sourceware.org/binutils/docs/ld/Miscellaneous-Commands.html"><code class="language-plaintext highlighter-rouge">INSERT [ AFTER | BEFORE ] output_section</code> command</a>. We can pass this script to <code class="language-plaintext highlighter-rouge">avr-ld</code> via the <code class="language-plaintext highlighter-rouge">-T</code> option:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SECTIONS
{
    .xpcc_assertion : ALIGN(2)
    {
        __assertion_table_start = .;
        KEEP(*(.assertion))
        __assertion_table_end = .;
    }
}
INSERT AFTER .data
</code></pre></div></div> <p>This places the section exactly where we want it:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Sections:
Idx Name            Size      VMA       LMA       File off  Algn
  0 .text           00000850  00000000  00000000  000000b4  2**1
  1 .data           00000014  00800100  00000850  00000904  2**0
  2 .xpcc_assertion 00000006  00000864  00000864  00000918  2**1
</code></pre></div></div> <p>The code for <code class="language-plaintext highlighter-rouge">xpcc_assert_fail</code> also needs to be adapted for reading from Flash:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// use *_P string functions from &lt;avr/pgmspace.h&gt;</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">module</span> <span class="o">=</span> <span class="n">identifier</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">location</span> <span class="o">=</span> <span class="n">module</span> <span class="o">+</span> <span class="n">strlen_P</span><span class="p">(</span><span class="n">module</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">failure</span> <span class="o">=</span> <span class="n">location</span> <span class="o">+</span> <span class="n">strlen_P</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">// we can't access the function pointer directly, cos it's not in RAM</span>
<span class="n">AssertionHandler</span> <span class="o">*</span> <span class="n">table_addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__assertion_table_start</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(;</span> <span class="n">table_addr</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">__assertion_table_end</span><span class="p">;</span> <span class="n">table_addr</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// first fetch the function pointer from flash, then jump to it</span>
    <span class="n">AssertionHandler</span> <span class="n">handler</span> <span class="o">=</span> <span class="p">(</span><span class="n">AssertionHandler</span><span class="p">)</span> <span class="n">pgm_read_word</span><span class="p">(</span><span class="n">table_addr</span><span class="p">);</span>
    <span class="n">state</span> <span class="o">|=</span> <span class="n">handler</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">failure</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Well, that was easy. This code works fine until the AVR <code class="language-plaintext highlighter-rouge">.text + .data</code> section size gets so large that it pushes the <code class="language-plaintext highlighter-rouge">.xpcc_assertion</code> section above the 64kB address boundary (AVRs can have up to 128kB Flash, don’t ask /o\). Then <code class="language-plaintext highlighter-rouge">table_addr</code> would wrap around and read garbage. For us this is an acceptable caveat. I mean, if you really get to <em>that</em> point, you should sit down and ask yourself some hard questions about your life.</p> <h2 id="the-evaluation"> <a href="#the-evaluation" class="anchor-head"></a> The Evaluation </h2> <p>So what are the properties of our solution?</p> <h3 id="overhead"> <a href="#overhead" class="anchor-head"></a> Overhead </h3> <p>Our assertions are a simple concept, with a very low overall code size overhead and when the assertion succeeds also low execution time penalty, even on AVRs. There is obviously an unavoidable overhead for checking the test condition, safety doesn’t come for free. But what is the code size penalty per assertion in the code? We’ll benchmark using this assertion:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xpcc_assert</span><span class="p">(</span><span class="n">timeout</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"can"</span><span class="p">,</span> <span class="s">"init"</span><span class="p">,</span> <span class="s">"timeout"</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div> <p>In AVRs, the assembly shows a simple condition check, a branch over for when the assertion passes, otherwise 4 loads and a call to <code class="language-plaintext highlighter-rouge">xpcc_assert_fail</code>:</p><pre><code class="language-asm">2e4:   81 11       cpse r24, r1    ; condition check
2e6:   05 c0       rjmp .+10       ; branch over
2e8:   60 e0       ldi  r22, 0x01  ; context is 16-bit
2ea:   70 e0       ldi  r23, 0x00  ; constant and 1
2ec:   83 ea       ldi  r24, 0xA3  ; load ptr to progmem string
2ee:   90 e0       ldi  r25, 0x00  ; progmem below text, hence 0 here
2f0:   5d d1       rcall   .+698   ; call &lt;xpcc_assert_fail&gt;
</code></pre><p>On ARMv7-M the assembly is a little different. The simple condition check branches over if the assertion passes, otherwise <code class="language-plaintext highlighter-rouge">mov</code>es and loads the two arguments before loading and calling <code class="language-plaintext highlighter-rouge">xpcc_assert_fail</code>:</p><pre><code class="language-asm">80001ca:   f003 01ff and.w r1, r3, #255  ; condition check
80001cc:   b913      cbnz  r3, 80001d8   ; branch over
80001d0:   2100      movs  r1, #1        ; context is constant and 1
80001d2:   4803      ldr   r0, [pc, #12] ; load value @ 80001e0
80001d4:   4b03      ldr   r3, [pc, #12] ; load value @ 80001e4
80001d6:   4798      blx   r3            ; call &lt;xpcc_assert_fail&gt;
...                                      ; hey look, a literal pool
80001e0:   08000d8c  .word   0x08000d8c  ; pointer to string
80001e4:   08000521  .word   0x08000521  ; pointer to function
</code></pre><p>The minimal code overheads per assertion call are 14B on AVR and 20B on ARMv7-M, but depending on the complexity of the test condition, more code can be generated. However, if an assertion fails a time penalty exists: All assertion handlers will be called always. Furthermore everything executes on the currently active stack, maybe we’ll change that in the future.</p> <h3 id="atomicity"> <a href="#atomicity" class="anchor-head"></a> Atomicity </h3> <p>A failed assert disables interrupts since its implementation is not reentrant! Also keep in mind that our ARMv7-M HardFault handler also eventually calls <code class="language-plaintext highlighter-rouge">xpcc_assert_fail</code> and due to its hardcoded priority, it cannot be interrupted anyway. So it’s best to always have the same behavior everywhere.</p> <p>The abandon handler may choose to re-enable interrupts if required, for example to allow the UART driver to print the failure reason. Furthermore if mission critical systems need to continue running, then the abandon handler can keep them alive. For us this would include maybe putting the robot in a mechanically safe configuration before shutting down the motor drivers.</p> <h3 id="nesting"> <a href="#nesting" class="anchor-head"></a> Nesting </h3> <p>Failing an assertion while already handling a failed assertion is not allowed and leads to an immediate termination (aka. an infinte loop). This can happen quicker than you think. Remember the abandon handler printing the failure over UART? What if the failure is the UART buffer overflowing? Yeah, that.</p> <h3 id="documentation"> <a href="#documentation" class="anchor-head"></a> Documentation </h3> <p>There is no way of knowing if the function you’re calling can fail an assert, except from documentation. This can be a big issue, especially when inadvertently failing assertions from inside an interrupt context, which would call all assertion handlers and the abandon handler from this context too.</p> <p>This is a difficult problem to fix in general, but it doesn’t need to be solved perfectly: The application could be compiled in “assertion debug mode” where every assertion calls an “awareness” handler regardless of the test condition. This could also help with profiling assertion usage.</p> <h3 id="ignoring-assertions"> <a href="#ignoring-assertions" class="anchor-head"></a> Ignoring Assertions </h3> <p>It is a bit weird that contrary to C++ exceptions, the caller cannot handle the assertion directly at the call site, but only globally. We tried to make it easier by allowing declarations of global assertion handlers anywhere, so that they can at least be declared closer to the call site. But if you ignore an assertion, execution will continue, and there is no way to let the caller know that an assertion occurred, except to set a flag in shared memory:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">bool</span> <span class="n">assertion_failed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="n">Abandonment</span> <span class="nf">ignore_uart_buffer</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uintptr_t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s">"uart"</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">assertion_failed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">xpcc</span><span class="o">::</span><span class="n">Abandonment</span><span class="o">::</span><span class="n">Ignore</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">xpcc</span><span class="o">::</span><span class="n">Abandonment</span><span class="o">::</span><span class="n">DontCare</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">XPCC_ASSERTION_HANDLER</span><span class="p">(</span><span class="n">ignore_uart_buffer</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">caller_function</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">call_function_with_assertion</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">assertion_failed</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assertion_failed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="c1">// do something else</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Admittedly, this is an edge case and the vast amount of assertion failures cannot be ignored, as there is nothing the caller can do and abandonment is exactly the right choice.</p> <h3 id="abandonment-causes"> <a href="#abandonment-causes" class="anchor-head"></a> Abandonment Causes </h3> <p>As food for thought, here are the causes of abandonment in Midori and the possible implementations in xpcc. Note that AVRs don’t have fault handlers, they just quietly choke on their bits until they die in a plume of blue smoke.</p> <table> <thead> <tr> <th style="text-align: left">bug description</th> <th style="text-align: left">xpcc implementation</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">An incorrect cast</td> <td style="text-align: left">undetectable at runtime</td> </tr> <tr> <td style="text-align: left">An attempt to dereference a <code class="language-plaintext highlighter-rouge">null</code> pointer</td> <td style="text-align: left">Hard Fault or unpredictable (AVR)</td> </tr> <tr> <td style="text-align: left">An attempt to access an array outside of its bounds</td> <td style="text-align: left">detectable only with wrapper code</td> </tr> <tr> <td style="text-align: left">Divide-by-zero</td> <td style="text-align: left">Hard Fault or <code class="language-plaintext highlighter-rouge">xpcc_assert</code> (software)</td> </tr> <tr> <td style="text-align: left">An unintended mathematical over/underflow</td> <td style="text-align: left">detectable only with wrapper code</td> </tr> <tr> <td style="text-align: left">Out-of-memory</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">xpcc_assert</code> in dynamic allocator</td> </tr> <tr> <td style="text-align: left">Stack overflow</td> <td style="text-align: left">Hard Fault or undetectable (AVR)</td> </tr> <tr> <td style="text-align: left">Explicit abandonment</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">xpcc_assert(false, ...)</code></td> </tr> <tr> <td style="text-align: left">Contract failures</td> <td style="text-align: left">not a part of C/C++ (sadly)</td> </tr> <tr> <td style="text-align: left">Assertion failures</td> <td style="text-align: left">uh, well, <code class="language-plaintext highlighter-rouge">xpcc_assert</code></td> </tr> </tbody> </table> <h2 id="the-conclusion"> <a href="#the-conclusion" class="anchor-head"></a> The Conclusion </h2> <p>Our solution isn’t anywhere near as polished and well thought out as Midori’s, but considering our restrictions it’s not completely terrible. I would claim that it works for enough of our use cases to be useful and it allows for a lot of flexibility in responding to failed assertions. Our approach of encoding the failure as a string is novel in the context of microcontrollers and is very efficient too.</p> <p>We see this as a good enough alternative to C++ exceptions and will be using it a lot in xpcc.</p> </div> </article> </main> <nav class="post-nav"> <a class="post-nav-item post-nav-prev" href="/computing-baudrates-at-compile-time/" > <div class="nav-arrow">Previous</div> <span class="post-title">Computing and Asserting Baudrate Settings at Compile Time</span> </a> <a class="post-nav-item post-nav-next" href="/modm-devices/"> <div class="nav-arrow">Next</div> <span class="post-title">Introducing modm-devices: hardware descriptions for AVR and STM32 devices</span> </a> </nav> <footer class="footer"> <a class="footer_item" href="/feed.xml">rss</a> <span class="footer_item">&copy; 2022</span> <small class="footer_copyright"> <!-- Klisé Theme: https://github.com/piharpi/jekyll-klise --> <a href="https://github.com/piharpi/jekyll-klise" target="_blank" rel="noreferrer noopener" >klisé</a > theme on <a href="https://jekyllrb.com" target="_blank" rel="noreferrer noopener" >jekyll</a > </small> </footer> <script src="/assets/js/main.js" defer="defer"></script> </div> </body> </html>
